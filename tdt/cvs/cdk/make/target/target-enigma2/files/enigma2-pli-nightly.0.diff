diff --git a/configure.ac b/configure.ac
index 19b494e..6163284 100644
--- a/configure.ac
+++ b/configure.ac
@@ -34,10 +34,50 @@ AC_ARG_WITH(gstversion,
 	AS_HELP_STRING([--with-gstversion],[use gstreamer version (major.minor)]),
 	[GST_MAJORMINOR=$withval],[GST_MAJORMINOR=0.10])
 
-PKG_CHECK_MODULES(BASE, [freetype2 fribidi gstreamer-$GST_MAJORMINOR gstreamer-pbutils-$GST_MAJORMINOR libdvbsi++ libpng libxml-2.0 sigc++-1.2 libssl libcrypto])
+AC_ARG_ENABLE(libeplayer3,
+	[  --enable-libeplayer3          enable TDT libeplayer3 as player engine supportt],
+	[AC_DEFINE(ENABLE_LIBEPLAYER3,1,[enable TDT libeplayer3 as player engine support])])
+
+AM_CONDITIONAL(ENABLE_LIBEPLAYER3,test "$enable_libeplayer3" = "yes")
+if test "$enable_libeplayer3" = "yes"; then
+	AC_DEFINE(ENABLE_LIBEPLAYER3,1,[include TDT libeplayer3 as player engine support])
+fi
+
+AC_ARG_ENABLE(mediafwgstreamer,
+	[  --enable-mediafwgstreamer      enable gstreamer as player engine supportt],
+	[AC_DEFINE(ENABLE_MEDIAFWGSTREAMER,1,[enable gstreamer as player engine support])])
+
+AM_CONDITIONAL(ENABLE_MEDIAFWGSTREAMER,test "$enable_mediafwgstreamer" = "yes")
+if test "$enable_mediafwgstreamer" = "yes"; then
+	AC_DEFINE(ENABLE_MEDIAFWGSTREAMER,1,[include gstreamer as player engine support])
+fi
+
+if test "$enable_mediafwgstreamer" = "yes"; then
+	PKG_CHECK_MODULES(BASE, [freetype2 fribidi gstreamer-$GST_MAJORMINOR gstreamer-pbutils-$GST_MAJORMINOR libdvbsi++ libpng libxml-2.0 sigc++-1.2 libssl libcrypto])
+else
+	PKG_CHECK_MODULES(BASE, [freetype2 fribidi libdvbsi++ libpng libxml-2.0 sigc++-1.2 libssl libcrypto])
+fi
 PKG_CHECK_MODULES(LIBDDVD, libdreamdvd, HAVE_LIBDDVD="yes", HAVE_LIBDDVD="no")
 AM_CONDITIONAL(HAVE_LIBDDVD, test "$HAVE_LIBDDVD" = "yes")
 
+AC_ARG_ENABLE([tf7700],
+	[AS_HELP_STRING(--enable-tf7700,    enable topfield tf7700 stuff)],
+	[case "${enableval}" in
+		yes) enable_tf7700=true ;;
+		no) enable_tf7700=false ;;
+		*) AC_MSG_ERROR([bad value ${enableval} for --enable-tf7700]) ;;
+	esac])
+AM_CONDITIONAL([ENABLE_TF7700], [test x$enable_tf7700 = xtrue])
+
+AC_ARG_ENABLE([cuberevo],
+	[AS_HELP_STRING(--enable-cuberevo,    enable cuberevo stuff)],
+	[case "${enableval}" in
+		yes) enable_cuberevo=true ;;
+		no) enable_cuberevo=false ;;
+		*) AC_MSG_ERROR([bad value ${enableval} for --enable-cuberevo]) ;;
+	esac])
+AM_CONDITIONAL([ENABLE_CUBEREVO], [test x$enable_cuberevo = xtrue])
+
 AC_CHECK_LIB([dl], [dlopen], [LIBDL_LIBS="-ldl"], [AC_MSG_ERROR([Could not find libdl])])
 AC_SUBST(LIBDL_LIBS)
 AC_CHECK_LIB([jpeg], [jpeg_set_defaults], [LIBJPEG_LIBS="-ljpeg"], [AC_MSG_ERROR([Could not find libjpeg])])
@@ -86,6 +126,15 @@ if test x"$withcolorlcd" != xno ; then
 fi
 AM_CONDITIONAL(HAVE_COLORLCD, test x"$withcolorlcd" != xno)
 
+AC_ARG_WITH(graphlcd,
+	AC_HELP_STRING([--with-graphlcd], [use GraphLCD color display, yes or no]),
+	[[withgraphlcd=$withval]],
+	[[withgraphlcd=no]]
+)
+if test x"$withgraphlcd" != xno ; then
+	AC_DEFINE(HAVE_GRAPHLCD, 1,[Define when using a GraphLCD color display device])
+fi
+AM_CONDITIONAL(HAVE_GRAPHLCD, test x"$withgraphlcd" != xno)
 
 AC_ARG_WITH(oldpvr,
 	AC_HELP_STRING([--with-oldpvr], [use /dev/misc/pvr instead of /dev/dvb/adapterX/dvrX, yes or no]),
@@ -206,8 +255,6 @@ lib/python/Plugins/Extensions/PicturePlayer/data/Makefile
 lib/python/Plugins/Extensions/SocketMMI/Makefile
 lib/python/Plugins/Extensions/SocketMMI/meta/Makefile
 lib/python/Plugins/Extensions/SocketMMI/src/Makefile
-lib/python/Plugins/Extensions/TuxboxPlugins/Makefile
-lib/python/Plugins/Extensions/TuxboxPlugins/meta/Makefile
 lib/python/Plugins/PLi/Makefile
 lib/python/Plugins/SystemPlugins/CommonInterfaceAssignment/Makefile
 lib/python/Plugins/SystemPlugins/CommonInterfaceAssignment/meta/Makefile
@@ -244,6 +291,8 @@ lib/python/Plugins/SystemPlugins/Videomode/Makefile
 lib/python/Plugins/SystemPlugins/Videomode/meta/Makefile
 lib/python/Plugins/SystemPlugins/WirelessLan/Makefile
 lib/python/Plugins/SystemPlugins/WirelessLan/meta/Makefile
+lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile
+lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile
 lib/python/Tools/Makefile
 po/Makefile
 main/Makefile
diff --git a/data/skin_display_default.xml b/data/skin_display_default.xml
index ed23576..b3305ec 100644
--- a/data/skin_display_default.xml
+++ b/data/skin_display_default.xml
@@ -22,27 +22,30 @@
 
 <!-- template -->
 	<screen name="SummaryClockPanel">
-		<widget source="global.CurrentTime" render="Label" position="right" size="60,*" font="FdLcD;24" halign="right" valign="top" noWrap="1">
+		<widget source="global.CurrentTime" render="Label" position="right" size="160,*" font="FdLcD;44" halign="right" valign="top" noWrap="1">
 			<convert type="ClockToText"></convert>
 		</widget>
-		<widget source="session.RecordState" render="FixedLabel" text="Rec" position="4,12" size="24,12" font="FdLcD;12" zPosition="1" noWrap="1">
+		<widget source="session.RecordState" render="FixedLabel" text="Rec" position="140,20" size="60,36" foregroundColor="#f23d21" font="FdLcD;35" zPosition="1" noWrap="1">
 			<convert type="ConditionalShowHide">Blink</convert>
 		</widget>
 	</screen>
 
 <!-- main-->
 	<screen name="InfoBarSummary" position="fill">
-		<widget source="session.CurrentService" render="Label" position="top" size="*,21" font="FdLcD;20" halign="left" noWrap="1">
+		<widget source="session.CurrentService" render="Picon" position="0,165" zPosition="1" size="100,60" alphatest="on">
+				<convert type="ServiceName">Reference</convert>
+		</widget>
+		<widget source="session.CurrentService" render="Label" position="top" size="*,81" font="FdLcD;40" halign="center" foregroundColor="#ffff7f" >
 			<convert type="ServiceName">Name</convert>
 		</widget>
-		<widget source="session.Event_Now" render="Label" position="top" size="*,15" font="FdLcD;14" halign="left" noWrap="1">
+		<widget source="session.Event_Now" render="Label" position="top" size="*,61" font="FdLcD;30" halign="center" >
 			<convert type="EventName">Name</convert>
 		</widget>
-		<widget source="session.Event_Now" render="Progress" position="top" size="*,4" borderWidth="1" >
+		<widget source="session.Event_Now" render="Progress" position="top" size="*,14" borderWidth="3" >
 			<convert type="EventTime">Progress</convert>
 		</widget>
-		<panel position="bottom" size="*,24" name="SummaryClockPanel">
-			<widget source="session.Event_Now" render="Label" position="4,0" size="40,12" font="FdLcD;12" halign="left" noWrap="1">
+		<panel position="bottom" size="*,44" name="SummaryClockPanel">
+			<widget source="session.Event_Now" render="Label" position="215,0" size="110,40" font="FdLcD;44" halign="left" noWrap="1">
 				<convert type="EventTime">Remaining</convert>
 				<convert type="RemainingToText">NoSeconds</convert>
 			</widget>
@@ -52,43 +55,43 @@
 
 <!-- channelselection-->
 	<screen name="ChannelSelection_summary" position="fill">
-		<widget source="parent.ServiceEvent" render="Label" position="top" size="*,21" font="FdLcD;20" halign="left" noWrap="1" >
+		<widget source="parent.ServiceEvent" render="Label" position="top" size="*,81" font="FdLcD;40" halign="center" foregroundColor="#ffff7f" >
 			<convert type="ServiceName">Name</convert>
 		</widget>
-		<widget source="parent.ServiceEvent" render="Label" position="top" size="*,15" font="FdLcD;14" halign="left" noWrap="1">
+		<widget source="parent.ServiceEvent" render="Label" position="top" size="*,61" font="FdLcD;30" halign="center" >
 			<convert type="EventName">Name</convert>
 		</widget>
-		<widget source="parent.ServiceEvent" render="Progress" position="top" size="*,4" borderWidth="1">
+		<widget source="parent.ServiceEvent" render="Progress" position="top" size="*,14" borderWidth="3">
 			<convert type="EventTime">Progress</convert>
 		</widget>
-		<panel position="bottom" size="*,24" name="SummaryClockPanel" />
+		<panel position="bottom" size="*,44" name="SummaryClockPanel" />
 	</screen>
 
 <!-- menus-->
 	<screen name="MenuSummary" position="fill">
-		<widget source="parent.title" render="Label" position="top" size="*,16" font="FdLcD;14" halign="center" valign="top" noWrap="1" />
-		<widget source="parent.menu" render="Label" position="top" size="*,48" font="FdLcD;16" halign="left" valign="top">
+		<widget source="parent.title" render="Label" position="top" size="*,120" font="FdLcD;40" halign="center" valign="top" foregroundColor="#ffff7f" />
+		<widget source="parent.menu" render="Label" position="top" size="*,61" font="FdLcD;30" halign="center" valign="top">
 			<convert type="StringListSelection" />
 		</widget>
 	</screen>
 
 <!-- movieplayer-->
 	<screen name="InfoBarMoviePlayerSummary" position="fill">
-		<widget source="session.CurrentService" render="Label" position="top" size="*,36" font="FdLcD;16" halign="left" valign="top" >
+		<widget source="session.CurrentService" render="Label" position="top" size="*,140" font="FdLcD;40" halign="center" valign="center" foregroundColor="#ffff7f" >
 			<convert type="ServiceName">Name</convert>
 		</widget>
-		<widget source="session.CurrentService" render="Progress" position="top" size="*,4" borderWidth="1">
+		<widget source="session.CurrentService" render="Progress" position="top" size="*,14" borderWidth="3">
 			<convert type="ServicePosition">Position</convert>
 		</widget>
-		<panel position="bottom" size="*,24" name="SummaryClockPanel">
-			<widget source="session.CurrentService" render="Label" position="4,0" size="42,12" font="FdLcD;12" halign="left" noWrap="1">
+		<panel position="bottom" size="*,44" name="SummaryClockPanel">
+			<widget source="session.CurrentService" render="Label" position="240,0" size="110,40" font="FdLcD;44" halign="left" noWrap="1">
 				<convert type="ServicePosition">Position</convert>
 			</widget>
 		</panel>
 	</screen>
 
 	<screen name="MovieContextMenuSummary" position="fill">
-		<widget source="parent.Title" render="Label" position="top" size="*,14" font="FdLcD;12" halign="left" valign="top" noWrap="1" />
+		<widget source="parent.Title" render="Label" position="top" size="*,14" font="FdLcD;12" halign="left" valign="top" noWrap="1"/>
 		<widget source="selected" render="Label" position="top" size="*,32" font="FdLcD;16" />
 		<panel position="bottom" size="*,18">
 			<widget source="global.CurrentTime" render="Label" position="right" size="60,*" halign="right" font="FdLcD;16" >
@@ -98,10 +101,10 @@
 	</screen>
 
 	<screen name="MovieSelectionSummary" position="fill">
-		<widget source="parent.Title" render="Label" position="top" size="*,14" font="FdLcD;12" halign="left" valign="top" noWrap="1" />
-		<widget source="name" render="Label" position="top" size="*,32" font="FdLcD;16" halign="left" valign="top" />
-		<panel position="bottom" size="*,18">
-			<widget source="parent.Service" render="Label" position="right" size="46,*" font="FdLcD;14" halign="left" noWrap="1">
+		<widget source="parent.Title" render="Label" position="top" size="*,70" font="FdLcD;27" halign="center" valign="top"/>
+		<widget source="name" render="Label" position="top" size="*,106" font="FdLcD;35" halign="center" valign="top" foregroundColor="#ffff7f" />
+		<panel position="bottom" size="*,44">
+			<widget source="parent.Service" render="Label" position="right" size="180,*" font="FdLcD;30" halign="right" noWrap="1">
 				<convert type="MovieInfo">FileSize</convert>
 			</widget>
 			<widget source="parent.Service" render="Label" position="fill" font="FdLcD;14" halign="left" noWrap="1">
@@ -128,53 +131,53 @@
 
 <!-- setup-->
 	<screen name="SetupSummary" position="fill">
-		<widget source="SetupTitle" render="Label" position="top" size="*,12" font="FdLcD;12" halign="left" />
-		<widget source="SetupEntry" render="Label" position="top" size="*,40" font="FdLcD;12" halign="left" />
-		<widget source="SetupValue" render="Label" position="top" size="*,12" font="FdLcD;12" halign="left" />
+		<widget source="SetupTitle" render="Label" position="top" size="*,61" font="FdLcD;30" halign="left" />
+		<widget source="SetupEntry" render="Label" position="top" size="*,51" font="FdLcD;25" halign="left" />
+		<widget source="SetupValue" render="Label" position="top" size="*,51" font="FdLcD;25" halign="left" />
 	</screen>
 
 <!-- misc-->
 	<screen name="SimpleSummary" position="fill">
-		<widget source="parent.Title" render="Label" position="top" size="*,40" font="FdLcD;16" halign="center" valign="center" />
+		<widget source="parent.Title" render="Label" position="top" size="*,100" font="FdLcD;40" halign="center" valign="center" />
 		<panel position="bottom" size="*,24" name="SummaryClockPanel" />
 	</screen>
 
 	<screen name="WizardSummary" position="fill">
-		<widget source="text" render="Label" position="top" size="*,16" font="FdLcD;16"/>
-		<widget source="parent.list" render="Label" position="fill" font="FdLcD;12">
+		<widget source="text" render="Label" position="top" size="*,71" font="FdLcD;35" halign="center" />
+		<widget source="parent.list" render="Label" position="fill" font="FdLcD;25" halign="center" >
 			<convert type="StringListSelection" />
 		</widget>
 	</screen>
 
 	<screen name="VideoWizardSummary" position="fill">
 		<widget name="text" position="top" size="*,40" font="FdLcD;12" transparent="1" />
-		<widget source="parent.list" render="Label" position="fill" font="FdLcD;14">
+		<widget source="parent.list" render="Label" position="fill" font="FdLcD;45" halign="center" >
 			<convert type="StringListSelection" />
 		</widget>
 	</screen>
 
 <!-- standby -->
 	<screen name="StandbySummary" position="fill">
-		<widget source="global.CurrentTime" render="Label" position="center,0" size="120,64" font="FdLcD;48" halign="center" valign="center" noWrap="1">
+		<widget source="global.CurrentTime" render="Label" position="center,center" size="320,121" font="FdLcD;120" halign="center" valign="center" noWrap="1">
 			<convert type="ClockToText"></convert>
 		</widget>
-		<widget source="session.RecordState" render="FixedLabel" text="Recording" position="4,50" size="120,12" font="FdLcD;12" zPosition="2" valign="bottom" halign="left" noWrap="1">
-			<convert type="ConditionalShowHide"></convert>
+		<widget source="session.RecordState" render="FixedLabel" text="Recording" position="center,180" size="190,42" font="FdLcD;40" zPosition="2" valign="bottom" halign="center" noWrap="1" foregroundColor="#0000ff" >
+			<convert type="ConditionalShowHide">Blink</convert>
 		</widget>
 	</screen>
 <!-- Plugin browser -->
 	<screen name="PluginBrowserSummary" position="fill">
-		<widget source="parent.Title" render="Label" position="top" size="*,16" font="FdLcD;12"  noWrap="1" />
-		<widget source="entry" render="Label" position="top" size="*,20" font="FdLcD;18" noWrap="1" />
-		<widget source="desc" render="Label" position="fill" font="FdLcD;12" valign="top" />
+		<widget source="parent.Title" render="Label" position="top" size="*,60" font="FdLcD;40" halign="center" foregroundColor="#ffff7f" noWrap="1" />
+		<widget source="entry" render="Label" position="top" size="*,61" font="FdLcD;30" halign="left" />
+		<widget source="desc" render="Label" position="fill" font="FdLcD;22" valign="top" />
 	</screen>
 
 <!-- JobView Summary -->
 	<screen name="JobView_summary" position="fill">
-		<widget source="parent.summary_job_name" render="Label" position="6,4" size="120,42" font="FdLcD;16" />
-		<widget source="parent.summary_job_task" render="Label" position="6,22" size="120,26" font="FdLcD;12" />
-		<widget source="parent.summary_job_progress" render="Progress" position="6,50" size="60,12" borderWidth="1" zPosition="1" />
-		<widget source="parent.summary_job_progress" render="Label" position="66,50" size="50,12" font="FdLcD;12" zPosition="2" halign="center" transparent="1"  >
+		<widget source="parent.summary_job_name" render="Label" position="top" size="*,51" font="FdLcD;25" halign="center" />
+		<widget source="parent.summary_job_task" render="Label" position="top" size="*,41" font="FdLcD;20" halign="center" />
+		<widget source="parent.summary_job_progress" render="Progress" position="top" size="80,16" borderWidth="1" zPosition="1" halign="center" />
+		<widget source="parent.summary_job_progress" render="Label" position="top" size="100,24" font="FdLcD;24" zPosition="2" halign="center" transparent="1"  >
 			<convert type="ProgressToText" />
 		</widget>
 	</screen>
@@ -184,12 +187,12 @@
 	</screen>
 
 	<screen name="MessageBox_summary" position="fill">
-		<widget source="parent.Text" render="Label" position="top" size="*,52" font="FdLcD;11" halign="center" valign="center" />
-		<widget source="parent.selectedChoice" render="Label" position="bottom" size="*,14" font="FdLcD;14" halign="center" valign="center" />
+		<widget source="parent.Text" render="Label" position="top" size="*,95" font="FdLcD;31" halign="center" valign="center" />
+		<widget source="parent.selectedChoice" render="Label" position="bottom" size="*,44" font="FdLcD;44" halign="center" valign="center" />
 	</screen>
 
 	<screen name="MessageBoxSimple_summary" position="fill">
-		<widget source="parent.Text" render="Label" position="top" size="*,52" font="FdLcD;11" halign="center" valign="center" />
-		<widget source="parent.selectedChoice" render="Label" position="bottom" size="*,14" font="FdLcD;14" halign="center" valign="center" />
+		<widget source="parent.Text" render="Label" position="top" size="*,95" font="FdLcD;31" halign="center" valign="center" />
+		<widget source="parent.selectedChoice" render="Label" position="bottom" size="*,44" font="FdLcD;44" halign="center" valign="center" />
 	</screen>
 </skin>
diff --git a/lib/Makefile.am b/lib/Makefile.am
index 597bd99..b7a5ab0 100644
--- a/lib/Makefile.am
+++ b/lib/Makefile.am
@@ -7,6 +7,12 @@ AM_CPPFLAGS = \
 	-include Python.h \
 	-include $(top_builddir)/enigma2_config.h
 
+if ENABLE_LIBEPLAYER3
+AM_CPPFLAGS += \
+       -I$(top_srcdir)/../misc/tools/libeplayer3/include
+endif
+
+
 # initialize these, to be filled with targets in the included files
 noinst_LIBRARIES=
 BUILT_SOURCES=
@@ -19,6 +25,7 @@ installdir = $(pkglibdir)
 include actions/Makefile.inc
 include base/Makefile.inc
 include components/Makefile.inc
+include dvb/lowlevel/Makefile.inc
 include dvb/Makefile.inc
 include dvb_ci/Makefile.inc
 include gdi/Makefile.inc
diff --git a/lib/base/Makefile.inc b/lib/base/Makefile.inc
index 94f293e..d872d7f 100644
--- a/lib/base/Makefile.inc
+++ b/lib/base/Makefile.inc
@@ -43,7 +43,7 @@ baseinclude_HEADERS = \
 	base/estring.h \
 	base/etpm.h \
 	base/filepush.h \
-	base/freesatv2.cpp \
+	base/freesatv2.h \
 	base/i18n.h \
 	base/itssource.h \
 	base/init.h \
diff --git a/lib/base/etpm.cpp b/lib/base/etpm.cpp
index 5799347..ce23ccc 100644
--- a/lib/base/etpm.cpp
+++ b/lib/base/etpm.cpp
@@ -6,14 +6,17 @@
 #include <string.h>
 #include <sys/un.h>
 #include <unistd.h>
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 #include <openssl/bn.h>
 #include <openssl/sha.h>
+#endif
 #include <lib/base/eerror.h>
 
 #include "etpm.h"
 
 eTPM::eTPM()
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	struct sockaddr_un addr;
 	unsigned char buf[8];
 	unsigned int tag;
@@ -53,6 +56,7 @@ eTPM::eTPM()
 
 	parse_data(val, len);
 	free(val);
+#endif
 }
 
 eTPM::~eTPM()
@@ -63,6 +67,7 @@ eTPM::~eTPM()
 
 bool eTPM::send_cmd(enum tpmd_cmd cmd, const void *data, size_t len)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	unsigned char buf[len + 4];
 
 	buf[0] = (cmd >> 8) & 0xff;
@@ -77,11 +82,13 @@ bool eTPM::send_cmd(enum tpmd_cmd cmd, const void *data, size_t len)
 		return false;
 	}
 
+#endif
 	return true;
 }
 
 void* eTPM::recv_cmd(unsigned int *tag, size_t *len)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	unsigned char buf[4];
 	void *val;
 
@@ -116,10 +123,14 @@ void* eTPM::recv_cmd(unsigned int *tag, size_t *len)
 	}
 
 	return val;
+#else
+	return NULL;
+#endif
 }
 
 void eTPM::parse_data(const unsigned char *data, size_t datalen)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	unsigned int i;
 	unsigned int tag;
 	unsigned int len;
@@ -145,19 +156,23 @@ void eTPM::parse_data(const unsigned char *data, size_t datalen)
 			break;
 		}
 	}
+#endif
 }
 
 std::string eTPM::getCert(cert_type type)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	if (type == TPMD_DT_LEVEL2_CERT && level2_cert_read)
 		return std::string((char*)level2_cert, 210);
 	else if (type == TPMD_DT_LEVEL3_CERT && level3_cert_read)
 		return std::string((char*)level3_cert, 210);
+#endif
 	return "";
 }
 
 std::string eTPM::challenge(std::string rnd)
 {
+#if not defined(__sh__) // we dont have a tpm chip, and we dont want one
 	if (rnd.length() == 8)
 	{
 		if (!send_cmd(TPMD_CMD_COMPUTE_SIGNATURE, rnd.c_str(), 8))
@@ -174,5 +189,6 @@ std::string eTPM::challenge(std::string rnd)
 		free(val);
 		return ret;
 	}
+#endif
 	return "";
 }
diff --git a/lib/base/filepush.cpp b/lib/base/filepush.cpp
index 354cae4..5671677 100644
--- a/lib/base/filepush.cpp
+++ b/lib/base/filepush.cpp
@@ -4,6 +4,15 @@
 #include <fcntl.h>
 #include <sys/ioctl.h>
 
+#if defined(__sh__) // this allows filesystem tasks to be prioritised
+#include <sys/vfs.h>
+#define USBDEVICE_SUPER_MAGIC 0x9fa2
+#define EXT2_SUPER_MAGIC      0xEF53
+#define EXT3_SUPER_MAGIC      0xEF53
+#define SMB_SUPER_MAGIC       0x517B
+#define NFS_SUPER_MAGIC       0x6969
+#define MSDOS_SUPER_MAGIC     0x4d44 /* MD */
+#endif
 //#define SHOW_WRITE_TIME
 
 eFilePushThread::eFilePushThread(int io_prio_class, int io_prio_level, int blocksize, size_t buffersize)
@@ -57,10 +66,30 @@ void eFilePushThread::thread()
 	off_t current_span_offset = 0;
 	size_t current_span_remaining = 0;
 
+#if defined(__sh__)
+// opens video device for the reverse playback workaround
+// Changes in this file are cause e2 doesnt tell the player to play reverse
+	int fd_video = open("/dev/dvb/adapter0/video0", O_RDONLY);
+// Fix to ensure that event evtEOF is called at end of playbackl part 1/3
+	bool already_empty = false;
+#endif
+
 	while (!m_stop)
 	{
 		if (m_sg && !current_span_remaining)
 		{
+#if defined(__sh__) // tells the player to play in reverse
+#define VIDEO_DISCONTINUITY                   _IO('o', 84)
+#define DVB_DISCONTINUITY_SKIP                0x01
+#define DVB_DISCONTINUITY_CONTINUOUS_REVERSE  0x02
+			if ((m_sg->getSkipMode() != 0))
+			{
+				// inform the player about the jump in the stream data
+				// this only works if the video device allows the discontinuity ioctl in read-only mode (patched)
+				int param = DVB_DISCONTINUITY_SKIP; // | DVB_DISCONTINUITY_CONTINUOUS_REVERSE;
+				int rc = ioctl(fd_video, VIDEO_DISCONTINUITY, (void*)param);
+			}
+#endif
 			m_sg->getNextSourceSpan(m_current_position, bytes_read, current_span_offset, current_span_remaining);
 			ASSERT(!(current_span_remaining % m_blocksize));
 			m_current_position = current_span_offset;
@@ -127,7 +156,19 @@ void eFilePushThread::thread()
 				{
 					case 0:
 						eDebug("wait for driver eof timeout");
+#if defined(__sh__) // Fix to ensure that event evtEOF is called at end of playbackl part 2/3
+						if (already_empty)
+						{
+							break;
+						}
+						else
+						{
+							already_empty = true;
+							continue;
+						}
+#else
 						continue;
+#endif
 					case 1:
 						eDebug("wait for driver eof ok");
 						break;
@@ -190,12 +231,18 @@ void eFilePushThread::thread()
 			}
 
 			eofcount = 0;
+#if defined(__sh__) // Fix to ensure that event evtEOF is called at end of playbackl part 3/3
+			already_empty = false;
+#endif
 			m_current_position += buf_end;
 			bytes_read += buf_end;
 			if (m_sg)
 				current_span_remaining -= buf_end;
 		}
 	}
+#if defined(__sh__) // closes video device for the reverse playback workaround
+	close(fd_video);
+#endif
 	sendEvent(evtStopped);
 
 	{ /* mutex lock scope */
diff --git a/lib/base/filepush.h b/lib/base/filepush.h
index 47ec4ed..fc65435 100644
--- a/lib/base/filepush.h
+++ b/lib/base/filepush.h
@@ -13,6 +13,10 @@ class iFilePushScatterGather
 public:
 	virtual void getNextSourceSpan(off_t current_offset, size_t bytes_read, off_t &start, size_t &size)=0;
 	virtual ~iFilePushScatterGather() {}
+#if defined(__sh__)
+	//Changes in this file are cause e2 doesnt tell the player to play reverse
+	virtual int getSkipMode() = 0;
+#endif
 };
 
 class eFilePushThread: public eThread, public Object
diff --git a/lib/base/ioprio.cpp b/lib/base/ioprio.cpp
index 5c8622f..fbfcc8d 100644
--- a/lib/base/ioprio.cpp
+++ b/lib/base/ioprio.cpp
@@ -28,6 +28,9 @@ extern "C" int sys_ioprio_get(int, int);
 #elif defined(__mips__)
 #define __NR_ioprio_set		4284
 #define __NR_ioprio_get		4285
+#elif defined(__sh__) // the correct values for our kernel
+#define __NR_ioprio_set		288
+#define __NR_ioprio_get		289
 #else
 #error "Unsupported arch"
 #endif
diff --git a/lib/base/smartptr.h b/lib/base/smartptr.h
index 4b7401c..7d25250 100644
--- a/lib/base/smartptr.h
+++ b/lib/base/smartptr.h
@@ -6,6 +6,8 @@
 #include <string.h>
 #include <lib/python/swig.h>
 
+inline void ptrAssert(void *p) { if (!p) *(unsigned long*)0=0; }
+
 template<class T>
 class ePtr
 {
@@ -58,10 +60,10 @@ public:
 	}
 #ifndef SWIG
 	T* grabRef() { if (!ptr) return 0; ptr->AddRef(); return ptr; }
-	T* &ptrref() { return ptr; }
+	T* &ptrref() { ASSERT(!ptr); return ptr; }
 	operator bool() const { return !!this->ptr; }
 #endif
-	T* operator->() const { return ptr; }
+	T* operator->() const { ptrAssert(ptr); return ptr; }
 	operator T*() const { return this->ptr; }
 };
 
@@ -133,9 +135,9 @@ public:
 	}
 #ifndef SWIG
 	T* grabRef() { if (!ptr) return 0; ptr->AddRef(); ptr->AddUse(); return ptr; }
-	T* &ptrref() { return ptr; }
+	T* &ptrref() { ASSERT(!ptr); return ptr; }
 #endif
-	T* operator->() const { return ptr; }
+	T* operator->() const { ptrAssert(ptr); return ptr; }
 	operator T*() const { return this->ptr; }
 };
 
@@ -178,12 +180,12 @@ public:
 		ePtr<T>::operator=(c);
 		return *this;
 	}
-	ePtrHelper<T> operator->() { return ePtrHelper<T>(ptr); }
+	ePtrHelper<T> operator->() { ptrAssert(ptr); return ePtrHelper<T>(ptr); }
 			/* for const objects, we don't need the helper, as they can't */
 			/* be changed outside the program flow. at least this is */
 			/* what the compiler assumes, so in case you're using const */
 			/* eMutablePtrs note that they have to be const. */
-	const T* operator->() const { return ptr; }
+	const T* operator->() const { ptrAssert(ptr); return ptr; }
 };
 #endif
 
diff --git a/lib/driver/Makefile.inc b/lib/driver/Makefile.inc
index 1933963..1383487 100644
--- a/lib/driver/Makefile.inc
+++ b/lib/driver/Makefile.inc
@@ -9,7 +9,8 @@ driver_libenigma_driver_a_SOURCES = \
 	driver/rc.cpp \
 	driver/rcinput.cpp \
 	driver/rfmod.cpp \
-	driver/hdmi_cec.cpp
+	driver/hdmi_cec.cpp \
+	driver/vfd.cpp
 
 driverincludedir = $(pkgincludedir)/lib/driver
 driverinclude_HEADERS = \
@@ -24,7 +25,8 @@ driverinclude_HEADERS = \
 	driver/rcinput.h \
 	driver/rcinput_swig.h \
 	driver/rfmod.h \
-	driver/hdmi_cec.h
+	driver/hdmi_cec.h \
+	driver/vfd.h
 
 if HAVE_LIBSDL
 driver_libenigma_driver_a_SOURCES += \
diff --git a/lib/driver/hdmi_cec.cpp b/lib/driver/hdmi_cec.cpp
index 705270d..876fdeb 100644
--- a/lib/driver/hdmi_cec.cpp
+++ b/lib/driver/hdmi_cec.cpp
@@ -85,7 +85,7 @@ eHdmiCEC *eHdmiCEC::getInstance()
 void eHdmiCEC::reportPhysicalAddress()
 {
 	struct cec_message txmessage;
-	txmessage.address = 0x0f; /* broadcast */
+	txmessage.address = (logicalAddress << 4) + (0xf); /* broadcast */
 	txmessage.data[0] = 0x84; /* report address */
 	txmessage.data[1] = physicalAddress[0];
 	txmessage.data[2] = physicalAddress[1];
@@ -106,7 +106,14 @@ void eHdmiCEC::getAddressInfo()
 			unsigned char logical;
 			unsigned char type;
 		} addressinfo;
-
+#else
+		struct
+		{
+			unsigned char logical;
+			unsigned char physical[2];
+			unsigned char type;
+		} addressinfo;
+#endif 
 		if (::ioctl(hdmiFd, 1, &addressinfo) >= 0)
 		{
 			hasdata = true;
@@ -131,18 +138,7 @@ void eHdmiCEC::getAddressInfo()
 				break;
 			}
 		}
-#else
-		struct
-		{
-			unsigned char logical;
-			unsigned char physical[2];
-			unsigned char type;
-		} addressinfo;
-		if (::ioctl(hdmiFd, 1, &addressinfo) >= 0)
-		{
-			hasdata = true;
-		}
-#endif
+
 		if (hasdata)
 		{
 			deviceType = addressinfo.type;
@@ -312,6 +308,9 @@ long eHdmiCEC::translateKey(unsigned char code)
 		case 0x31:
 			key = 0x193;
 			break;
+		case 0x40:
+			key = 0x74;
+			break;
 		case 0x44:
 			key = 0xcf;
 			break;
@@ -330,6 +329,12 @@ long eHdmiCEC::translateKey(unsigned char code)
 		case 0x49:
 			key = 0xd0;
 			break;
+		case 0x4B:
+			key = 0xd0;
+			break;
+		case 0x4C:
+			key = 0xa8;
+			break;
 		case 0x53:
 			key = 0x166;
 			break;
diff --git a/lib/driver/rc.cpp b/lib/driver/rc.cpp
index 5b742c3..c07e576 100644
--- a/lib/driver/rc.cpp
+++ b/lib/driver/rc.cpp
@@ -151,6 +151,9 @@ bool eRCInputEventDriver::isKeyboard()
 #ifdef VUPLUS_RC_WORKAROUND
 	return(false);
 #else
+	if (getDeviceName().find("RC") != std::string::npos)
+		return false;
+
 	/* check whether the input device has KEY_A, in which case we assume it is a keyboard */
 	return hasCap(keyCaps, KEY_A);
 #endif
diff --git a/lib/driver/vfd.cpp b/lib/driver/vfd.cpp
new file mode 100644
index 0000000..fe2e4a4
--- /dev/null
+++ b/lib/driver/vfd.cpp
@@ -0,0 +1,256 @@
+#include <stdarg.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <ctype.h>
+#include <sys/stat.h>
+#include  <pthread.h>
+
+#include <lib/base/eerror.h>
+#include <lib/driver/vfd.h>
+
+#define VFD_DEVICE "/dev/vfd"
+#define VFDICONDISPLAYONOFF   0xc0425a0a
+#define VFDDISPLAYCHARS       0xc0425a00
+#define VFDBRIGHTNESS         0xc0425a03
+//light on off
+#define VFDDISPLAYWRITEONOFF  0xc0425a05
+#define VFDDISPLAYCLR		0xc0425b00
+#define VFDLENGTH 16
+
+bool startloop_running = false;
+static bool icon_onoff[45];
+static pthread_t thread_start_loop = 0;
+void * start_loop (void *arg);
+bool blocked = false;
+bool requested = false;
+bool VFD_CENTER = false;
+bool scoll_loop = false;
+int VFD_SCROLL = 1;
+
+char g_str[64];
+
+struct vfd_ioctl_data
+{
+	unsigned char start;
+	unsigned char data[64];
+	unsigned char length;
+};
+
+#if defined(PLATFORM_SPARK) || defined(PLATFORM_SPARK7162)
+struct set_icon_s {
+	int icon_nr;
+	int on;
+};
+#endif
+
+evfd* evfd::instance = NULL;
+
+evfd* evfd::getInstance()
+{
+	if (instance == NULL)
+		instance = new evfd;
+	return instance;
+}
+
+evfd::evfd()
+{
+	file_vfd = 0;
+	vfd_type=8;
+	FILE *vfd_proc = fopen ("/proc/aotom/display_type", "r");
+	if (vfd_proc)
+	{	char buf[2];
+		fread(&buf,sizeof(buf),1,vfd_proc);
+		vfd_type=atoi(&buf[0]);
+		fclose (vfd_proc);	    
+	}
+}
+
+void evfd::init()
+{
+	pthread_create (&thread_start_loop, NULL, &start_loop, NULL);
+	return;
+}
+
+evfd::~evfd()
+{
+	//close (file_vfd);
+}
+
+void * start_loop (void *arg)
+{
+	evfd vfd;
+	blocked = true;
+	//vfd.vfd_clear_icons();
+	vfd.vfd_write_string("Open AR-P ENIGMA2", true);
+	//run 2 times through all icons 
+	if (vfd.getVfdType() != 4)
+	{
+	    memset(&icon_onoff,0, sizeof(icon_onoff));
+            static const unsigned char brightness[14]={1,2,3,4,5,6,7,6,5,4,3,2,1,0};
+	    for (int vloop = 0; vloop < 128; vloop++)
+	    {
+                    
+		    vfd.vfd_set_brightness(brightness[vloop%14]);
+		    usleep(75000);
+	    }
+	    vfd.vfd_set_brightness(7);
+	}
+	blocked = false;
+	return NULL;
+}
+
+void evfd::vfd_write_string(const char * str)
+{
+	vfd_write_string(str, false);
+}
+
+void evfd::vfd_write_string(const char * str, bool force)
+{
+	if (!blocked || force)
+	{
+		struct vfd_ioctl_data data;
+		data.length = (unsigned char)snprintf((char*)data.data, sizeof(data.data), "%s", str);
+		data.start = 0;
+
+		file_vfd = open (VFD_DEVICE, O_WRONLY);
+		ioctl ( file_vfd, VFDDISPLAYCHARS, &data );
+		close (file_vfd);
+	}
+}
+
+void evfd::vfd_write_string_scrollText(const char* text)
+{
+	if (!blocked)
+	{
+		int i, len = strlen(text);
+		char out[17]={'\0'};
+		for (i=0; i<=(len-16); i++)
+		{ // scroll text till end
+			memcpy(out, text+i, 16);
+			vfd_write_string(out);
+			usleep(200000);
+		}
+		for (i=1; i<16; i++)
+		{ // scroll text with whitespaces from right
+			memcpy(out, text+len+i-16, 16-i);
+			memset(out+(16-i-1), ' ', i);
+			vfd_write_string(out);
+			usleep(200000);
+		}
+		memcpy(out, text, 16); // display first 16 chars after scrolling
+		vfd_write_string(out);
+	}
+	return;
+}
+
+void evfd::vfd_clear_string()
+{
+	vfd_write_string("                ");
+}
+
+void evfd::vfd_set_icon(tvfd_icon id, bool onoff)
+{
+	if (getVfdType() != 4) vfd_set_icon(id, onoff, false);
+}
+
+void evfd::vfd_set_icon(tvfd_icon id, bool onoff, bool force)
+{
+    if (getVfdType() != 4)
+    {
+	icon_onoff[id] = onoff;
+	if (!blocked || force)
+	{
+#if defined(PLATFORM_SPARK) || defined(PLATFORM_SPARK7162)
+	    	struct set_icon_s data;
+#else
+		struct vfd_ioctl_data data;
+#endif
+		if (!startloop_running)
+		{
+#if defined(PLATFORM_SPARK) || defined(PLATFORM_SPARK7162)
+		    	memset(&data, 0, sizeof(struct set_icon_s));			
+			data.icon_nr=id;
+			data.on = onoff;
+#else
+			memset(&data, 0, sizeof(struct vfd_ioctl_data));
+			data.start = 0x00;
+			data.data[0] = id;
+			data.data[4] = onoff;
+			data.length = 5;
+#endif
+			file_vfd = open (VFD_DEVICE, O_WRONLY);
+			ioctl(file_vfd, VFDICONDISPLAYONOFF, &data);
+			close (file_vfd);
+		}
+	}
+    }
+    return;
+}
+
+void evfd::vfd_clear_icons()
+{
+    if (getVfdType() != 4)
+    {
+	for (int id = 1; id <= 45; id++)
+	{
+		vfd_set_icon((tvfd_icon)id, false);
+	}
+    }
+    return;
+}
+
+void evfd::vfd_set_brightness(unsigned char setting)
+{
+    if (getVfdType() != 4)
+    {
+	struct vfd_ioctl_data data;
+
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+	data.start = setting & 0x07;
+	data.length = 0;
+
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+	ioctl ( file_vfd, VFDBRIGHTNESS, &data );
+	close (file_vfd);
+    }
+    return;
+}
+
+void evfd::vfd_set_light(bool onoff)
+{
+	struct vfd_ioctl_data data;
+
+	memset(&data, 0, sizeof(struct vfd_ioctl_data));
+
+	if (onoff)
+		data.start = 0x01;
+	else
+		data.start = 0x00;
+		data.length = 0;
+
+	file_vfd = open (VFD_DEVICE, O_WRONLY);
+	ioctl(file_vfd, VFDDISPLAYWRITEONOFF, &data);
+
+	close (file_vfd);
+	return;
+}
+
+void evfd::vfd_set_fan(bool onoff)
+{
+	return;
+}
+
+void evfd::vfd_set_SCROLL(int id)
+{
+	VFD_SCROLL=id;
+}
+
+void evfd::vfd_set_CENTER(bool id)
+{
+	VFD_CENTER=id;
+}
diff --git a/lib/driver/vfd.h b/lib/driver/vfd.h
new file mode 100644
index 0000000..15f6c17
--- /dev/null
+++ b/lib/driver/vfd.h
@@ -0,0 +1,47 @@
+#ifndef VFD_H_
+#define VFD_H_
+
+#define ICON_ON  1
+#define ICON_OFF 0
+
+typedef enum { PLAYFASTBACKWARD=1, PLAYHEAD, PLAYLOG,  PLAYTAIL, PLAYFASTFORWARD, PLAYPAUSE, REC1, MUTE,
+	CYCLE, DUBI, CA, CI, USB, DOUBLESCREEN, REC2, HDD_A8, HDD_A7, HDD_A6, HDD_A5,HDD_A4, HDD_A3,
+	HDD_FULL, HDD_A2, HDD_A1, MP3, AC3, TVMODE_LOG, AUDIO, ALERT, HDD_A9, CLOCK_PM, CLOCK_AM, CLOCK,
+	TIME_SECOND, DOT2, STANDBY, TER, DISK_S3, DISK_S2, DISK_S1, DISK_S0, SAT, TIMESHIFT, DOT1, CAB } tvfd_icon;
+
+class evfd
+{
+protected:
+	static evfd *instance;
+	int file_vfd;
+	int vfd_type;
+#ifdef SWIG
+	evfd();
+	~evfd();
+#endif
+public:
+#ifndef SWIG
+	evfd();
+	~evfd();
+#endif
+	void init();
+	static evfd* getInstance();
+
+	int getVfdType() { return vfd_type; }
+	void vfd_set_SCROLL(int id);
+	void vfd_set_CENTER(bool id);
+	void vfd_set_icon(tvfd_icon id, bool onoff);
+	void vfd_set_icon(tvfd_icon id, bool onoff, bool force);
+	void vfd_clear_icons();
+
+	void vfd_write_string(const char * string);
+	void vfd_write_string(const char * str, bool force);
+	void vfd_write_string_scrollText(const char* text);
+	void vfd_clear_string();
+	
+	void vfd_set_brightness(unsigned char setting);
+	void vfd_set_light(bool onoff);
+	void vfd_set_fan(bool onoff);
+};
+
+#endif
diff --git a/lib/dvb/db.cpp b/lib/dvb/db.cpp
index 87764b2..3d2a4d6 100644
--- a/lib/dvb/db.cpp
+++ b/lib/dvb/db.cpp
@@ -401,15 +401,17 @@ static ePtr<eDVBFrontendParameters> parseFrontendData(const char* line, int vers
 				system=eDVBFrontendParametersSatellite::System_DVB_S,
 				modulation=eDVBFrontendParametersSatellite::Modulation_QPSK,
 				rolloff=eDVBFrontendParametersSatellite::RollOff_alpha_0_35,
-				pilot=eDVBFrontendParametersSatellite::Pilot_Unknown;
+				pilot=eDVBFrontendParametersSatellite::Pilot_Unknown,
+				is_id = -1, pls_code = 1, pls_mode = 0;
 			if (version == 3)
 				sscanf(line+2, "%d:%d:%d:%d:%d:%d:%d:%d:%d:%d",
 					&frequency, &symbol_rate, &polarisation, &fec, &orbital_position,
 					&inversion, &system, &modulation, &rolloff, &pilot);
 			else
-				sscanf(line+2, "%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d",
+				sscanf(line+2, "%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d",
 					&frequency, &symbol_rate, &polarisation, &fec, &orbital_position,
-					&inversion, &flags, &system, &modulation, &rolloff, &pilot);
+					&inversion, &flags, &system, &modulation, &rolloff, &pilot,
+					&is_id, &pls_code, &pls_mode);
 			sat.frequency = frequency;
 			sat.symbol_rate = symbol_rate;
 			sat.polarisation = polarisation;
@@ -420,6 +422,9 @@ static ePtr<eDVBFrontendParameters> parseFrontendData(const char* line, int vers
 			sat.modulation = modulation;
 			sat.rolloff = rolloff;
 			sat.pilot = pilot;
+			sat.is_id = is_id;
+			sat.pls_mode = pls_mode & 3;
+			sat.pls_code = pls_code & 0x3FFFF;
 			ePtr<eDVBFrontendParameters> feparm = new eDVBFrontendParameters;
 			feparm->setDVBS(sat);
 			feparm->setFlags(flags);
@@ -429,11 +434,11 @@ static ePtr<eDVBFrontendParameters> parseFrontendData(const char* line, int vers
 		{
 			eDVBFrontendParametersTerrestrial ter;
 			int frequency, bandwidth, code_rate_HP, code_rate_LP, modulation, transmission_mode,
-				guard_interval, hierarchy, inversion, flags = 0, plpid = 0;
+				guard_interval, hierarchy, inversion, flags = 0, plp_id = 0;
 			int system = eDVBFrontendParametersTerrestrial::System_DVB_T;
 			sscanf(line+2, "%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d",
 				&frequency, &bandwidth, &code_rate_HP, &code_rate_LP, &modulation,
-				&transmission_mode, &guard_interval, &hierarchy, &inversion, &flags, &system, &plpid);
+				&transmission_mode, &guard_interval, &hierarchy, &inversion, &flags, &system, &plp_id);
 			ter.frequency = frequency;
 			switch (bandwidth)
 			{
@@ -454,7 +459,7 @@ static ePtr<eDVBFrontendParameters> parseFrontendData(const char* line, int vers
 			ter.hierarchy = hierarchy;
 			ter.inversion = inversion;
 			ter.system = system;
-			ter.plpid = plpid;
+			ter.plp_id = plp_id;
 			ePtr<eDVBFrontendParameters> feparm = new eDVBFrontendParameters;
 			feparm->setDVBT(ter);
 			feparm->setFlags(flags);
@@ -629,7 +634,7 @@ void eDVBDB::saveServicelist(const char *file)
 		{
 			if (sat.system == eDVBFrontendParametersSatellite::System_DVB_S2)
 			{
-				fprintf(f, "\ts %d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d\n",
+				fprintf(f, "\ts %d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d\n",
 					sat.frequency, sat.symbol_rate,
 					sat.polarisation, sat.fec,
 					sat.orbital_position > 1800 ? sat.orbital_position - 3600 : sat.orbital_position,
@@ -638,7 +643,8 @@ void eDVBDB::saveServicelist(const char *file)
 					sat.system,
 					sat.modulation,
 					sat.rolloff,
-					sat.pilot);
+					sat.pilot,
+					sat.is_id, sat.pls_code & 0x3FFFF, sat.pls_mode & 3);
 			}
 			else
 			{
@@ -679,7 +685,7 @@ void eDVBDB::saveServicelist(const char *file)
 			fprintf(f, "\tt %d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d:%d\n",
 				ter.frequency, bandwidth, ter.code_rate_HP,
 				ter.code_rate_LP, ter.modulation, ter.transmission_mode,
-				ter.guard_interval, ter.hierarchy, ter.inversion, flags, ter.system, ter.plpid);
+				ter.guard_interval, ter.hierarchy, ter.inversion, flags, ter.system, ter.plp_id);
 		}
 		else if (!ch.m_frontendParameters->getDVBC(cab))
 		{
@@ -1066,7 +1072,7 @@ PyObject *eDVBDB::readSatellites(ePyObject sat_list, ePyObject sat_dict, ePyObje
 		return Py_False;
 	}
 	int tmp, *dest = NULL,
-		modulation, system, freq, sr, pol, fec, inv, pilot, rolloff, tsid, onid;
+		modulation, system, freq, sr, pol, fec, inv, pilot, rolloff, is_id, pls_code, pls_mode, tsid, onid;
 	char *end_ptr;
 	const Attribute *at;
 	std::string name;
@@ -1131,6 +1137,9 @@ PyObject *eDVBDB::readSatellites(ePyObject sat_list, ePyObject sat_dict, ePyObje
 				inv = eDVBFrontendParametersSatellite::Inversion_Unknown;
 				pilot = eDVBFrontendParametersSatellite::Pilot_Unknown;
 				rolloff = eDVBFrontendParametersSatellite::RollOff_alpha_0_35;
+				is_id = -1;
+				pls_code = 1;
+				pls_mode = 0;
 				tsid = -1;
 				onid = -1;
 
@@ -1148,6 +1157,9 @@ PyObject *eDVBDB::readSatellites(ePyObject sat_list, ePyObject sat_dict, ePyObje
 					else if (name == "inversion") dest = &inv;
 					else if (name == "rolloff") dest = &rolloff;
 					else if (name == "pilot") dest = &pilot;
+					else if (name == "is_id") dest = &is_id;
+					else if (name == "pls_code") dest = &pls_code;
+					else if (name == "pls_mode") dest = &pls_mode;
 					else if (name == "tsid") dest = &tsid;
 					else if (name == "onid") dest = &onid;
 					else continue;
@@ -1161,7 +1173,7 @@ PyObject *eDVBDB::readSatellites(ePyObject sat_list, ePyObject sat_dict, ePyObje
 				}
 				if (freq && sr && pol != -1)
 				{
-					tuple = PyTuple_New(12);
+					tuple = PyTuple_New(13);
 					PyTuple_SET_ITEM(tuple, 0, PyInt_FromLong(0));
 					PyTuple_SET_ITEM(tuple, 1, PyInt_FromLong(freq));
 					PyTuple_SET_ITEM(tuple, 2, PyInt_FromLong(sr));
@@ -1172,8 +1184,11 @@ PyObject *eDVBDB::readSatellites(ePyObject sat_list, ePyObject sat_dict, ePyObje
 					PyTuple_SET_ITEM(tuple, 7, PyInt_FromLong(inv));
 					PyTuple_SET_ITEM(tuple, 8, PyInt_FromLong(rolloff));
 					PyTuple_SET_ITEM(tuple, 9, PyInt_FromLong(pilot));
-					PyTuple_SET_ITEM(tuple, 10, PyInt_FromLong(tsid));
-					PyTuple_SET_ITEM(tuple, 11, PyInt_FromLong(onid));
+					PyTuple_SET_ITEM(tuple, 10, PyInt_FromLong(is_id));
+					PyTuple_SET_ITEM(tuple, 11, PyInt_FromLong(pls_mode & 3));
+					PyTuple_SET_ITEM(tuple, 12, PyInt_FromLong(pls_code & 0x3FFFF));
+					PyTuple_SET_ITEM(tuple, 11, PyInt_FromLong(tsid));
+					PyTuple_SET_ITEM(tuple, 12, PyInt_FromLong(onid));
 					PyList_Append(tplist, tuple);
 					Py_DECREF(tuple);
 				}
@@ -1342,7 +1357,7 @@ PyObject *eDVBDB::readTerrestrials(ePyObject ter_list, ePyObject tp_dict)
 	const Attribute *at;
 	std::string name;
 	int tmp, *dest,
-		freq, bw, constellation, crh, crl, guard, transm, hierarchy, inv, system, plpid;
+		freq, bw, constellation, crh, crl, guard, transm, hierarchy, inv, system, plp_id;
 	char *end_ptr;
 	const ElementList &root_elements = root->getElementList();
 	for (ElementConstIterator it(root_elements.begin()); it != root_elements.end(); ++it)
@@ -1393,7 +1408,7 @@ PyObject *eDVBDB::readTerrestrials(ePyObject ter_list, ePyObject tp_dict)
 				hierarchy = eDVBFrontendParametersTerrestrial::Hierarchy_Auto;
 				inv = eDVBFrontendParametersTerrestrial::Inversion_Unknown;
 				system = eDVBFrontendParametersTerrestrial::System_DVB_T_T2;
-				plpid = 0;
+				plp_id = 0;
 				for (AttributeConstIterator it(tp_attributes.begin()); it != end; ++it)
 				{
 //					eDebug("\t\tattr: %s", at->name().c_str());
@@ -1410,7 +1425,7 @@ PyObject *eDVBDB::readTerrestrials(ePyObject ter_list, ePyObject tp_dict)
 					else if (name == "hierarchy_information") dest = &hierarchy;
 					else if (name == "inversion") dest = &inv;
 					else if (name == "system") dest = &system;
-					else if (name == "plp_id") dest = &plpid;
+					else if (name == "plp_id") dest = &plp_id;
 					else continue;
 					if (dest)
 					{
@@ -1432,9 +1447,9 @@ PyObject *eDVBDB::readTerrestrials(ePyObject ter_list, ePyObject tp_dict)
 					case eDVBFrontendParametersTerrestrial::Bandwidth_1_712MHz: bw = 1712000; break;
 					case eDVBFrontendParametersTerrestrial::Bandwidth_10MHz: bw = 10000000; break;
 					}
-					if (crh > eDVBFrontendParametersTerrestrial::FEC_8_9)
+					if (crh > eDVBFrontendParametersTerrestrial::FEC_4_5)
 						crh = eDVBFrontendParametersTerrestrial::FEC_Auto;
-					if (crl > eDVBFrontendParametersTerrestrial::FEC_8_9)
+					if (crl > eDVBFrontendParametersTerrestrial::FEC_4_5)
 						crl = eDVBFrontendParametersTerrestrial::FEC_Auto;
 					tuple = PyTuple_New(12);
 					PyTuple_SET_ITEM(tuple, 0, PyInt_FromLong(2));
@@ -1448,7 +1463,7 @@ PyObject *eDVBDB::readTerrestrials(ePyObject ter_list, ePyObject tp_dict)
 					PyTuple_SET_ITEM(tuple, 8, PyInt_FromLong(hierarchy));
 					PyTuple_SET_ITEM(tuple, 9, PyInt_FromLong(inv));
 					PyTuple_SET_ITEM(tuple, 10, PyInt_FromLong(system));
-					PyTuple_SET_ITEM(tuple, 11, PyInt_FromLong(plpid));
+					PyTuple_SET_ITEM(tuple, 11, PyInt_FromLong(plp_id));
 					PyList_Append(tplist, tuple);
 					Py_DECREF(tuple);
 				}
diff --git a/lib/dvb/decoder.cpp b/lib/dvb/decoder.cpp
index 9176ba1..638331d 100644
--- a/lib/dvb/decoder.cpp
+++ b/lib/dvb/decoder.cpp
@@ -74,7 +74,11 @@ int eDVBAudio::startPid(int pid, int type)
 			pes.pes_type = DMX_PES_AUDIO3;
 			break;
 		}
+#if defined(__sh__) // increases zapping speed
+		pes.flags    = DMX_IMMEDIATE_START;
+#else
 		pes.flags    = 0;
+#endif
 		eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - audio - ", pid);
 		if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 		{
@@ -82,6 +86,7 @@ int eDVBAudio::startPid(int pid, int type)
 			return -errno;
 		}
 		eDebug("ok");
+#if not defined(__sh__) // already startet cause of DMX_IMMEDIATE_START
 		eDebugNoNewLine("DEMUX_START - audio - ");
 		if (::ioctl(m_fd_demux, DMX_START) < 0)
 		{
@@ -89,6 +94,7 @@ int eDVBAudio::startPid(int pid, int type)
 			return -errno;
 		}
 		eDebug("ok");
+#endif
 	}
 
 	if (m_fd >= 0)
@@ -128,7 +134,9 @@ int eDVBAudio::startPid(int pid, int type)
 			eDebug("failed (%m)");
 		else
 			eDebug("ok");
+#if not defined(__sh__) // this is a hack which only matters for dm drivers
 		freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in Decoder::setState
+#endif
 		eDebugNoNewLine("AUDIO_PLAY - ");
 		if (::ioctl(m_fd, AUDIO_PLAY) < 0)
 			eDebug("failed (%m)");
@@ -353,7 +361,11 @@ int eDVBVideo::startPid(int pid, int type)
 			pes.pes_type = DMX_PES_VIDEO3;
 			break;
 		}
+#if defined(__sh__) // increases zapping speed
+		pes.flags    = DMX_IMMEDIATE_START;
+#else
 		pes.flags    = 0;
+#endif
 		eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - video - ", pid);
 		if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 		{
@@ -361,6 +373,7 @@ int eDVBVideo::startPid(int pid, int type)
 			return -errno;
 		}
 		eDebug("ok");
+#if not defined(__sh__) // already startet cause of DMX_IMMEDIATE_START
 		eDebugNoNewLine("DEMUX_START - video - ");
 		if (::ioctl(m_fd_demux, DMX_START) < 0)
 		{
@@ -368,11 +381,14 @@ int eDVBVideo::startPid(int pid, int type)
 			return -errno;
 		}
 		eDebug("ok");
+#endif
 	}
 
 	if (m_fd >= 0)
 	{
+#if not defined(__sh__) // this is a hack which only matters for dm drivers
 		freeze();  // why freeze here?!? this is a problem when only a pid change is requested... because of the unfreeze logic in Decoder::setState
+#endif
 		eDebugNoNewLine("VIDEO_PLAY - ");
 		if (::ioctl(m_fd, VIDEO_PLAY) < 0)
 			eDebug("failed (%m)");
@@ -657,7 +673,11 @@ int eDVBPCR::startPid(int pid)
 		pes.pes_type = DMX_PES_PCR3;
 		break;
 	}
+#if defined(__sh__) // increases zapping speed
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - pcr - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
 	{
@@ -665,6 +685,7 @@ int eDVBPCR::startPid(int pid)
 		return -errno;
 	}
 	eDebug("ok");
+#if not defined(__sh__) // already startet cause of DMX_IMMEDIATE_START
 	eDebugNoNewLine("DEMUX_START - pcr - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -672,6 +693,7 @@ int eDVBPCR::startPid(int pid)
 		return -errno;
 	}
 	eDebug("ok");
+#endif
 	return 0;
 }
 
@@ -726,7 +748,11 @@ int eDVBTText::startPid(int pid)
 		pes.pes_type = DMX_PES_TELETEXT3;
 		break;
 	}
+#if defined(__sh__) // increases zapping speed
+	pes.flags    = DMX_IMMEDIATE_START;
+#else
 	pes.flags    = 0;
+#endif
 
 	eDebugNoNewLine("DMX_SET_PES_FILTER(0x%02x) - ttx - ", pid);
 	if (::ioctl(m_fd_demux, DMX_SET_PES_FILTER, &pes) < 0)
@@ -735,6 +761,7 @@ int eDVBTText::startPid(int pid)
 		return -errno;
 	}
 	eDebug("ok");
+#if not defined(__sh__) // already startet cause of DMX_IMMEDIATE_START
 	eDebugNoNewLine("DEMUX_START - ttx - ");
 	if (::ioctl(m_fd_demux, DMX_START) < 0)
 	{
@@ -742,6 +769,7 @@ int eDVBTText::startPid(int pid)
 		return -errno;
 	}
 	eDebug("ok");
+#endif
 	return 0;
 }
 
@@ -877,12 +905,28 @@ int eTSMPEGDecoder::setState()
 		int *s = state_table[m_state];
 		if (changed & (changeState|changeVideo) && m_video)
 		{
+#if not defined(__sh__) // see comment below
 			m_video->setSlowMotion(s[1]);
 			m_video->setFastForward(s[2]);
+#endif
 			if (s[0])
 				m_video->unfreeze();
 			else
 				m_video->freeze();
+#if defined(__sh__)
+// the VIDEO_CONTINUE would reset the FASTFORWARD  command so we
+// execute the FASTFORWARD after the VIDEO_CONTINUE
+			if (s[1])
+			{
+				m_video->setFastForward(s[2]);
+				m_video->setSlowMotion(s[1]);
+			}
+			else
+			{
+				m_video->setSlowMotion(s[1]);
+				m_video->setFastForward(s[2]);
+			}
+#endif
 		}
 		if (changed & (changeState|changeAudio) && m_audio)
 		{
@@ -1183,6 +1227,10 @@ RESULT eTSMPEGDecoder::showSinglePic(const char *filename)
 		{
 			struct stat s;
 			fstat(f, &s);
+#if defined(__sh__) // our driver has a different behaviour for iframes
+			if (m_video_clip_fd >= 0)
+				finishShowSinglePic();
+#endif
 			if (m_video_clip_fd == -1)
 				m_video_clip_fd = open("/dev/dvb/adapter0/video0", O_WRONLY);
 			if (m_video_clip_fd >= 0)
@@ -1203,8 +1251,10 @@ RESULT eTSMPEGDecoder::showSinglePic(const char *filename)
 
 				if (ioctl(m_video_clip_fd, VIDEO_SELECT_SOURCE, VIDEO_SOURCE_MEMORY) < 0)
 					eDebug("VIDEO_SELECT_SOURCE MEMORY failed (%m)");
+#if not defined(__sh__)
 				if (ioctl(m_video_clip_fd, VIDEO_SET_STREAMTYPE, streamtype) < 0)
 					eDebug("VIDEO_SET_STREAMTYPE failed(%m)");
+#endif
 				if (ioctl(m_video_clip_fd, VIDEO_PLAY) < 0)
 					eDebug("VIDEO_PLAY failed (%m)");
 				if (ioctl(m_video_clip_fd, VIDEO_CONTINUE) < 0)
@@ -1221,7 +1271,9 @@ RESULT eTSMPEGDecoder::showSinglePic(const char *filename)
 				if (!seq_end_avail)
 					write(m_video_clip_fd, seq_end, sizeof(seq_end));
 				writeAll(m_video_clip_fd, stuffing, 8192);
+#if not defined(__sh__)
 				m_showSinglePicTimer->start(150, true);
+#endif
 			}
 			close(f);
 		}
diff --git a/lib/dvb/dvb.cpp b/lib/dvb/dvb.cpp
index 5102a98..8731a8b 100644
--- a/lib/dvb/dvb.cpp
+++ b/lib/dvb/dvb.cpp
@@ -115,6 +115,68 @@ eDVBResourceManager::eDVBResourceManager()
 		m_boxtype = DM800SE;
 	else if (!strncmp(tmp, "dm7020hd\n", rd))
 		m_boxtype = DM7020HD;
+#if defined(__sh__)
+	else if (!strncmp(tmp, "adb_box\n", rd))
+		m_boxtype = ADB_BOX;
+	else if (!strncmp(tmp, "ufs910\n", rd))
+		m_boxtype = UFS910;
+	else if (!strncmp(tmp, "ufs912\n", rd))
+		m_boxtype = UFS912;
+	else if (!strncmp(tmp, "ufs913\n", rd))
+		m_boxtype = UFS913;
+	else if (!strncmp(tmp, "ufs922\n", rd))
+		m_boxtype = UFS922;
+	else if (!strncmp(tmp, "ufc960\n", rd))
+		m_boxtype = UFC960;
+	else if (!strncmp(tmp, "tf7700hdpvr\n", rd))
+		m_boxtype = TF7700HDPVR;
+	else if (!strncmp(tmp, "hdbox\n", rd))
+		m_boxtype = HDBOX;
+	else if (!strncmp(tmp, "hl101\n", rd))
+		m_boxtype = HL101;
+	else if (!strncmp(tmp, "spark\n", rd))
+		m_boxtype = SPARK;
+	else if (!strncmp(tmp, "spark7162\n", rd))
+		m_boxtype = SPARK7162;
+	else if (!strncmp(tmp, "vip1-v2\n", rd))
+		m_boxtype = VIP1_V2;
+	else if (!strncmp(tmp, "vip2-v1\n", rd))
+		m_boxtype = VIP2_V1;
+	else if (!strncmp(tmp, "cuberevo\n", rd))
+		m_boxtype = CUBEREVO;
+	else if (!strncmp(tmp, "cuberevo-9500hd\n", rd))
+		m_boxtype = CUBEREVO_9500HD;
+	else if (!strncmp(tmp, "cuberevo-mini\n", rd))
+		m_boxtype = CUBEREVO_MINI;
+	else if (!strncmp(tmp, "cuberevo-mini2\n", rd))
+		m_boxtype = CUBEREVO_MINI2;
+	else if (!strncmp(tmp, "cuberevo-2000hd\n", rd))
+		m_boxtype = CUBEREVO_2000HD;
+	else if (!strncmp(tmp, "cuberevo-250hd\n", rd))
+		m_boxtype = CUBEREVO_250HD;
+	else if (!strncmp(tmp, "cuberevo-mini-fta\n", rd))
+		m_boxtype = CUBEREVO_MINI_FTA;
+	else if (!strncmp(tmp, "ipbox9900\n", rd))
+		m_boxtype = IPBOX9900;
+	else if (!strncmp(tmp, "ipbox99\n", rd))
+		m_boxtype = IPBOX99;
+	else if (!strncmp(tmp, "ipbox55\n", rd))
+		m_boxtype = IPBOX55;
+	else if (!strncmp(tmp, "octagon1008\n", rd))
+		m_boxtype = OCTAGON1008;
+	else if (!strncmp(tmp, "hs7810a\n", rd))
+		m_boxtype = HS7810A;
+	else if (!strncmp(tmp, "hs7110\n", rd))
+		m_boxtype = HS7110;
+	else if (!strncmp(tmp, "whitebox\n", rd))
+		m_boxtype = WHITEBOX;
+	else if (!strncmp(tmp, "atevio7500\n", rd))
+		m_boxtype = ATEVIO7500;
+	else if (!strncmp(tmp, "sagemcom88\n", rd))
+		m_boxtype = SAGEMCOM88;
+	else if (!strncmp(tmp, "arivalink200\n", rd))
+		m_boxtype = ARIVALINK200;
+#else
 	else {
 		eDebug("boxtype detection via /proc/stb/info not possible... use fallback via demux count!\n");
 		if (m_demux.size() == 3)
@@ -124,7 +186,7 @@ eDVBResourceManager::eDVBResourceManager()
 		else
 			m_boxtype = DM8000;
 	}
-
+#endif
 	eDebug("found %zd adapter, %zd frontends(%zd sim) and %zd demux, boxtype %d",
 		m_adapter.size(), m_frontend.size(), m_simulate_frontend.size(), m_demux.size(), m_boxtype);
 
@@ -925,6 +987,58 @@ RESULT eDVBResourceManager::allocateDemux(eDVBRegisteredFrontend *fe, ePtr<eDVBA
 			}
 		}
 	}
+#if defined(__sh__) // we use our own algo for demux detection
+	else if (m_boxtype == ADB_BOX || m_boxtype == UFS910 || m_boxtype == UFS912 || m_boxtype == UFS913 || m_boxtype == UFS922 || m_boxtype == UFC960 || m_boxtype == SPARK || m_boxtype == SPARK7162 || m_boxtype == TF7700HDPVR || m_boxtype == HDBOX ||
+		m_boxtype == HL101 || m_boxtype == CUBEREVO || m_boxtype == CUBEREVO_MINI || m_boxtype == CUBEREVO_MINI2 || m_boxtype == VIP1_V2 || m_boxtype == VIP2_V1 || m_boxtype == HS7810A || m_boxtype == HS7110 || m_boxtype == WHITEBOX ||	
+		m_boxtype == CUBEREVO_MINI_FTA || m_boxtype == CUBEREVO_250HD || m_boxtype == CUBEREVO_2000HD || m_boxtype == CUBEREVO_9500HD || m_boxtype == OCTAGON1008 || m_boxtype == ATEVIO7500 ||
+		m_boxtype == IPBOX9900 || m_boxtype == IPBOX99 || m_boxtype == IPBOX55 || m_boxtype == SAGEMCOM88 || m_boxtype == ARIVALINK200)
+	{
+		int n=0;
+		for (; i != m_demux.end(); ++i, ++n)
+		{
+			if(fe)
+			{
+				if (!i->m_inuse)
+				{
+					if (!unused)
+					{
+						// take the first unused
+						//eDebug("\nallocate demux b = %d\n",n);
+						unused = i;
+					}
+				}
+				else if (i->m_adapter == fe->m_adapter && i->m_demux->getSource() == fe->m_frontend->getDVBID())
+				{
+					// take the demux allocated to the same
+					// frontend,  just create a new reference
+					demux = new eDVBAllocatedDemux(i);
+					//eDebug("\nallocate demux b = %d\n",n);
+					return 0;
+				}
+			}
+			else if(n == (m_demux.size() - 1))
+			{
+				// Always use the last demux for PVR
+				// it is assumed that the last demux is not
+				// attached to a frontend. That is, there
+				// should be one instance of dvr & demux
+				// devices more than of frontend devices.
+				// Otherwise, playback and timeshift might
+				// interfere recording.
+				if (i->m_inuse)
+				{
+					// just create a new reference
+					demux = new eDVBAllocatedDemux(i);
+					//eDebug("\nallocate demux c = %d\n",n);
+					return 0;
+				}
+				unused = i;
+				//eDebug("\nallocate demux d = %d\n", n);
+				break;
+			}
+		}
+	}
+#endif
 	else
 	{
 		iDVBAdapter *adapter = fe ? fe->m_adapter : m_adapter.begin(); /* look for a demux on the same adapter as the frontend, or the first adapter for dvr playback */
@@ -2080,6 +2194,12 @@ RESULT eDVBChannel::playSource(ePtr<iTsSource> &source, const char *streaminfo_f
 			return -ENODEV;
 		}
 #else
+#if defined(__sh__) // our pvr device is called dvr
+		char dvrDev[128];
+		int dvrIndex = m_mgr->m_adapter.begin()->getNumDemux() - 1;
+		sprintf(dvrDev, "/dev/dvb/adapter0/dvr%d", dvrIndex);
+		m_pvr_fd_dst = open(dvrDev, O_WRONLY);
+#else
 		ePtr<eDVBAllocatedDemux> &demux = m_demux ? m_demux : m_decoder_demux;
 		if (demux)
 		{
@@ -2096,6 +2216,7 @@ RESULT eDVBChannel::playSource(ePtr<iTsSource> &source, const char *streaminfo_f
 			return -ENODEV;
 		}
 #endif
+#endif
 	}
 
 	m_pvr_thread = new eDVBChannelFilePush(m_source->getPacketSize());
diff --git a/lib/dvb/dvb.h b/lib/dvb/dvb.h
index fb63399..13dd82b 100644
--- a/lib/dvb/dvb.h
+++ b/lib/dvb/dvb.h
@@ -161,7 +161,11 @@ class eDVBResourceManager: public iObject, public Object
 	DECLARE_REF(eDVBResourceManager);
 	int avail, busy;
 
+#if not defined(__sh__)
 	enum { DM7025, DM800, DM500HD, DM800SE, DM8000, DM7020HD };
+#else
+	enum { DM7025, DM800, DM500HD, DM800SE, DM8000, DM7020HD, ADB_BOX, UFS910, UFS912, UFS913, UFS922, UFC960, TF7700HDPVR, HDBOX, HL101, CUBEREVO, CUBEREVO_MINI, CUBEREVO_MINI2, CUBEREVO_MINI_FTA, CUBEREVO_250HD, CUBEREVO_9500HD, CUBEREVO_2000HD, IPBOX9900, IPBOX99, IPBOX55, OCTAGON1008, VIP1_V2, VIP2_V1, SPARK, SPARK7162, ATEVIO7500, HS7810A, HS7110, WHITEBOX, SAGEMCOM88, ARIVALINK200};
+#endif
 
 	int m_boxtype;
 
@@ -273,6 +277,9 @@ public:
 		/* cannot be used for PVR channels. */
 	RESULT setChannel(const eDVBChannelID &id, ePtr<iDVBFrontendParameters> &feparam);
 	eDVBChannelID getChannelID() { return m_channel_id; }
+#if defined(__sh__) //see filepush.h
+	int getSkipMode() { return m_skipmode_m; }
+#endif
 
 	RESULT connectStateChange(const Slot1<void,iDVBChannel*> &stateChange, ePtr<eConnection> &connection);
 	RESULT connectEvent(const Slot2<void,iDVBChannel*,int> &eventChange, ePtr<eConnection> &connection);
diff --git a/lib/dvb/epgcache.cpp b/lib/dvb/epgcache.cpp
index 5e589e8..e8fcc48 100644
--- a/lib/dvb/epgcache.cpp
+++ b/lib/dvb/epgcache.cpp
@@ -25,7 +25,7 @@
 int eventData::CacheSize=0;
 bool eventData::isCacheCorrupt = 0;
 descriptorMap eventData::descriptors;
-uint8_t eventData::data[2 * 4096 + 12];
+__u8 eventData::data[2 * 4096 + 12];
 extern const uint32_t crc32_table[256];
 
 const eServiceReference &handleGroup(const eServiceReference &ref)
@@ -57,16 +57,16 @@ eventData::eventData(const eit_event_struct* e, int size, int type, int tsidonid
 	if (!e)
 		return;
 
-	uint32_t descr[65];
-	uint32_t *pdescr=descr;
+	__u32 descr[65];
+	__u32 *pdescr=descr;
 
-	uint8_t *data = (uint8_t*)e;
+	__u8 *data = (__u8*)e;
 	int ptr=12;
 	size -= 12;
 
 	while(size > 1)
 	{
-		uint8_t *descr = data+ptr;
+		__u8 *descr = data+ptr;
 		int descr_len = descr[1];
 		descr_len += 2;
 		if (size >= descr_len)
@@ -79,7 +79,7 @@ eventData::eventData(const eit_event_struct* e, int size, int type, int tsidonid
 				case CONTENT_DESCRIPTOR:
 				case PARENTAL_RATING_DESCRIPTOR:
 				{
-					uint32_t crc = 0;
+					__u32 crc = 0;
 					int cnt=0;
 					while(cnt++ < descr_len)
 						crc = (crc << 8) ^ crc32_table[((crc >> 24) ^ data[ptr++]) & 0xFF];
@@ -88,7 +88,7 @@ eventData::eventData(const eit_event_struct* e, int size, int type, int tsidonid
 					if ( it == descriptors.end() )
 					{
 						CacheSize+=descr_len;
-						uint8_t *d = new uint8_t[descr_len];
+						__u8 *d = new __u8[descr_len];
 						memcpy(d, descr, descr_len);
 						descriptors[crc] = descriptorPair(1, d);
 					}
@@ -125,7 +125,7 @@ eventData::eventData(const eit_event_struct* e, int size, int type, int tsidonid
 						*/
 						eventNameUTF8len = truncateUTF8(eventNameUTF8, 255 - 6);
 						int title_len = 6 + eventNameUTF8len;
-						uint8_t *title_data = new uint8_t[title_len + 2];
+						__u8 *title_data = new __u8[title_len + 2];
 						title_data[0] = SHORT_EVENT_DESCRIPTOR;
 						title_data[1] = title_len;
 						title_data[2] = descr[2];
@@ -137,7 +137,7 @@ eventData::eventData(const eit_event_struct* e, int size, int type, int tsidonid
 						title_data[7 + eventNameUTF8len] = 0;
 
 						//Calculate the CRC, based on our new data
-						uint32_t title_crc = 0;
+						__u32 title_crc = 0;
 						int cnt=0;
 						int tmpPtr = 0;
 						title_len += 2; //add 2 the length to include the 2 bytes in the header
@@ -163,7 +163,7 @@ eventData::eventData(const eit_event_struct* e, int size, int type, int tsidonid
 					{
 						textUTF8len = truncateUTF8(textUTF8, 255 - 6);
 						int text_len = 6 + textUTF8len;
-						uint8_t *text_data = new uint8_t[text_len + 2];
+						__u8 *text_data = new __u8[text_len + 2];
 						text_data[0] = SHORT_EVENT_DESCRIPTOR;
 						text_data[1] = text_len;
 						text_data[2] = descr[2];
@@ -174,7 +174,7 @@ eventData::eventData(const eit_event_struct* e, int size, int type, int tsidonid
 						text_data[7] = 0x15; //identify text as UTF-8
 						memcpy(&text_data[8], textUTF8.data(), textUTF8len);
 
-						uint32_t text_crc = 0;
+						__u32 text_crc = 0;
 						int cnt=0;
 						int tmpPtr = 0;
 						text_len += 2; //add 2 the length to include the 2 bytes in the header
@@ -209,9 +209,9 @@ eventData::eventData(const eit_event_struct* e, int size, int type, int tsidonid
 	}
 	ASSERT(pdescr <= &descr[65]);
 	ByteSize = 10+((pdescr-descr)*4);
-	EITdata = new uint8_t[ByteSize];
+	EITdata = new __u8[ByteSize];
 	CacheSize+=ByteSize;
-	memcpy(EITdata, (uint8_t*) e, 10);
+	memcpy(EITdata, (__u8*) e, 10);
 	memcpy(EITdata+10, descr, ByteSize-10);
 }
 
@@ -221,10 +221,25 @@ const eit_event_struct* eventData::get() const
 	int tmp = ByteSize - 10;
 	memcpy(data, EITdata, 10);
 	unsigned int descriptors_length = 0;
-	uint32_t *p = (uint32_t*)(EITdata + 10);
+#ifndef __sh__
+	__u32 *p = (__u32*)(EITdata + 10);
+#else
+// Dagobert: fix not aligned access
+	__u8 *p = (__u8*)(EITdata+10);
+#endif
 	while (tmp > 3)
 	{
-		descriptorMap::iterator it = descriptors.find(*p++);
+#ifndef __sh__
+		descriptorMap::iterator it =
+			descriptors.find(*p++);
+#else
+		__u32 index = p[3] << 24 | p[2] << 16 | p[1] << 8 | p[0];
+// eDebug("index %d %x, %x %x %x %x\n", index, index, p[0], p[1], p[2], p[3]);
+		descriptorMap::iterator it =
+			descriptors.find(index);
+
+		p += 4;
+#endif
 		if (it != descriptors.end())
 		{
 			unsigned int b = it->second.second[1] + 2;
@@ -249,12 +264,26 @@ eventData::~eventData()
 	if ( ByteSize )
 	{
 		CacheSize -= ByteSize;
-		uint32_t *d = (uint32_t*)(EITdata+10);
+#ifndef __sh__
+		__u32 *d = (__u32*)(EITdata+10);
+#else
+// Dagobert: fix not aligned access
+		__u8 *d = (__u8*)(EITdata+10);
+#endif
 		ByteSize -= 10;
 		while(ByteSize>3)
 		{
+#ifndef __sh__
 			descriptorMap::iterator it =
 				descriptors.find(*d++);
+#else
+			__u32 index = d[3] << 24 | d[2] << 16 | d[1] << 8 | d[0];
+// eDebug("index %d %x, %x %x %x %x\n", index, index, d[0], d[1], d[2], d[3]);
+			descriptorMap::iterator it =
+				descriptors.find(index);
+				
+			d += 4;
+#endif
 			if ( it != descriptors.end() )
 			{
 				descriptorPair &p = it->second;
@@ -279,16 +308,16 @@ void eventData::load(FILE *f)
 {
 	int size=0;
 	int id=0;
-	uint8_t header[2];
+	__u8 header[2];
 	descriptorPair p;
 	fread(&size, sizeof(int), 1, f);
 	while(size)
 	{
-		fread(&id, sizeof(uint32_t), 1, f);
+		fread(&id, sizeof(__u32), 1, f);
 		fread(&p.first, sizeof(int), 1, f);
 		fread(header, 2, 1, f);
 		int bytes = header[1]+2;
-		p.second = new uint8_t[bytes];
+		p.second = new __u8[bytes];
 		p.second[0] = header[0];
 		p.second[1] = header[1];
 		fread(p.second+2, bytes-2, 1, f);
@@ -307,7 +336,7 @@ void eventData::save(FILE *f)
 	fwrite(&size, sizeof(int), 1, f);
 	while(size)
 	{
-		fwrite(&it->first, sizeof(uint32_t), 1, f);
+		fwrite(&it->first, sizeof(__u32), 1, f);
 		fwrite(&it->second.first, sizeof(int), 1, f);
 		fwrite(it->second.second, it->second.second[1]+2, 1, f);
 		++it;
@@ -608,7 +637,7 @@ bool eEPGCache::FixOverlapping(std::pair<eventMap,timeMap> &servicemap, time_t T
 #endif
 			)
 		{
-			uint16_t event_id = tmp->second->getEventID();
+			__u16 event_id = tmp->second->getEventID();
 			servicemap.first.erase(event_id);
 #ifdef EPG_DEBUG
 			Event evt((uint8_t*)tmp->second->get());
@@ -643,7 +672,7 @@ bool eEPGCache::FixOverlapping(std::pair<eventMap,timeMap> &servicemap, time_t T
 	{
 		if (tmp->first != TM && tmp->second->type != PRIVATE)
 		{
-			uint16_t event_id = tmp->second->getEventID();
+			__u16 event_id = tmp->second->getEventID();
 			servicemap.first.erase(event_id);
 #ifdef EPG_DEBUG
 			Event evt((uint8_t*)tmp->second->get());
@@ -667,7 +696,7 @@ bool eEPGCache::FixOverlapping(std::pair<eventMap,timeMap> &servicemap, time_t T
 	return ret;
 }
 
-void eEPGCache::sectionRead(const uint8_t *data, int source, channel_data *channel)
+void eEPGCache::sectionRead(const __u8 *data, int source, channel_data *channel)
 {
 	eit_t *eit = (eit_t*) data;
 
@@ -735,7 +764,7 @@ void eEPGCache::sectionRead(const uint8_t *data, int source, channel_data *chann
 
 	while (ptr<len)
 	{
-		uint16_t event_hash;
+		__u16 event_hash;
 		eit_event_size = HILO(eit_event->descriptors_loop_length)+EIT_LOOP_SIZE;
 
 		duration = fromBCD(eit_event->duration_1)*3600+fromBCD(eit_event->duration_2)*60+fromBCD(eit_event->duration_3);
@@ -757,7 +786,7 @@ void eEPGCache::sectionRead(const uint8_t *data, int source, channel_data *chann
 		     ( (onid != 1714) || (duration != (24*3600-1)) )	// PlatformaHD invalid event
 		   )
 		{
-			uint16_t event_id = HILO(eit_event->event_id);
+			__u16 event_id = HILO(eit_event->event_id);
 			eventData *evt = 0;
 			int ev_erase_count = 0;
 			int tm_erase_count = 0;
@@ -859,7 +888,7 @@ void eEPGCache::sectionRead(const uint8_t *data, int source, channel_data *chann
 			{
 				// exempt memory
 				delete tm_it->second;
-				ev_it=prevEventIt=servicemap.first.insert( prevEventIt, std::pair<const uint16_t, eventData*>( event_id, evt) );
+				ev_it=prevEventIt=servicemap.first.insert( prevEventIt, std::pair<const __u16, eventData*>( event_id, evt) );
 				tm_it->second=evt;
 			}
 			else // added new eventData
@@ -867,7 +896,7 @@ void eEPGCache::sectionRead(const uint8_t *data, int source, channel_data *chann
 #ifdef EPG_DEBUG
 				consistencyCheck=false;
 #endif
-				ev_it=prevEventIt=servicemap.first.insert( prevEventIt, std::pair<const uint16_t, eventData*>( event_id, evt) );
+				ev_it=prevEventIt=servicemap.first.insert( prevEventIt, std::pair<const __u16, eventData*>( event_id, evt) );
 				tm_it=prevTimeIt=servicemap.second.insert( prevTimeIt, std::pair<const time_t, eventData*>( TM, evt ) );
 			}
 
@@ -924,7 +953,7 @@ next:
 		}
 #endif
 		ptr += eit_event_size;
-		eit_event=(eit_event_struct*)(((uint8_t*)eit_event)+eit_event_size);
+		eit_event=(eit_event_struct*)(((__u8*)eit_event)+eit_event_size);
 	}
 }
 
@@ -1049,8 +1078,8 @@ eEPGCache::~eEPGCache()
 	messages.send(Message::quit);
 	kill(); // waiting for thread shutdown
 	singleLock s(cache_lock);
-	for (eventCache::iterator evIt = eventDB.begin(); evIt != eventDB.end(); evIt++)
-		for (eventMap::iterator It = evIt->second.first.begin(); It != evIt->second.first.end(); It++)
+	for (eventCache::iterator evIt = eventDB.begin(); evIt != eventDB.end(); ++evIt)
+		for (eventMap::iterator It = evIt->second.first.begin(); It != evIt->second.first.end(); ++It)
 			delete It->second;
 }
 
@@ -1248,13 +1277,12 @@ void eEPGCache::load()
 				fread( &size, sizeof(int), 1, f);
 				while(size--)
 				{
-					uint8_t len=0;
-					uint8_t type=0;
-					eventData *event=0;
-					fread( &type, sizeof(uint8_t), 1, f);
-					fread( &len, sizeof(uint8_t), 1, f);
-					event = new eventData(0, len, type);
-					event->EITdata = new uint8_t[len];
+					__u8 len=0;
+					__u8 type=0;
+					fread( &type, sizeof(__u8), 1, f);
+					fread( &len, sizeof(__u8), 1, f);
+					eventData *event = new eventData(0, len, type);
+					event->EITdata = new __u8[len];
 					eventData::CacheSize+=len;
 					fread( event->EITdata, len, 1, f);
 					evMap[ event->getEventID() ]=event;
@@ -1288,11 +1316,11 @@ void eEPGCache::load()
 						while(size--)
 						{
 							time_t time1, time2;
-							uint16_t event_id;
+							__u16 event_id;
 							fread( &time1, sizeof(time_t), 1, f);
 							fread( &time2, sizeof(time_t), 1, f);
-							fread( &event_id, sizeof(uint16_t), 1, f);
-							content_time_tables[key][content_id][time1]=std::pair<time_t, uint16_t>(time2, event_id);
+							fread( &event_id, sizeof(__u16), 1, f);
+							content_time_tables[key][content_id][time1]=std::pair<time_t, __u16>(time2, event_id);
 							eventMap::iterator it =
 								evMap.find(event_id);
 							if (it != evMap.end())
@@ -1382,9 +1410,9 @@ void eEPGCache::save()
 		fwrite( &size, sizeof(int), 1, f);
 		for (timeMap::iterator time_it(timemap.begin()); time_it != timemap.end(); ++time_it)
 		{
-			uint8_t len = time_it->second->ByteSize;
-			fwrite( &time_it->second->type, sizeof(uint8_t), 1, f );
-			fwrite( &len, sizeof(uint8_t), 1, f);
+			__u8 len = time_it->second->ByteSize;
+			fwrite( &time_it->second->type, sizeof(__u8), 1, f );
+			fwrite( &len, sizeof(__u8), 1, f);
 			fwrite( time_it->second->EITdata, len, 1, f);
 			++cnt;
 		}
@@ -1412,7 +1440,7 @@ void eEPGCache::save()
 			{
 				fwrite( &it->first, sizeof(time_t), 1, f);
 				fwrite( &it->second.first, sizeof(time_t), 1, f);
-				fwrite( &it->second.second, sizeof(uint16_t), 1, f);
+				fwrite( &it->second.second, sizeof(__u16), 1, f);
 			}
 		}
 	}
@@ -1852,10 +1880,50 @@ void eEPGCache::channel_data::abortEPG()
 	pthread_mutex_unlock(&channel_active);
 }
 
-void eEPGCache::channel_data::readData( const uint8_t *data, int source)
+void eEPGCache::channel_data::readData( const __u8 *data, int source)
 {
 	int map;
 	iDVBSectionReader *reader = NULL;
+#ifdef __sh__
+/* Dagobert: this is still very hacky, but currently I cant find
+ * the origin of the readData call. I think the caller is
+ * responsible for the unaligned data pointer in this call.
+ * So we malloc our own memory here which _should_ be aligned.
+ *
+ * TODO: We should search for the origin of this call. As I
+ * said before I need an UML Diagram or must try to import
+ * e2 and all libs into an IDE for better overview ;)
+ *
+ */
+	const __u8 *aligned_data = NULL;
+	bool isNotAligned = false;
+	
+	if ((unsigned int) data % 4 != 0)
+		isNotAligned = true;
+		
+	if (isNotAligned)
+	{
+	
+		/* see HILO macro and eit.h */
+		int len = ((data[1] & 0x0F) << 8 | data[2]) -1;
+
+		/*eDebug("len %d %x, %x %x\n", len, len, data[1], data[2]);*/
+
+		if ( EIT_SIZE >= len )
+			return;
+
+		aligned_data = (const __u8 *) malloc(len);
+
+		if ((unsigned int)aligned_data % 4 != 0)
+		{
+			eDebug("eEPGCache::channel_data::readData: ERRORERRORERROR: unaligned data pointer %p\n", aligned_data);
+		}
+
+		/*eDebug("%p %p\n", aligned_data, data); */
+		memcpy((void *) aligned_data, (const __u8 *) data, len);
+		data = aligned_data;
+	}
+#endif
 	switch (source)
 	{
 		case NOWNEXT:
@@ -1953,7 +2021,7 @@ void eEPGCache::channel_data::readData( const uint8_t *data, int source)
 	else
 	{
 		eit_t *eit = (eit_t*) data;
-		uint32_t sectionNo = data[0] << 24;
+		__u32 sectionNo = data[0] << 24;
 		sectionNo |= data[3] << 16;
 		sectionNo |= data[4] << 8;
 		sectionNo |= eit->section_number;
@@ -1965,8 +2033,8 @@ void eEPGCache::channel_data::readData( const uint8_t *data, int source)
 		{
 			seenSections.insert(sectionNo);
 			calcedSections.insert(sectionNo);
-			uint32_t tmpval = sectionNo & 0xFFFFFF00;
-			uint8_t incr = source == NOWNEXT ? 1 : 8;
+			__u32 tmpval = sectionNo & 0xFFFFFF00;
+			__u8 incr = source == NOWNEXT ? 1 : 8;
 			for ( int i = 0; i <= eit->last_section_number; i+=incr )
 			{
 				if ( i == eit->section_number )
@@ -1980,16 +2048,20 @@ void eEPGCache::channel_data::readData( const uint8_t *data, int source)
 			cache->sectionRead(data, source, this);
 		}
 	}
+#ifdef __sh__
+	if (isNotAligned)
+		free((void *)aligned_data);
+#endif	
 }
 
 #if ENABLE_FREESAT
 
-freesatEITSubtableStatus::freesatEITSubtableStatus(u_char version, uint8_t maxSection) : version(version)
+freesatEITSubtableStatus::freesatEITSubtableStatus(u_char version, __u8 maxSection) : version(version)
 {
 	initMap(maxSection);
 }
 
-void freesatEITSubtableStatus::initMap(uint8_t maxSection)
+void freesatEITSubtableStatus::initMap(__u8 maxSection)
 {
 	int i, maxSectionIdx = maxSection / 8;
 	for (i = 0; i < 32; i++)
@@ -1998,18 +2070,18 @@ void freesatEITSubtableStatus::initMap(uint8_t maxSection)
 	}
 }
 
-bool freesatEITSubtableStatus::isSectionPresent(uint8_t sectionNo)
+bool freesatEITSubtableStatus::isSectionPresent(__u8 sectionNo)
 {
-	uint8_t sectionIdx = sectionNo / 8;
-	uint8_t bitOffset = sectionNo % 8;
+	__u8 sectionIdx = sectionNo / 8;
+	__u8 bitOffset = sectionNo % 8;
 
 	return ((sectionMap[sectionIdx] & (1 << bitOffset)) != 0);
 }
 
 bool freesatEITSubtableStatus::isCompleted()
 {
-	uint32_t i = 0;
-	uint8_t calc;
+	__u32 i = 0;
+	__u8 calc;
 
 	while ( i < 32 )
 	{
@@ -2022,11 +2094,11 @@ bool freesatEITSubtableStatus::isCompleted()
 	return true; // All segments ok
 }
 
-void freesatEITSubtableStatus::seen(uint8_t sectionNo, uint8_t maxSegmentSection)
+void freesatEITSubtableStatus::seen(__u8 sectionNo, __u8 maxSegmentSection)
 {
-	uint8_t sectionIdx = sectionNo / 8;
-	uint8_t bitOffset = sectionNo % 8;
-	uint8_t maxBitOffset = maxSegmentSection % 8;
+	__u8 sectionIdx = sectionNo / 8;
+	__u8 bitOffset = sectionNo % 8;
+	__u8 maxBitOffset = maxSegmentSection % 8;
 
 	sectionMap[sectionIdx] &= 0x00FF; // Clear calc map
 	sectionMap[sectionIdx] |= ((0x01FF << maxBitOffset) & 0xFF00); // Set calc map
@@ -2038,7 +2110,7 @@ bool freesatEITSubtableStatus::isVersionChanged(u_char testVersion)
 	return version != testVersion;
 }
 
-void freesatEITSubtableStatus::updateVersion(u_char newVersion, uint8_t maxSection)
+void freesatEITSubtableStatus::updateVersion(u_char newVersion, __u8 maxSection)
 {
 	version = newVersion;
 	initMap(maxSection);
@@ -2050,16 +2122,16 @@ void eEPGCache::channel_data::cleanupFreeSat()
 	m_FreesatTablesToComplete = 0;
 }
 
-void eEPGCache::channel_data::readFreeSatScheduleOtherData( const uint8_t *data)
+void eEPGCache::channel_data::readFreeSatScheduleOtherData( const __u8 *data)
 {
 	eit_t *eit = (eit_t*) data;
-	uint32_t subtableNo = data[0] << 24; // Table ID
+	__u32 subtableNo = data[0] << 24; // Table ID
 	subtableNo |= data[3] << 16; // Service ID Hi
 	subtableNo |= data[4] << 8; // Service ID Lo
 
 	// Check for sub-table version in map
-	std::map<uint32_t, freesatEITSubtableStatus> &freeSatSubTableStatus = this->m_FreeSatSubTableStatus;
-	std::map<uint32_t, freesatEITSubtableStatus>::iterator itmap = freeSatSubTableStatus.find(subtableNo);
+	std::map<__u32, freesatEITSubtableStatus> &freeSatSubTableStatus = this->m_FreeSatSubTableStatus;
+	std::map<__u32, freesatEITSubtableStatus>::iterator itmap = freeSatSubTableStatus.find(subtableNo);
 
 	freesatEITSubtableStatus *fsstatus;
 	if ( itmap == freeSatSubTableStatus.end() )
@@ -2068,7 +2140,7 @@ void eEPGCache::channel_data::readFreeSatScheduleOtherData( const uint8_t *data)
 		//eDebug("[EPGC] New subtable (%x) version (%d) now/next (%d) tsid (%x/%x) onid (%x/%x)", subtableNo, eit->version_number, eit->current_next_indicator, eit->transport_stream_id_hi, eit->transport_stream_id_lo, eit->original_network_id_hi, eit->original_network_id_lo);
 		fsstatus = new freesatEITSubtableStatus(eit->version_number, eit->last_section_number);
 		m_FreesatTablesToComplete++;
-		freeSatSubTableStatus.insert(std::pair<uint32_t,freesatEITSubtableStatus>(subtableNo, *fsstatus));
+		freeSatSubTableStatus.insert(std::pair<__u32,freesatEITSubtableStatus>(subtableNo, *fsstatus));
 	}
 	else
 	{
@@ -2695,8 +2767,8 @@ static void fill_eit_duration(eit_event_struct *evt, int time)
     evt->duration_3 = toBCD((time % 3600) % 60);
 }
 
-static inline uint8_t HI(int x) { return (uint8_t) ((x >> 8) & 0xFF); }
-static inline uint8_t LO(int x) { return (uint8_t) (x & 0xFF); }
+static inline __u8 HI(int x) { return (__u8) ((x >> 8) & 0xFF); }
+static inline __u8 LO(int x) { return (__u8) (x & 0xFF); }
 #define SET_HILO(x, val) {x##_hi = ((val) >> 8); x##_lo = (val) & 0xff; }
 // convert from set of strings to DVB format (EIT)
 void eEPGCache::submitEventData(const std::vector<eServiceReferenceDVB>& serviceRefs, long start,
@@ -2706,8 +2778,8 @@ void eEPGCache::submitEventData(const std::vector<eServiceReferenceDVB>& service
 	if (!title)
 		return;
 	static const int EIT_LENGTH = 4108;
-	static const uint8_t codePage = 0x15; // UTF-8 encoding
-	uint8_t data[EIT_LENGTH];
+	static const __u8 codePage = 0x15; // UTF-8 encoding
+	__u8 data[EIT_LENGTH];
 
 	eit_t *packet = (eit_t *) data;
 	packet->table_id = 0x50;
@@ -2723,7 +2795,7 @@ void eEPGCache::submitEventData(const std::vector<eServiceReferenceDVB>& service
 
 	eit_event_t *evt_struct = (eit_event_t*) (data + EIT_SIZE);
 
-	uint16_t eventId = start & 0xFFFF;
+	__u16 eventId = start & 0xFFFF;
 	SET_HILO(evt_struct->event_id, eventId);
 
 	//6 bytes start time, 3 bytes duration
@@ -2735,7 +2807,7 @@ void eEPGCache::submitEventData(const std::vector<eServiceReferenceDVB>& service
 
 	//no support for different code pages, only DVB's latin1 character set
 	//TODO: convert text to correct character set (data is probably passed in as UTF-8)
-	uint8_t *x = (uint8_t *) evt_struct;
+	__u8 *x = (__u8 *) evt_struct;
 	x += EIT_LOOP_SIZE;
 	int nameLength = strnlen(title, 246);
 	int descLength = short_summary ? strnlen(short_summary, 246 - nameLength) : 0;
@@ -2749,7 +2821,7 @@ void eEPGCache::submitEventData(const std::vector<eServiceReferenceDVB>& service
 	short_evt->language_code_2 = 'n';
 	short_evt->language_code_3 = 'g';
 	short_evt->event_name_length = nameLength ? nameLength + 1 : 0;
-	x = (uint8_t *) short_evt;
+	x = (__u8 *) short_evt;
 	x += EIT_SHORT_EVENT_DESCRIPTOR_SIZE;
 	*x = codePage;
 	++x;
@@ -2781,7 +2853,7 @@ void eEPGCache::submitEventData(const std::vector<eServiceReferenceDVB>& service
 	}
 
 	//Long description
-	int currentLoopLength = x - (uint8_t*)short_evt;
+	int currentLoopLength = x - (__u8*)short_evt;
 	static const int overheadPerDescriptor = 9; //increase if codepages are added!!!
 	static const int MAX_LEN = 256 - overheadPerDescriptor;
 
@@ -2820,7 +2892,7 @@ void eEPGCache::submitEventData(const std::vector<eServiceReferenceDVB>& service
 	}
 
 	//TODO: add age and more
-	int desc_loop_length = x - ((uint8_t*)evt_struct + EIT_LOOP_SIZE);
+	int desc_loop_length = x - ((__u8*)evt_struct + EIT_LOOP_SIZE);
 	SET_HILO(evt_struct->descriptors_loop_length, desc_loop_length);
 
 	int packet_length = (x - data) - 3; //should add 1 for crc....
@@ -2987,7 +3059,7 @@ PyObject *eEPGCache::search(ePyObject arg)
 {
 	ePyObject ret;
 	int descridx = -1;
-	uint32_t descr[512];
+	__u32 descr[512];
 	int eventid = -1;
 	const char *argstring=0;
 	char *refstr=0;
@@ -3063,18 +3135,29 @@ PyObject *eEPGCache::search(ePyObject arg)
 						lookupEventId(ref, eventid, evData);
 						if (evData)
 						{
-							uint8_t *data = evData->EITdata;
+							__u8 *data = evData->EITdata;
 							int tmp = evData->ByteSize-10;
-							uint32_t *p = (uint32_t*)(data+10);
+#ifndef __sh__
+							__u32 *p = (__u32*)(data+10);
+#else
+// Dagobert: Alignment fix
+							__u8 *p = (__u8*)(data+10);
+#endif
 							// search short and extended event descriptors
 							while(tmp>3)
 							{
-								uint32_t crc = *p++;
+#ifndef __sh__
+								__u32 crc = *p++;
+#else
+// Dagobert: Alignment fix
+								__u32 crc = p[3] << 24 | p[2] << 16 | p[1] << 8 | p[0];
+								p += 4;
+#endif
 								descriptorMap::iterator it =
 									eventData::descriptors.find(crc);
 								if (it != eventData::descriptors.end())
 								{
-									uint8_t *descr_data = it->second.second;
+									__u8 *descr_data = it->second.second;
 									switch(descr_data[0])
 									{
 									case 0x4D ... 0x4E:
@@ -3132,7 +3215,7 @@ PyObject *eEPGCache::search(ePyObject arg)
 					for (descriptorMap::iterator it(eventData::descriptors.begin());
 						it != eventData::descriptors.end() && descridx < 511; ++it)
 					{
-						uint8_t *data = it->second.second;
+						__u8 *data = it->second.second;
 						if ( data[0] == 0x4D ) // short event descriptor
 						{
 							const char *titleptr = (const char*)&data[6];
@@ -3246,14 +3329,25 @@ PyObject *eEPGCache::search(ePyObject arg)
 					if (evit->second->getEventID() == eventid)
 						continue;
 				}
-				uint8_t *data = evit->second->EITdata;
+				__u8 *data = evit->second->EITdata;
 				int tmp = evit->second->ByteSize-10;
-				uint32_t *p = (uint32_t*)(data+10);
+#ifndef __sh__
+				__u32 *p = (__u32*)(data+10);
+#else
+// Dagobert: Alignment fix
+				__u8 *p = (__u8*)(data+10);
+#endif
 				// check if any of our descriptor used by this event
 				int cnt=-1;
 				while(tmp>3)
 				{
-					uint32_t crc32 = *p++;
+#ifndef __sh__
+					__u32 crc32 = *p++;
+#else
+// Dagobert: Alignment fix
+					__u32 crc32 = p[3] << 24 | p[2] << 16 | p[1] << 8 | p[0];
+					p += 4;
+#endif
 					for ( int i=0; i <= descridx; ++i)
 					{
 						if (descr[i] == crc32)  // found...
@@ -3398,7 +3492,7 @@ void eEPGCache::PMTready(eDVBServicePMTHandler *pmthandler)
 							case 0xC2: // user defined
 								if ((*desc)->getLength() == 8)
 								{
-									uint8_t buffer[10];
+									__u8 buffer[10];
 									(*desc)->writeToBuffer(buffer);
 									if (!memcmp((const char *)buffer+2, "EPGDATA", 7))
 									{
@@ -3482,14 +3576,14 @@ void eEPGCache::PMTready(eDVBServicePMTHandler *pmthandler)
 
 struct date_time
 {
-	uint8_t data[5];
+	__u8 data[5];
 	time_t tm;
 	date_time( const date_time &a )
 	{
 		memcpy(data, a.data, 5);
 		tm = a.tm;
 	}
-	date_time( const uint8_t data[5])
+	date_time( const __u8 data[5])
 	{
 		memcpy(this->data, data, 5);
 		tm = parseDVBtime(data[0], data[1], data[2], data[3], data[4]);
@@ -3497,7 +3591,7 @@ struct date_time
 	date_time()
 	{
 	}
-	const uint8_t& operator[](int pos) const
+	const __u8& operator[](int pos) const
 	{
 		return data[pos];
 	}
@@ -3511,7 +3605,7 @@ struct less_datetime
 	}
 };
 
-void eEPGCache::privateSectionRead(const uniqueEPGKey &current_service, const uint8_t *data)
+void eEPGCache::privateSectionRead(const uniqueEPGKey &current_service, const __u8 *data)
 {
 	contentMap &content_time_table = content_time_tables[current_service];
 	singleLock s(cache_lock);
@@ -3539,14 +3633,14 @@ void eEPGCache::privateSectionRead(const uniqueEPGKey &current_service, const ui
 	}
 	time_event_map.clear();
 
-	uint8_t duration[3];
+	__u8 duration[3];
 	memcpy(duration, data+ptr, 3);
 	ptr+=3;
 	int duration_sec =
 		fromBCD(duration[0])*3600+fromBCD(duration[1])*60+fromBCD(duration[2]);
 
-	const uint8_t *descriptors[65];
-	const uint8_t **pdescr = descriptors;
+	const __u8 *descriptors[65];
+	const __u8 **pdescr = descriptors;
 
 	int descriptors_length = (data[ptr++]&0x0F) << 8;
 	descriptors_length |= data[ptr++];
@@ -3588,7 +3682,7 @@ void eEPGCache::privateSectionRead(const uniqueEPGKey &current_service, const ui
 				descr_len -= 6;
 				while( descr_len > 2 )
 				{
-					uint8_t datetime[5];
+					__u8 datetime[5];
 					datetime[0] = data[ptr++];
 					datetime[1] = data[ptr++];
 					int tmp_len = data[ptr++];
@@ -3615,13 +3709,13 @@ void eEPGCache::privateSectionRead(const uniqueEPGKey &current_service, const ui
 		}
 	}
 	ASSERT(pdescr <= &descriptors[65]);
-	uint8_t event[4098];
+	__u8 event[4098];
 	eit_event_struct *ev_struct = (eit_event_struct*) event;
 	ev_struct->running_status = 0;
 	ev_struct->free_CA_mode = 1;
 	memcpy(event+7, duration, 3);
 	ptr = 12;
-	const uint8_t **d=descriptors;
+	const __u8 **d=descriptors;
 	while ( d < pdescr )
 	{
 		memcpy(event+ptr, *d, ((*d)[1])+2);
@@ -3640,7 +3734,7 @@ void eEPGCache::privateSectionRead(const uniqueEPGKey &current_service, const ui
 		for (std::list<uniqueEPGKey>::iterator i(it->second.begin()); i != it->second.end(); ++i)
 		{
 			event[bptr++] = 0x4A;
-			uint8_t *len = event+(bptr++);
+			__u8 *len = event+(bptr++);
 			event[bptr++] = (i->tsid & 0xFF00) >> 8;
 			event[bptr++] = (i->tsid & 0xFF);
 			event[bptr++] = (i->onid & 0xFF00) >> 8;
@@ -3659,12 +3753,12 @@ void eEPGCache::privateSectionRead(const uniqueEPGKey &current_service, const ui
 		while( tmMap.find(stime) != tmMap.end() )
 			++stime;
 		event[6] += (stime - it->first.tm);
-		uint16_t event_id = 0;
+		__u16 event_id = 0;
 		while( evMap.find(event_id) != evMap.end() )
 			++event_id;
 		event[0] = (event_id & 0xFF00) >> 8;
 		event[1] = (event_id & 0xFF);
-		time_event_map[it->first.tm]=std::pair<time_t, uint16_t>(stime, event_id);
+		time_event_map[it->first.tm]=std::pair<time_t, __u16>(stime, event_id);
 		eventData *d = new eventData( ev_struct, bptr, PRIVATE );
 		evMap[event_id] = d;
 		tmMap[stime] = d;
@@ -3693,7 +3787,7 @@ void eEPGCache::channel_data::startPrivateReader()
 	m_PrivateReader->start(mask);
 }
 
-void eEPGCache::channel_data::readPrivateData( const uint8_t *data)
+void eEPGCache::channel_data::readPrivateData( const __u8 *data)
 {
 	if ( seenPrivateSections.find(data[6]) == seenPrivateSections.end() )
 	{
@@ -3725,7 +3819,7 @@ void eEPGCache::channel_data::cleanupMHW()
 	m_program_ids.clear();
 }
 
-uint8_t *eEPGCache::channel_data::delimitName( uint8_t *in, uint8_t *out, int len_in )
+__u8 *eEPGCache::channel_data::delimitName( __u8 *in, __u8 *out, int len_in )
 {
 	// Names in mhw structs are not strings as they are not '\0' terminated.
 	// This function converts the mhw name into a string.
@@ -3760,7 +3854,7 @@ void eEPGCache::channel_data::timeMHW2DVB( u_char day, u_char hours, u_char minu
 {
 	char tz_saved[1024];
 	// Remove offset in mhw time.
-	uint8_t local_hours = hours;
+	__u8 local_hours = hours;
 	if ( hours >= 16 )
 		local_hours -= 4;
 	else if ( hours >= 8 )
@@ -3811,10 +3905,10 @@ void eEPGCache::channel_data::timeMHW2DVB( u_char day, u_char hours, u_char minu
 	timeMHW2DVB( recdate.tm_hour, minutes, return_time+2 );
 }
 
-void eEPGCache::channel_data::storeMHWTitle(std::map<uint32_t, mhw_title_t>::iterator itTitle, std::string sumText, const uint8_t *data)
+void eEPGCache::channel_data::storeMHWTitle(std::map<__u32, mhw_title_t>::iterator itTitle, std::string sumText, const __u8 *data)
 // data is borrowed from calling proc to save memory space.
 {
-	uint8_t name[34];
+	__u8 name[34];
 
 	// For each title a separate EIT packet will be sent to eEPGCache::sectionRead()
 	bool isMHW2 = itTitle->second.mhw2_mjd_hi || itTitle->second.mhw2_mjd_lo ||
@@ -3837,7 +3931,7 @@ void eEPGCache::channel_data::storeMHWTitle(std::map<uint32_t, mhw_title_t>::ite
 	packet->segment_last_section_number = 0; // eEPGCache::sectionRead() will dig this for the moment
 	packet->segment_last_table_id = 0x50;
 
-	uint8_t *title = isMHW2 ? ((uint8_t*)(itTitle->second.title))-4 : (uint8_t*)itTitle->second.title;
+	__u8 *title = isMHW2 ? ((__u8*)(itTitle->second.title))-4 : (__u8*)itTitle->second.title;
 	std::string prog_title = (char *) delimitName( title, name, isMHW2 ? 35 : 23 );
 	int prog_title_length = prog_title.length();
 
@@ -3963,7 +4057,7 @@ void eEPGCache::channel_data::startMHWTimeout(int msec)
 	m_MHWTimeoutet=false;
 }
 
-void eEPGCache::channel_data::startMHWReader(uint16_t pid, uint8_t tid)
+void eEPGCache::channel_data::startMHWReader(__u16 pid, __u8 tid)
 {
 	m_MHWFilterMask.pid = pid;
 	m_MHWFilterMask.data[0] = tid;
@@ -3971,7 +4065,7 @@ void eEPGCache::channel_data::startMHWReader(uint16_t pid, uint8_t tid)
 //	eDebug("start 0x%02x 0x%02x", pid, tid);
 }
 
-void eEPGCache::channel_data::startMHWReader2(uint16_t pid, uint8_t tid, int ext)
+void eEPGCache::channel_data::startMHWReader2(__u16 pid, __u8 tid, int ext)
 {
 	m_MHWFilterMask2.pid = pid;
 	m_MHWFilterMask2.data[0] = tid;
@@ -3990,7 +4084,7 @@ void eEPGCache::channel_data::startMHWReader2(uint16_t pid, uint8_t tid, int ext
 	m_MHWReader2->start(m_MHWFilterMask2);
 }
 
-void eEPGCache::channel_data::readMHWData(const uint8_t *data)
+void eEPGCache::channel_data::readMHWData(const __u8 *data)
 {
 	if ( m_MHWReader2 )
 		m_MHWReader2->stop();
@@ -4029,9 +4123,9 @@ void eEPGCache::channel_data::readMHWData(const uint8_t *data)
 		int record_size = sizeof( mhw_theme_name_t );
 		int nbr_records = int (len/record_size);
 		int idx_ptr = 0;
-		uint8_t next_idx = (uint8_t) *(data + 3 + idx_ptr);
-		uint8_t idx = 0;
-		uint8_t sub_idx = 0;
+		__u8 next_idx = (__u8) *(data + 3 + idx_ptr);
+		__u8 idx = 0;
+		__u8 sub_idx = 0;
 		for ( int i = 0; i < nbr_records; i++ )
 		{
 			mhw_theme_name_t *theme = (mhw_theme_name_t*) &data[19 + i*record_size];
@@ -4039,7 +4133,7 @@ void eEPGCache::channel_data::readMHWData(const uint8_t *data)
 			{
 				idx = (idx_ptr<<4);
 				idx_ptr++;
-				next_idx = (uint8_t) *(data + 3 + idx_ptr);
+				next_idx = (__u8) *(data + 3 + idx_ptr);
 				sub_idx = 0;
 			}
 			else
@@ -4057,7 +4151,7 @@ void eEPGCache::channel_data::readMHWData(const uint8_t *data)
 	// Titles table
 	{
 		mhw_title_t *title = (mhw_title_t*) data;
-		uint8_t name[24];
+		__u8 name[24];
 		std::string prog_title = (char *) delimitName( title->title, name, 23 );
 
 		if ( title->channel_id == 0xFF || prog_title.substr(0,7) == "BIENTOT" )	// Separator or BIENTOT record
@@ -4065,9 +4159,9 @@ void eEPGCache::channel_data::readMHWData(const uint8_t *data)
 		else
 		{
 			// Create unique key per title
-			uint32_t title_id = ((title->channel_id)<<16)|((title->dh.day)<<13)|((title->dh.hours)<<8)|
+			__u32 title_id = ((title->channel_id)<<16)|((title->dh.day)<<13)|((title->dh.hours)<<8)|
 				(title->ms.minutes);
-			uint32_t program_id = ((title->program_id_hi)<<24)|((title->program_id_mh)<<16)|
+			__u32 program_id = ((title->program_id_hi)<<24)|((title->program_id_mh)<<16)|
 				((title->program_id_ml)<<8)|(title->program_id_lo);
 
 			if ( m_titles.find( title_id ) == m_titles.end() )
@@ -4080,7 +4174,7 @@ void eEPGCache::channel_data::readMHWData(const uint8_t *data)
 				m_titles[ title_id ] = *title;
 				if ( (title->ms.summary_available) && (m_program_ids.find(program_id) == m_program_ids.end()) )
 					// program_ids will be used to gather summaries.
-					m_program_ids.insert(std::pair<uint32_t,uint32_t>(program_id,title_id));
+					m_program_ids.insert(std::pair<__u32,__u32>(program_id,title_id));
 				return;	// Continue reading of the current table.
 			}
 			else if (!checkMHWTimeout())
@@ -4104,7 +4198,7 @@ void eEPGCache::channel_data::readMHWData(const uint8_t *data)
 		mhw_summary_t *summary = (mhw_summary_t*) data;
 
 		// Create unique key per record
-		uint32_t program_id = ((summary->program_id_hi)<<24)|((summary->program_id_mh)<<16)|
+		__u32 program_id = ((summary->program_id_hi)<<24)|((summary->program_id_mh)<<16)|
 			((summary->program_id_ml)<<8)|(summary->program_id_lo);
 		int len = ((data[1]&0xf)<<8) + data[2];
 
@@ -4113,7 +4207,7 @@ void eEPGCache::channel_data::readMHWData(const uint8_t *data)
 		memcpy(&tmp, &data, sizeof(void*));
 		tmp[len+3] = 0;	// Terminate as a string.
 
-		std::multimap<uint32_t, uint32_t>::iterator itProgid( m_program_ids.find( program_id ) );
+		std::multimap<__u32, __u32>::iterator itProgid( m_program_ids.find( program_id ) );
 		if ( itProgid == m_program_ids.end() )
 		{ /*	This part is to prevent to looping forever if some summaries are not received yet.
 			There is a timeout of 4 sec. after the last successfully read summary. */
@@ -4129,7 +4223,7 @@ void eEPGCache::channel_data::readMHWData(const uint8_t *data)
 				the_text.replace(pos, 2, " ");
 
 			// Find corresponding title, store title and summary in epgcache.
-			std::map<uint32_t, mhw_title_t>::iterator itTitle( m_titles.find( itProgid->second ) );
+			std::map<__u32, mhw_title_t>::iterator itTitle( m_titles.find( itProgid->second ) );
 			if ( itTitle != m_titles.end() )
 			{
 				startMHWTimeout(4000);
@@ -4146,7 +4240,7 @@ void eEPGCache::channel_data::readMHWData(const uint8_t *data)
 		m_program_ids.size());
 	// Summaries have been read, titles that have summaries have been stored.
 	// Now store titles that do not have summaries.
-	for (std::map<uint32_t, mhw_title_t>::iterator itTitle(m_titles.begin()); itTitle != m_titles.end(); itTitle++)
+	for (std::map<__u32, mhw_title_t>::iterator itTitle(m_titles.begin()); itTitle != m_titles.end(); itTitle++)
 		storeMHWTitle( itTitle, "", data );
 	isRunning &= ~MHW;
 	m_MHWConn=0;
@@ -4156,7 +4250,7 @@ void eEPGCache::channel_data::readMHWData(const uint8_t *data)
 		finishEPG();
 }
 
-void eEPGCache::channel_data::readMHWData2(const uint8_t *data)
+void eEPGCache::channel_data::readMHWData2(const __u8 *data)
 {
 	int dataLen = (((data[1]&0xf) << 8) | data[2]) + 3;
 
@@ -4192,7 +4286,7 @@ void eEPGCache::channel_data::readMHWData2(const uint8_t *data)
 		else
 			goto abort;
 		// data seems consistent...
-		const uint8_t *tmp = data+121;
+		const __u8 *tmp = data+121;
 		for (int i=0; i < num_channels; ++i)
 		{
 			mhw_channel_name_t channel;
@@ -4273,17 +4367,17 @@ void eEPGCache::channel_data::readMHWData2(const uint8_t *data)
 			title.mhw2_duration_lo = duration&0xFF;
 
 			// Create unique key per title
-			uint32_t title_id = (data[pos+7] << 24) | (data[pos+8] << 16) | (data[pos+9] << 8) | data[pos+10];
+			__u32 title_id = (data[pos+7] << 24) | (data[pos+8] << 16) | (data[pos+9] << 8) | data[pos+10];
 
-			uint8_t slen = data[pos+18] & 0x3f;
-			uint8_t *dest = ((uint8_t*)title.title)-4;
+			__u8 slen = data[pos+18] & 0x3f;
+			__u8 *dest = ((__u8*)title.title)-4;
 			memcpy(dest, &data[pos+19], slen>35 ? 35 : slen);
 			memset(dest+slen, 0, 35-slen);
 			pos += 19 + slen;
 //			eDebug("%02x [%02x %02x]: %s", data[pos], data[pos+1], data[pos+2], dest);
 
 //			not used theme id (data[7] & 0x3f) + (data[pos] & 0x3f);
-			uint32_t summary_id = (data[pos+1] << 8) | data[pos+2];
+			__u32 summary_id = (data[pos+1] << 8) | data[pos+2];
 
 //			if (title.channel_id > m_channels.size())
 //				eDebug("channel_id(%d %02x) to big!!", title.channel_id);
@@ -4295,7 +4389,7 @@ void eEPGCache::channel_data::readMHWData2(const uint8_t *data)
 
 			pos += 3;
 
-			std::map<uint32_t, mhw_title_t>::iterator it = m_titles.find( title_id );
+			std::map<__u32, mhw_title_t>::iterator it = m_titles.find( title_id );
 			if ( it == m_titles.end() )
 			{
 				startMHWTimeout(5000);
@@ -4303,7 +4397,7 @@ void eEPGCache::channel_data::readMHWData2(const uint8_t *data)
 				if (summary_id != 0xFFFF)
 				{
 					bool add=true;
-					std::multimap<uint32_t, uint32_t>::iterator it(m_program_ids.lower_bound(summary_id));
+					std::multimap<__u32, __u32>::iterator it(m_program_ids.lower_bound(summary_id));
 					while (it != m_program_ids.end() && it->first == summary_id)
 					{
 						if (it->second == title_id) {
@@ -4313,7 +4407,7 @@ void eEPGCache::channel_data::readMHWData2(const uint8_t *data)
 						++it;
 					}
 					if (add)
-						m_program_ids.insert(std::pair<uint32_t,uint32_t>(summary_id,title_id));
+						m_program_ids.insert(std::pair<__u32,__u32>(summary_id,title_id));
 				}
 			}
 			else
@@ -4377,7 +4471,7 @@ void eEPGCache::channel_data::readMHWData2(const uint8_t *data)
 			if (valid)
 			{
 				// data seems consistent...
-				uint32_t summary_id = (data[3]<<8)|data[4];
+				__u32 summary_id = (data[3]<<8)|data[4];
 //				eDebug ("summary id %04x\n", summary_id);
 //				eDebug("[%02x %02x] %02x %02x %02x %02x %02x %02x %02x %02x XX\n", data[3], data[4], data[5], data[6], data[7], data[8], data[9], data[10], data[11], data[12], data[13] );
 
@@ -4401,7 +4495,7 @@ void eEPGCache::channel_data::readMHWData2(const uint8_t *data)
 				else
 					tmp[pos+1] = 0;
 
-				std::multimap<uint32_t, uint32_t>::iterator itProgId( m_program_ids.lower_bound(summary_id) );
+				std::multimap<__u32, __u32>::iterator itProgId( m_program_ids.lower_bound(summary_id) );
 				if ( itProgId == m_program_ids.end() || itProgId->first != summary_id)
 				{ /*	This part is to prevent to looping forever if some summaries are not received yet.
 					There is a timeout of 4 sec. after the last successfully read summary. */
@@ -4419,7 +4513,7 @@ void eEPGCache::channel_data::readMHWData2(const uint8_t *data)
 					{
 //						eDebug(".");
 						// Find corresponding title, store title and summary in epgcache.
-						std::map<uint32_t, mhw_title_t>::iterator itTitle( m_titles.find( itProgId->second ) );
+						std::map<__u32, mhw_title_t>::iterator itTitle( m_titles.find( itProgId->second ) );
 						if ( itTitle != m_titles.end() )
 						{
 							storeMHWTitle( itTitle, the_text, data );
@@ -4453,7 +4547,7 @@ void eEPGCache::channel_data::readMHWData2(const uint8_t *data)
 		{
 			// Summaries have been read, titles that have summaries have been stored.
 			// Now store titles that do not have summaries.
-			for (std::map<uint32_t, mhw_title_t>::iterator itTitle(m_titles.begin()); itTitle != m_titles.end(); itTitle++)
+			for (std::map<__u32, mhw_title_t>::iterator itTitle(m_titles.begin()); itTitle != m_titles.end(); itTitle++)
 				storeMHWTitle( itTitle, "", data );
 			eDebug("[EPGC] mhw2 finished(%ld) %d summaries not found",
 				::time(0),
diff --git a/lib/dvb/frontend.cpp b/lib/dvb/frontend.cpp
index 9613b93..57cc6f5 100644
--- a/lib/dvb/frontend.cpp
+++ b/lib/dvb/frontend.cpp
@@ -98,21 +98,26 @@ void eDVBFrontendParametersSatellite::set(const SatelliteDeliverySystemDescripto
 		orbital_position = 3600 - orbital_position;
 	system = descriptor.getModulationSystem();
 	modulation = descriptor.getModulation();
-	if (system == System_DVB_S && modulation == Modulation_8PSK)
+	if (system == System_DVB_S && modulation == Modulation_QPSK)
 	{
 		eDebug("satellite_delivery_descriptor invalid modulation type.. force QPSK");
 		modulation = Modulation_QPSK;
 	}
 	rolloff = descriptor.getRollOff();
+	is_id = NO_STREAM_ID_FILTER;
+	pls_mode = 0; pls_code = 1;
 	if (system == System_DVB_S2)
 	{
-		eDebug("SAT DVB-S2 freq %d, %s, pos %d, sr %d, fec %d, modulation %d, rolloff %d",
+		eDebug("SAT DVB-S2 freq %d, %s, pos %d, sr %d, fec %d, modulation %d, rolloff %d, is_id %d, pls_mode %d, pls_code %d",
 			frequency,
 			polarisation ? "hor" : "vert",
 			orbital_position,
 			symbol_rate, fec,
 			modulation,
-			rolloff);
+			rolloff,
+			is_id,
+			pls_mode,
+			pls_code);
 	}
 	else
 	{
@@ -187,7 +192,7 @@ void eDVBFrontendParametersTerrestrial::set(const TerrestrialDeliverySystemDescr
 		modulation = Modulation_Auto;
 	inversion = Inversion_Unknown;
 	system = System_DVB_T;
-	plpid = 0;
+	plp_id = 0;
 	eDebug("Terr freq %d, bw %d, cr_hp %d, cr_lp %d, tm_mode %d, guard %d, hierarchy %d, const %d",
 		frequency, bandwidth, code_rate_HP, code_rate_LP, transmission_mode,
 		guard_interval, hierarchy, modulation);
@@ -291,6 +296,12 @@ RESULT eDVBFrontendParameters::calculateDifference(const iDVBFrontendParameters
 				diff = 1<<29;
 			else if (sat.polarisation != osat.polarisation)
 				diff = 1<<28;
+			else if (sat.is_id != osat.is_id)
+				diff = 1<<27;
+			else if (sat.pls_mode != osat.pls_mode)
+				diff = 1<<27;
+			else if (sat.pls_code != osat.pls_code)
+				diff = 1<<27;
 			else if (exact && sat.fec != osat.fec && sat.fec != eDVBFrontendParametersSatellite::FEC_Auto && osat.fec != eDVBFrontendParametersSatellite::FEC_Auto)
 				diff = 1<<27;
 			else if (exact && sat.modulation != osat.modulation && sat.modulation != eDVBFrontendParametersSatellite::Modulation_Auto && osat.modulation != eDVBFrontendParametersSatellite::Modulation_Auto)
@@ -354,7 +365,7 @@ RESULT eDVBFrontendParameters::calculateDifference(const iDVBFrontendParameters
 				oterrestrial.code_rate_HP != eDVBFrontendParametersTerrestrial::FEC_Auto &&
 				terrestrial.code_rate_HP != eDVBFrontendParametersTerrestrial::FEC_Auto)
 				diff = 1 << 30;
-			else if (oterrestrial.plpid != terrestrial.plpid)
+			else if (oterrestrial.plp_id != terrestrial.plp_id)
 				diff = 1 << 27;
 			else if (oterrestrial.system != terrestrial.system)
 				diff = 1 << 30;
@@ -780,7 +791,11 @@ void eDVBFrontend::calculateSignalQuality(int snr, int &signalquality, int &sign
 {
 	int sat_max = 1600; // for stv0288 / bsbe2
 	int ret = 0x12345678;
-	if (!strcmp(m_description, "AVL2108")) // ET9000
+	if (strstr(m_description, "STV090x Multistandard"))
+	{
+		ret = (int)(snr / 32.768);
+	}
+	else if (!strcmp(m_description, "AVL2108")) // ET9000
 	{
 		ret = (int)(snr / 40.5);
 		sat_max = 1618;
@@ -1679,7 +1694,8 @@ void eDVBFrontend::setFrontend(bool recvEvents)
 			{
 				case eDVBFrontendParametersSatellite::Modulation_QPSK: modulation = QPSK; break;
 				case eDVBFrontendParametersSatellite::Modulation_8PSK: modulation = PSK_8; break;
-				case eDVBFrontendParametersSatellite::Modulation_QAM16: modulation = QAM_16; break;
+				case eDVBFrontendParametersSatellite::Modulation_16APSK: modulation = APSK_16; break;
+				case eDVBFrontendParametersSatellite::Modulation_32APSK: modulation = APSK_32; break;
 			}
 			switch (parm.pilot)
 			{
@@ -1723,8 +1739,9 @@ void eDVBFrontend::setFrontend(bool recvEvents)
 			{
 				p[cmdseq.num].cmd = DTV_ROLLOFF, p[cmdseq.num].u.data = rolloff, cmdseq.num++;
 				p[cmdseq.num].cmd = DTV_PILOT, p[cmdseq.num].u.data = pilot, cmdseq.num++;
+				p[cmdseq.num].cmd = DTV_STREAM_ID, p[cmdseq.num].u.data = parm.is_id | (parm.pls_code << 8) | (parm.pls_mode << 26), cmdseq.num++;
+			}
 			}
-		}
 		else if (type == iDVBFrontend::feCable)
 		{
 			eDVBFrontendParametersCable parm;
@@ -1822,12 +1839,12 @@ void eDVBFrontend::setFrontend(bool recvEvents)
 			switch (parm.code_rate_LP)
 			{
 				case eDVBFrontendParametersTerrestrial::FEC_1_2: p[cmdseq.num].u.data = FEC_1_2; break;
+				case eDVBFrontendParametersTerrestrial::FEC_3_5: p[cmdseq.num].u.data = FEC_3_5; break;
 				case eDVBFrontendParametersTerrestrial::FEC_2_3: p[cmdseq.num].u.data = FEC_2_3; break;
 				case eDVBFrontendParametersTerrestrial::FEC_3_4: p[cmdseq.num].u.data = FEC_3_4; break;
+				case eDVBFrontendParametersTerrestrial::FEC_4_5: p[cmdseq.num].u.data = FEC_4_5; break;
 				case eDVBFrontendParametersTerrestrial::FEC_5_6: p[cmdseq.num].u.data = FEC_5_6; break;
-				case eDVBFrontendParametersTerrestrial::FEC_6_7: p[cmdseq.num].u.data = FEC_6_7; break;
 				case eDVBFrontendParametersTerrestrial::FEC_7_8: p[cmdseq.num].u.data = FEC_7_8; break;
-				case eDVBFrontendParametersTerrestrial::FEC_8_9: p[cmdseq.num].u.data = FEC_8_9; break;
 				default:
 				case eDVBFrontendParametersTerrestrial::FEC_Auto: p[cmdseq.num].u.data = FEC_AUTO; break;
 			}
@@ -1837,12 +1854,12 @@ void eDVBFrontend::setFrontend(bool recvEvents)
 			switch (parm.code_rate_HP)
 			{
 				case eDVBFrontendParametersTerrestrial::FEC_1_2: p[cmdseq.num].u.data = FEC_1_2; break;
+				case eDVBFrontendParametersTerrestrial::FEC_3_5: p[cmdseq.num].u.data = FEC_3_5; break;
 				case eDVBFrontendParametersTerrestrial::FEC_2_3: p[cmdseq.num].u.data = FEC_2_3; break;
 				case eDVBFrontendParametersTerrestrial::FEC_3_4: p[cmdseq.num].u.data = FEC_3_4; break;
+				case eDVBFrontendParametersTerrestrial::FEC_4_5: p[cmdseq.num].u.data = FEC_4_5; break;
 				case eDVBFrontendParametersTerrestrial::FEC_5_6: p[cmdseq.num].u.data = FEC_5_6; break;
-				case eDVBFrontendParametersTerrestrial::FEC_6_7: p[cmdseq.num].u.data = FEC_6_7; break;
 				case eDVBFrontendParametersTerrestrial::FEC_7_8: p[cmdseq.num].u.data = FEC_7_8; break;
-				case eDVBFrontendParametersTerrestrial::FEC_8_9: p[cmdseq.num].u.data = FEC_8_9; break;
 				default:
 				case eDVBFrontendParametersTerrestrial::FEC_Auto: p[cmdseq.num].u.data = FEC_AUTO; break;
 			}
@@ -1911,9 +1928,9 @@ void eDVBFrontend::setFrontend(bool recvEvents)
 				if (m_dvbversion >= DVB_VERSION(5, 3))
 				{
 #if defined DTV_STREAM_ID
-					p[cmdseq.num].cmd = DTV_STREAM_ID, p[cmdseq.num].u.data = parm.plpid, cmdseq.num++;
+					p[cmdseq.num].cmd = DTV_STREAM_ID, p[cmdseq.num].u.data = parm.plp_id, cmdseq.num++;
 #elif defined DTV_DVBT2_PLP_ID
-					p[cmdseq.num].cmd = DTV_DVBT2_PLP_ID, p[cmdseq.num].u.data = parm.plpid, cmdseq.num++;
+					p[cmdseq.num].cmd = DTV_DVBT2_PLP_ID, p[cmdseq.num].u.data = parm.plp_id, cmdseq.num++;
 #endif
 				}
 			}
@@ -1966,7 +1983,6 @@ void eDVBFrontend::setFrontend(bool recvEvents)
 		}
 	}
 }
-
 RESULT eDVBFrontend::prepare_sat(const eDVBFrontendParametersSatellite &feparm, unsigned int tunetimeout)
 {
 	int res;
@@ -1979,7 +1995,7 @@ RESULT eDVBFrontend::prepare_sat(const eDVBFrontendParametersSatellite &feparm,
 	res = m_sec->prepare(*this, feparm, satfrequency, 1 << m_slotid, tunetimeout);
 	if (!res)
 	{
-		eDebugNoSimulate("prepare_sat System %d Freq %d Pol %d SR %d INV %d FEC %d orbpos %d system %d modulation %d pilot %d, rolloff %d",
+		eDebugNoSimulate("prepare_sat System %d Freq %d Pol %d SR %d INV %d FEC %d orbpos %d system %d modulation %d pilot %d, rolloff %d, is_id %d, pls_mode %d, pls_code %d",
 			feparm.system,
 			feparm.frequency,
 			feparm.polarisation,
@@ -1990,7 +2006,10 @@ RESULT eDVBFrontend::prepare_sat(const eDVBFrontendParametersSatellite &feparm,
 			feparm.system,
 			feparm.modulation,
 			feparm.pilot,
-			feparm.rolloff);
+			feparm.rolloff,
+			feparm.is_id,
+			feparm.pls_mode,
+			feparm.pls_code);
 		if ((unsigned int)satfrequency < fe_info.frequency_min || (unsigned int)satfrequency > fe_info.frequency_max)
 		{
 			eDebugNoSimulate("%d mhz out of tuner range.. dont tune", satfrequency / 1000);
diff --git a/lib/dvb/frontendparms.cpp b/lib/dvb/frontendparms.cpp
index 92eda4e..dfacc48 100644
--- a/lib/dvb/frontendparms.cpp
+++ b/lib/dvb/frontendparms.cpp
@@ -158,6 +158,21 @@ int eDVBTransponderData::getSystem() const
 	return -1;
 }
 
+int eDVBTransponderData::getIsId() const
+{
+	return -1;
+}
+
+int eDVBTransponderData::getPLSMode() const
+{
+	return -1;
+}
+
+int eDVBTransponderData::getPLSCode() const
+{
+	return -1;
+}
+
 int eDVBTransponderData::getBandwidth() const
 {
 	return -1;
@@ -273,6 +288,8 @@ int eDVBSatelliteTransponderData::getModulation() const
 	default: eDebug("got unsupported modulation from frontend! report as QPSK!");
 	case QPSK: return eDVBFrontendParametersSatellite::Modulation_QPSK;
 	case PSK_8: return eDVBFrontendParametersSatellite::Modulation_8PSK;
+	case APSK_16: return eDVBFrontendParametersSatellite::Modulation_16APSK;
+	case APSK_32: return eDVBFrontendParametersSatellite::Modulation_32APSK;
 	}
 }
 
@@ -320,6 +337,27 @@ int eDVBSatelliteTransponderData::getSystem() const
 	}
 }
 
+int eDVBSatelliteTransponderData::getIsId() const
+{
+	if (originalValues) return transponderParameters.is_id;
+
+	return getProperty(DTV_STREAM_ID) & 0xFF;
+}
+
+int eDVBSatelliteTransponderData::getPLSMode() const
+{
+	if (originalValues) return transponderParameters.pls_mode;
+
+	return (getProperty(DTV_STREAM_ID) >> 26) & 0x3;
+}
+
+int eDVBSatelliteTransponderData::getPLSCode() const
+{
+	if (originalValues) return transponderParameters.pls_code;
+
+	return (getProperty(DTV_STREAM_ID) >> 8) & 0x3FFFF;
+}
+
 DEFINE_REF(eDVBCableTransponderData);
 
 eDVBCableTransponderData::eDVBCableTransponderData(struct dtv_property *dtvproperties, unsigned int propertycount, eDVBFrontendParametersCable &transponderparms, bool original)
@@ -458,8 +496,10 @@ int eDVBTerrestrialTransponderData::getCodeRateLp() const
 	switch (getProperty(DTV_CODE_RATE_LP))
 	{
 	case FEC_1_2: return eDVBFrontendParametersTerrestrial::FEC_1_2;
+	case FEC_3_5: return eDVBFrontendParametersTerrestrial::FEC_3_5;
 	case FEC_2_3: return eDVBFrontendParametersTerrestrial::FEC_2_3;
 	case FEC_3_4: return eDVBFrontendParametersTerrestrial::FEC_3_4;
+	case FEC_4_5: return eDVBFrontendParametersTerrestrial::FEC_4_5;
 	case FEC_5_6: return eDVBFrontendParametersTerrestrial::FEC_5_6;
 	case FEC_7_8: return eDVBFrontendParametersTerrestrial::FEC_7_8;
 	default:
@@ -474,8 +514,10 @@ int eDVBTerrestrialTransponderData::getCodeRateHp() const
 	switch (getProperty(DTV_CODE_RATE_HP))
 	{
 	case FEC_1_2: return eDVBFrontendParametersTerrestrial::FEC_1_2;
+	case FEC_3_5: return eDVBFrontendParametersTerrestrial::FEC_3_5;
 	case FEC_2_3: return eDVBFrontendParametersTerrestrial::FEC_2_3;
 	case FEC_3_4: return eDVBFrontendParametersTerrestrial::FEC_3_4;
+	case FEC_4_5: return eDVBFrontendParametersTerrestrial::FEC_4_5;
 	case FEC_5_6: return eDVBFrontendParametersTerrestrial::FEC_5_6;
 	case FEC_7_8: return eDVBFrontendParametersTerrestrial::FEC_7_8;
 	default:
@@ -508,6 +550,7 @@ int eDVBTerrestrialTransponderData::getTransmissionMode() const
 	case TRANSMISSION_MODE_8K: return eDVBFrontendParametersTerrestrial::TransmissionMode_8k;
 #if DVB_API_VERSION > 5 || DVB_API_VERSION == 5 && DVB_API_VERSION_MINOR >= 5
 	case TRANSMISSION_MODE_1K: return eDVBFrontendParametersTerrestrial::TransmissionMode_1k;
+	case TRANSMISSION_MODE_4K: return eDVBFrontendParametersTerrestrial::TransmissionMode_4k;
 	case TRANSMISSION_MODE_16K: return eDVBFrontendParametersTerrestrial::TransmissionMode_16k;
 	case TRANSMISSION_MODE_32K: return eDVBFrontendParametersTerrestrial::TransmissionMode_32k;
 #endif
@@ -553,7 +596,7 @@ int eDVBTerrestrialTransponderData::getHierarchyInformation() const
 
 int eDVBTerrestrialTransponderData::getPlpId() const
 {
-	if (originalValues) return transponderParameters.plpid;
+	if (originalValues) return transponderParameters.plp_id;
 
 #if defined DTV_STREAM_ID
 	return getProperty(DTV_STREAM_ID);
diff --git a/lib/dvb/frontendparms.h b/lib/dvb/frontendparms.h
index c105cbb..d240f17 100644
--- a/lib/dvb/frontendparms.h
+++ b/lib/dvb/frontendparms.h
@@ -12,6 +12,14 @@
 
 #include <linux/dvb/frontend.h>
 
+#ifndef DTV_STREAM_ID
+	#define DTV_STREAM_ID DTV_ISDBS_TS_ID
+#endif
+
+#ifndef NO_STREAM_ID_FILTER
+	#define NO_STREAM_ID_FILTER	(~0U)
+#endif
+
 struct eDVBFrontendParametersSatellite
 {
 #ifndef SWIG
@@ -35,7 +43,7 @@ struct eDVBFrontendParametersSatellite
 	};
 
 	enum {
-		Modulation_Auto, Modulation_QPSK, Modulation_8PSK, Modulation_QAM16
+		Modulation_Auto, Modulation_QPSK, Modulation_8PSK, Modulation_16APSK, Modulation_32APSK
 	};
 
 	// dvb-s2
@@ -47,9 +55,13 @@ struct eDVBFrontendParametersSatellite
 		Pilot_Off, Pilot_On, Pilot_Unknown
 	};
 
+	enum {
+		PLS_Root, PLS_Gold, PLS_Combo, PLS_Unknown
+	};
+
 	bool no_rotor_command_on_tune;
 	unsigned int frequency, symbol_rate;
-	int polarisation, fec, inversion, orbital_position, system, modulation, rolloff, pilot;
+	int polarisation, fec, inversion, orbital_position, system, modulation, rolloff, pilot, is_id, pls_mode, pls_code;
 };
 SWIG_ALLOW_OUTPUT_SIMPLE(eDVBFrontendParametersSatellite);
 
@@ -98,7 +110,7 @@ struct eDVBFrontendParametersTerrestrial
 	 * (and it's too late to fix this now, we would break backward compatibility)
 	 */
 	enum {
-		FEC_1_2=0, FEC_2_3=1, FEC_3_4=2, FEC_5_6=3, FEC_7_8=4, FEC_Auto=5, FEC_6_7=6, FEC_8_9=7
+		FEC_1_2=0, FEC_2_3=1, FEC_3_4=2, FEC_5_6=3, FEC_7_8=4, FEC_Auto=5, FEC_3_5=6, FEC_4_5=7
 	};
 
 	enum {
@@ -134,7 +146,7 @@ struct eDVBFrontendParametersTerrestrial
 	int hierarchy;
 	int inversion;
 	int system;
-	int plpid;
+	int plp_id;
 };
 SWIG_ALLOW_OUTPUT_SIMPLE(eDVBFrontendParametersTerrestrial);
 
@@ -200,6 +212,9 @@ public:
 	int getRolloff() const;
 	int getPilot() const;
 	int getSystem() const;
+	int getIsId() const;
+	int getPLSMode() const;
+	int getPLSCode() const;
 	int getBandwidth() const;
 	int getCodeRateLp() const;
 	int getCodeRateHp() const;
@@ -231,6 +246,9 @@ public:
 	int getRolloff() const;
 	int getPilot() const;
 	int getSystem() const;
+	int getIsId() const;
+	int getPLSMode() const;
+	int getPLSCode() const;
 };
 
 class eDVBCableTransponderData : public eDVBTransponderData
diff --git a/lib/dvb/idvb.h b/lib/dvb/idvb.h
index dcb64c6..c436418 100644
--- a/lib/dvb/idvb.h
+++ b/lib/dvb/idvb.h
@@ -3,6 +3,7 @@
 
 #ifndef SWIG
 
+#include <linux/dvb/version.h>
 #include <linux/dvb/frontend.h>
 #include <linux/dvb/video.h>
 #include <lib/base/object.h>
@@ -479,6 +480,9 @@ public:
 	virtual int getRolloff() const = 0;
 	virtual int getPilot() const = 0;
 	virtual int getSystem() const = 0;
+	virtual int getIsId() const = 0;
+	virtual int getPLSMode() const = 0;
+	virtual int getPLSCode() const = 0;
 	virtual int getBandwidth() const = 0;
 	virtual int getCodeRateLp() const = 0;
 	virtual int getCodeRateHp() const = 0;
diff --git a/lib/dvb/pmt.cpp b/lib/dvb/pmt.cpp
index f5028aa..ef3b4f9 100644
--- a/lib/dvb/pmt.cpp
+++ b/lib/dvb/pmt.cpp
@@ -780,6 +780,11 @@ int eDVBServicePMTHandler::tuneExt(eServiceReferenceDVB &ref, int use_decode_dem
 			eDVBCIInterfaces::getInstance()->addPMTHandler(this);
 	} else if (!simulate) // no simulation of playback services
 	{
+		if (m_service_type == streamclient)
+		{
+			eDebug("force setServiceID(1)");
+			m_reference.setServiceID(1);
+		}
 		if (!ref.getServiceID().get() /* incorrect sid in meta file or recordings.epl*/ )
 		{
 			eDVBTSTools tstools;
diff --git a/lib/dvb/scan.cpp b/lib/dvb/scan.cpp
index e79a121..487f529 100644
--- a/lib/dvb/scan.cpp
+++ b/lib/dvb/scan.cpp
@@ -515,8 +515,8 @@ void eDVBScan::addChannelToScan(iDVBFrontendParameters *feparm)
 	{
 		eDVBFrontendParametersSatellite parm;
 		feparm->getDVBS(parm);
-		SCAN_eDebug("try to add %d %d %d %d %d %d",
-			parm.orbital_position, parm.frequency, parm.symbol_rate, parm.polarisation, parm.fec, parm.modulation);
+		SCAN_eDebug("try to add %d %d %d %d %d %d %d",
+			parm.orbital_position, parm.frequency, parm.symbol_rate, parm.polarisation, parm.fec, parm.modulation, parm.is_id);
 		break;
 	}
 	case iDVBFrontend::feCable:
@@ -531,9 +531,9 @@ void eDVBScan::addChannelToScan(iDVBFrontendParameters *feparm)
 	{
 		eDVBFrontendParametersTerrestrial parm;
 		feparm->getDVBT(parm);
-		SCAN_eDebug("try to add %d %d %d %d %d %d %d %d",
+		SCAN_eDebug("try to add %d %d %d %d %d %d %d %d %d",
 			parm.frequency, parm.modulation, parm.transmission_mode, parm.hierarchy,
-			parm.guard_interval, parm.code_rate_LP, parm.code_rate_HP, parm.bandwidth);
+			parm.guard_interval, parm.code_rate_LP, parm.code_rate_HP, parm.bandwidth, parm.plp_id);
 		break;
 	}
 	}
@@ -727,7 +727,7 @@ void eDVBScan::channelDone()
 							{
 								T2 = true;
 								t2transponder.system = eDVBFrontendParametersTerrestrial::System_DVB_T2;
-								t2transponder.plpid = (int)d.getSelectorBytes()->at(0);
+								t2transponder.plp_id = (int)d.getSelectorBytes()->at(0);
 								t2transponder.code_rate_HP = t2transponder.code_rate_LP = eDVBFrontendParametersTerrestrial::FEC_Auto;
 								t2transponder.hierarchy = eDVBFrontendParametersTerrestrial::Hierarchy_Auto;
 								t2transponder.modulation = eDVBFrontendParametersTerrestrial::Modulation_Auto;
diff --git a/lib/dvb/volume.cpp b/lib/dvb/volume.cpp
index 8bbbcff..889ffd2 100644
--- a/lib/dvb/volume.cpp
+++ b/lib/dvb/volume.cpp
@@ -34,7 +34,9 @@ eDVBVolumecontrol::eDVBVolumecontrol()
 	openMixer();
 #endif
 	volumeUnMute();
+#if not defined(__sh__) // dont reset volume on start
 	setVolume(100, 100);
+#endif
 }
 
 int eDVBVolumecontrol::openMixer()
diff --git a/lib/dvb/volume.h b/lib/dvb/volume.h
index 7e4f364..3b95c6b 100644
--- a/lib/dvb/volume.h
+++ b/lib/dvb/volume.h
@@ -30,8 +30,8 @@ private:
 public:
 	static eDVBVolumecontrol* getInstance();
 
-	void volumeUp(int left = 5, int right = 5);
-	void volumeDown(int left = 5, int right = 5);
+	void volumeUp(int left = 2, int right = 2); //j00zek
+	void volumeDown(int left = 2, int right = 2); //j00zek
 
 	void setVolume(int left, int right);
 
diff --git a/lib/dvb_ci/dvbci.cpp b/lib/dvb_ci/dvbci.cpp
index daca87f..f19a60d 100644
--- a/lib/dvb_ci/dvbci.cpp
+++ b/lib/dvb_ci/dvbci.cpp
@@ -18,6 +18,11 @@
 
 #include <dvbsi++/ca_program_map_section.h>
 
+#ifdef __sh__
+#include <linux/dvb/ca.h>
+//#define x_debug
+#endif
+
 //#define CIDEBUG 1
 
 #ifdef CIDEBUG
@@ -28,6 +33,229 @@
 
 eDVBCIInterfaces *eDVBCIInterfaces::instance = 0;
 
+#ifdef __sh__
+bool eDVBCISlot::checkQueueSize()
+{
+	return (sendqueue.size() > 0);
+}
+
+/* from dvb-apps */
+int asn_1_decode(uint16_t * length, unsigned char * asn_1_array,
+		 uint32_t asn_1_array_len)
+{
+	uint8_t length_field;
+
+	if (asn_1_array_len < 1)
+		return -1;
+	length_field = asn_1_array[0];
+
+	if (length_field < 0x80) {
+		// there is only one word
+		*length = length_field & 0x7f;
+		return 1;
+	} else if (length_field == 0x81) {
+		if (asn_1_array_len < 2)
+			return -1;
+
+		*length = asn_1_array[1];
+		return 2;
+	} else if (length_field == 0x82) {
+		if (asn_1_array_len < 3)
+			return -1;
+
+		*length = (asn_1_array[1] << 8) | asn_1_array[2];
+		return 3;
+	}
+
+	return -1;
+}
+
+//send some data on an fd, for a special slot and connection_id
+eData eDVBCISlot::sendData(unsigned char* data, int len)
+{
+#ifdef x_debug
+	printf("%s: %p, %d\n", __func__, data, len);
+#endif
+
+	unsigned char *d = (unsigned char*) malloc(len + 5);
+
+	/* should we send a data last ? */
+	if (data != NULL)
+	{
+		if ((data[2] >= T_SB) && (data[2] <= T_NEW_T_C))
+		{
+			memcpy(d, data, len);
+		}
+		else
+		{
+			//send data_last and data
+			memcpy(d + 5, data, len);
+			d[0] = getSlotID();
+			d[1] = connection_id;
+			d[2] = T_DATA_LAST;
+			d[3] = len + 1; 		/* len */
+			d[4] = connection_id; 	/* transport connection identifier*/
+			len += 5;
+		}
+	}
+	else
+	{
+		//send a data last only
+		d[0] = getSlotID();
+		d[1] = connection_id;
+		d[2] = T_DATA_LAST;
+		d[3] = len + 1; 		/* len */
+		d[4] = connection_id; 	/* transport connection identifier*/
+		len = 5;
+	}
+
+#ifdef x_debug
+	printf("write (%d): > ", getSlotID());
+	for (int i=0; i < len; i++)
+		printf("%02x ",d[i]);
+	printf("\n");
+#endif
+
+#ifdef direct_write
+	res = write(fd, d, len);
+
+	free(d);
+	if (res < 0 || res != len)
+	{
+		printf("error writing data to fd %d, slot %d: %m\n", fd, getSlotID());
+		return eDataError;
+	}
+#else
+	sendqueue.push( queueData(d, len) );
+#endif
+	return eDataReady;
+}
+
+//send a transport connection create request
+bool eDVBCISlot::sendCreateTC()
+{
+	//printf("%s:%s >\n", FILENAME, __FUNCTION__);
+	unsigned char* data = (unsigned char*) malloc(sizeof(char) * 5);
+	tx_time.tv_sec = 0;
+	data[0] = getSlotID();
+	data[1] = getSlotID() + 1; 	/* conid */
+	data[2] = T_CREATE_T_C;
+	data[3] = 1;
+	data[4] = getSlotID() + 1 	/*conid*/;
+	write(fd, data, 5);
+	//printf("%s:%s <\n", FILENAME, __FUNCTION__);
+	return true;
+}
+
+void eDVBCISlot::process_tpdu(unsigned char tpdu_tag, __u8* data, int asn_data_length, int con_id)
+{
+	switch (tpdu_tag)
+	{
+		case T_C_T_C_REPLY:
+			printf("Got CTC Replay (slot %d, con %d)\n", getSlotID(), connection_id);
+
+			tx_time.tv_sec = 0;
+
+			state = stateInserted;
+
+			//answer with data last (and if we have with data)
+			sendData(NULL, 0);
+
+			break;
+		case T_DELETE_T_C:
+//FIXME: close sessions etc; reset ?
+//we must answer here with t_c_replay
+			printf("Got \"Delete Transport Connection\" from module ->currently not handled!\n");
+			break;
+		case T_D_T_C_REPLY:
+			printf("Got \"Delete Transport Connection Replay\" from module!\n");
+			break;
+		case T_REQUEST_T_C:
+			printf("Got \"Request Transport Connection\" from Module ->currently not handled!\n");
+			break;
+		case T_DATA_MORE:
+		{
+			int new_data_length = receivedLen + asn_data_length;
+			printf("Got \"Data More\" from Module\n");
+			__u8 *new_data_buffer = (__u8*) realloc(receivedData, new_data_length);
+			receivedData = new_data_buffer;
+			memcpy(receivedData + receivedLen, data, asn_data_length);
+			receivedLen = new_data_length;
+			tx_time.tv_sec = 0;
+			break;
+		}
+		case T_DATA_LAST:
+#ifdef x_debug
+			printf("Got \"Data Last\" from Module\n");
+#endif
+			tx_time.tv_sec = 0;
+			/* single package */
+			if (receivedData == NULL)
+			{
+				printf("->single package\n");
+#ifdef x_debug
+				printf("calling receiveData with data (len %d)> ", asn_data_length);
+				for (int i = 0;i < asn_data_length; i++)
+					printf("%02x ", data[i]);
+				printf("\n");
+#endif
+				eDVBCISession::receiveData(this, data, asn_data_length);
+				eDVBCISession::pollAll();
+			}
+			else
+			{
+				/* chained package */
+				int new_data_length = receivedLen + asn_data_length;
+				printf("->chained data\n");
+				__u8 *new_data_buffer = (__u8*) realloc(receivedData, new_data_length);
+				receivedData = new_data_buffer;
+				memcpy(receivedData + receivedLen, data, asn_data_length);
+				receivedLen = new_data_length;
+#ifdef x_debug
+				printf("calling receiveData with data (len %d)> ", asn_data_length);
+				for (int i = 0;i < receivedLen; i++)
+					printf("%02x ", receivedData[i]);
+				printf("\n");
+#endif
+				eDVBCISession::receiveData(this, receivedData, receivedLen);
+				eDVBCISession::pollAll();
+//fixme: must also be moved in e2 behind the data processing ;)
+				free(receivedData);
+				receivedData = NULL;
+				receivedLen = 0;
+			}
+			break;
+		case T_SB:
+		{
+#ifdef x_debug
+			printf("Got \"SB\" from Module\n");
+#endif
+			if (data[0] & 0x80)
+			{
+				printf("->data ready (%d)\n", getSlotID());
+				// send the RCV and ask for the data
+				unsigned char send_data[5];
+				send_data[0] = getSlotID();
+				send_data[1] = connection_id;
+				send_data[2] = T_RCV;
+				send_data[3] = 1;
+				send_data[4] = connection_id;
+				write(fd, send_data, 5);
+				gettimeofday(&tx_time, 0);
+			}
+			else
+			{
+				tx_time.tv_sec = 0;
+			}
+			break;
+		}
+		default:
+			printf("unhandled tpdu_tag 0x%0x\n", tpdu_tag);
+	}
+}
+
+#endif
+
 eDVBCIInterfaces::eDVBCIInterfaces()
 {
 	int num_ci = 0;
@@ -39,7 +267,11 @@ eDVBCIInterfaces::eDVBCIInterfaces()
 	while (1)
 	{
 		char filename[128];
+#ifdef __sh__
+		sprintf(filename, "/dev/dvb/adapter0/ci%d", num_ci);
+#else
 		sprintf(filename, "/dev/ci%d", num_ci);
+#endif
 
 		if (::access(filename, R_OK) < 0) break;
 
@@ -954,8 +1186,13 @@ int eDVBCISlot::send(const unsigned char *data, size_t len)
 	{
 		unsigned char *d = new unsigned char[len];
 		memcpy(d, data, len);
+#ifdef __sh__
+		sendData(d, len);
+		notifier->setRequested(eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
+#else
 		sendqueue.push( queueData(d, len) );
 		notifier->setRequested(eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
+#endif
 	}
 
 	return res;
@@ -964,6 +1201,7 @@ int eDVBCISlot::send(const unsigned char *data, size_t len)
 void eDVBCISlot::data(int what)
 {
 	eDebugCI("CISlot %d what %d\n", getSlotID(), what);
+#ifndef __sh__
 	if(what == eSocketNotifier::Priority) {
 		if(state != stateRemoved) {
 			state = stateRemoved;
@@ -1019,6 +1257,166 @@ void eDVBCISlot::data(int what)
 		else
 			notifier->setRequested(eSocketNotifier::Read|eSocketNotifier::Priority);
 	}
+#else
+	unsigned char data[1024];
+	int len = 1024;
+	unsigned char* d;
+	eData status;
+	ca_slot_info_t info;
+
+	if (what & eSocketNotifier::Read)
+	{
+		eDebugCI("eSocketNotifier::Read\n");
+		status = eDataReady;
+		len = ::read(fd, data, len);
+	}
+	else if (what & eSocketNotifier::Write)
+	{
+		eDebugCI("eSocketNotifier::Write\n");
+		status = eDataWrite;
+	}
+	else if (what & eSocketNotifier::Priority)
+	{
+		eDebugCI("eSocketNotifier::Priority\n");
+		status = eDataStatusChanged;
+	}
+
+	switch (getState())
+	{
+		case stateInvalid:
+		{
+			if (status == eDataStatusChanged)
+			{
+				info.num = getSlotID();
+
+				if (ioctl(fd, CA_GET_SLOT_INFO, &info) < 0)
+					printf("IOCTL CA_GET_SLOT_INFO failed for slot %d\n", getSlotID());
+
+				if (info.flags & CA_CI_MODULE_READY)
+				{
+					printf("1. cam status changed ->cam now present\n");
+					state = stateInserted;
+					mmi_active = false;
+					tx_time.tv_sec = 0;
+					application_manager = 0;
+					ca_manager = 0;
+					sendCreateTC();
+					eDVBCI_UI::getInstance()->setState(getSlotID(),1);
+				}
+			}
+			else
+			{
+				usleep(100000);
+			}
+		}
+		break;
+		case stateInserted:
+		{
+			if (status == eDataReady)
+			{
+				eDebugCI("received data - len %d\n", len);
+				//int s_id = data[0];
+				//int c_id = data[1];
+				//printf("%d: s_id = %d, c_id = %d\n", slot->slot, s_id, c_id);
+				d = data;
+				/* taken from the dvb-apps */
+				int data_length = len - 2;
+				d += 2; /* remove leading slot and connection id */
+				while (data_length > 0)
+				{
+					unsigned char tpdu_tag = d[0];
+					unsigned short asn_data_length;
+					int length_field_len;
+					if ((length_field_len = asn_1_decode(&asn_data_length, d + 1, data_length - 1)) < 0)
+					{
+						printf("Received data with invalid asn from module on slot %02x\n", getSlotID());
+						break;
+					}
+
+					if ((asn_data_length < 1) || (asn_data_length > (data_length - (1 + length_field_len))))
+					{
+						printf("Received data with invalid length from module on slot %02x\n", getSlotID());
+						break;
+					}
+					connection_id = d[1 + length_field_len];
+					//printf("Setting connection_id from received data to %d\n", slot->connection_id);
+					d += 1 + length_field_len + 1;
+					data_length -= (1 + length_field_len + 1);
+					asn_data_length--;
+					process_tpdu(tpdu_tag, d, asn_data_length, connection_id);
+					// skip over the consumed data
+					d += asn_data_length;
+					data_length -= asn_data_length;
+				} // while (data_length)
+			} /* data ready */
+			else if (status == eDataWrite)
+			{
+				if (!sendqueue.empty() && (tx_time.tv_sec == 0)) 
+				{
+					const queueData &qe = sendqueue.top();
+					int res = write(fd, qe.data, qe.len);
+					if (res >= 0 && (unsigned int)res == qe.len)
+					{
+						delete [] qe.data;
+						sendqueue.pop();
+						gettimeofday(&tx_time, 0);
+					}
+					else
+					{
+						printf("r = %d, %m\n", res);
+					}
+				}
+				/* the spec say's that we _must_ poll the connection
+				 * if the transport connection is in active state
+				 */
+				if ((tx_time.tv_sec == 0) && (!checkQueueSize()) && (time_after(last_poll_time, 1000)))
+				{
+					sendData(NULL, 0);
+					clock_gettime(CLOCK_MONOTONIC, &last_poll_time);
+				}
+			}
+			else if (status == eDataStatusChanged)
+			{
+				info.num = getSlotID();
+				if (ioctl(fd, CA_GET_SLOT_INFO, &info) < 0)
+					printf("IOCTL CA_GET_SLOT_INFO failed for slot %d\n", getSlotID());
+
+				if (info.flags & CA_CI_MODULE_READY)
+				{
+					printf("2. cam status changed ->cam now present\n");
+					mmi_active = false;
+					state = stateInvalid;
+					application_manager = 0;
+					ca_manager = 0;
+					tx_time.tv_sec = 0;
+					eDVBCI_UI::getInstance()->setState(getSlotID(),1); 
+				}
+				else if (!(info.flags & CA_CI_MODULE_READY))
+				{
+					printf("cam status changed ->cam now _not_ present\n");
+					eDVBCISession::deleteSessions(this);
+					mmi_active = false;
+					state = stateInvalid;
+					application_manager = 0;
+					ca_manager = 0;
+					tx_time.tv_sec = 0;
+					eDVBCIInterfaces::getInstance()->ciRemoved(this);
+					eDVBCI_UI::getInstance()->setState(getSlotID(),0);
+					while (sendqueue.size())
+					{
+						delete [] sendqueue.top().data;
+						sendqueue.pop();
+					}
+				}
+			}
+		}
+		break;
+		default:
+			printf("unknown state %d\n", state);
+		break;
+	}
+	notifier->setRequested(eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
+#endif
 }
 
 DEFINE_REF(eDVBCISlot);
@@ -1037,7 +1435,11 @@ eDVBCISlot::eDVBCISlot(eMainloop *context, int nr)
 
 	slotid = nr;
 
+#ifdef __sh__
+	sprintf(filename, "/dev/dvb/adapter0/ci%d", nr);
+#else
 	sprintf(filename, "/dev/ci%d", nr);
+#endif
 
 //	possible_caids.insert(0x1702);
 //	possible_providers.insert(providerPair("PREMIERE", 0xC00000));
@@ -1048,10 +1450,24 @@ eDVBCISlot::eDVBCISlot(eMainloop *context, int nr)
 	eDebugCI("CI Slot %d has fd %d", getSlotID(), fd);
 	state = stateInvalid;
 
+#ifdef __sh__
+	receivedLen = 0;
+	receivedData = NULL;
+#endif
 	if (fd >= 0)
 	{
+#ifdef __sh__
+		connection_id = slotid + 1;
+		tx_time.tv_sec = 0;
+		tx_time.tv_usec = 0;
+		last_poll_time.tv_sec = 0;
+		last_poll_time.tv_nsec = 0;
+#endif
 		notifier = eSocketNotifier::create(context, fd, eSocketNotifier::Read | eSocketNotifier::Priority | eSocketNotifier::Write);
 		CONNECT(notifier->activated, eDVBCISlot::data);
+#ifdef __sh__
+		reset();
+#endif
 	} else
 	{
 		perror(filename);
@@ -1087,6 +1503,13 @@ int eDVBCISlot::reset()
 {
 	eDebug("CI Slot %d: reset requested", getSlotID());
 
+#ifdef __sh__
+	state = stateInvalid;
+	mmi_active = false;
+	eDVBCI_UI::getInstance()->setAppName(getSlotID(), "");
+	eDVBCISession::deleteSessions(this);
+	eDVBCIInterfaces::getInstance()->ciRemoved(this);
+#else
 	if (state == stateInvalid)
 	{
 		unsigned char buf[256];
@@ -1094,6 +1517,7 @@ int eDVBCISlot::reset()
 		while(::read(fd, buf, 256)>0);
 		state = stateResetted;
 	}
+#endif
 
 	while(sendqueue.size())
 	{
@@ -1101,7 +1525,12 @@ int eDVBCISlot::reset()
 		sendqueue.pop();
 	}
 
+#ifdef __sh__
+	if (ioctl(fd, CA_RESET, getSlotID()) < 0)
+		eDebug("IOCTL CA_RESET failed for slot %d\n", slotid);
+#else
 	ioctl(fd, 0);
+#endif
 
 	return 0;
 }
diff --git a/lib/dvb_ci/dvbci.h b/lib/dvb_ci/dvbci.h
index 8431e95..be6e6eb 100644
--- a/lib/dvb_ci/dvbci.h
+++ b/lib/dvb_ci/dvbci.h
@@ -5,6 +5,9 @@
 
 #include <lib/base/ebase.h>
 #include <lib/service/iservice.h>
+#ifdef __sh__
+#include <lib/base/thread.h>
+#endif
 #include <lib/python/python.h>
 #include <set>
 #include <queue>
@@ -43,6 +46,42 @@ typedef std::set<providerPair> providerSet;
 typedef std::set<uint16_t> caidSet;
 typedef std::set<eServiceReference> serviceSet;
 
+#ifdef __sh__
+/* ********************************** */
+/* constants taken from dvb-apps 
+ */
+#define T_SB                0x80	// sb                           primitive   h<--m
+#define T_RCV               0x81	// receive                      primitive   h-->m
+#define T_CREATE_T_C        0x82	// create transport connection  primitive   h-->m
+#define T_C_T_C_REPLY       0x83	// ctc reply                    primitive   h<--m
+#define T_DELETE_T_C        0x84	// delete tc                    primitive   h<->m
+#define T_D_T_C_REPLY       0x85	// dtc reply                    primitive   h<->m
+#define T_REQUEST_T_C       0x86	// request transport connection primitive   h<--m
+#define T_NEW_T_C           0x87	// new tc / reply to t_request  primitive   h-->m
+#define T_T_C_ERROR         0x77	// error creating tc            primitive   h-->m
+#define T_DATA_LAST         0xA0	// convey data from higher      constructed h<->m
+				 // layers
+#define T_DATA_MORE         0xA1	// convey data from higher      constructed h<->m
+				 // layers
+
+typedef enum {eDataTimeout, eDataError, eDataReady, eDataWrite, eDataStatusChanged} eData;
+
+static inline int time_after(struct timespec oldtime, uint32_t delta_ms)
+{
+	// calculate the oldtime + add on the delta
+	uint64_t oldtime_ms = (oldtime.tv_sec * 1000) + (oldtime.tv_nsec / 1000000);
+	oldtime_ms += delta_ms;
+
+	// calculate the nowtime
+	struct timespec nowtime;
+	clock_gettime(CLOCK_MONOTONIC, &nowtime);
+	uint64_t nowtime_ms = (nowtime.tv_sec * 1000) + (nowtime.tv_nsec / 1000000);
+
+	// check
+	return nowtime_ms > oldtime_ms;
+}
+#endif
+
 class eDVBCISlot: public iObject, public Object
 {
 	friend class eDVBCIInterfaces;
@@ -66,6 +105,13 @@ class eDVBCISlot: public iObject, public Object
 	bool user_mapped;
 	void data(int);
 	bool plugged;
+#ifdef __sh__
+	//dagobert
+	char connection_id;
+	bool mmi_active;
+	int receivedLen;
+	unsigned char* receivedData;
+#endif
 public:
 	enum {stateRemoved, stateInserted, stateInvalid, stateResetted};
 	eDVBCISlot(eMainloop *context, int nr);
@@ -95,6 +141,17 @@ public:
 	int getNumOfServices() { return running_services.size(); }
 	int setSource(data_source source);
 	int setClockRate(int);
+#ifdef __sh__
+	bool checkQueueSize();
+	void thread();
+	void mmiOpened() { mmi_active = true; };
+	void mmiClosed() { mmi_active = false; };
+	void process_tpdu(unsigned char tpdu_tag, __u8* data, int asn_data_length, int con_id);
+	bool sendCreateTC();
+	eData sendData(unsigned char* data, int len);
+	struct timeval tx_time;
+	struct timespec last_poll_time;
+#endif
 };
 
 struct CIPmtHandler
diff --git a/lib/dvb_ci/dvbci_appmgr.cpp b/lib/dvb_ci/dvbci_appmgr.cpp
index b3e9ca1..86b43d1 100644
--- a/lib/dvb_ci/dvbci_appmgr.cpp
+++ b/lib/dvb_ci/dvbci_appmgr.cpp
@@ -94,6 +94,9 @@ int eDVBCIApplicationManagerSession::startMMI()
 	eDebug("in appmanager -> startmmi()");
 	const unsigned char tag[3]={0x9F, 0x80, 0x22};  // Tenter_menu
 	sendAPDU(tag);
+#ifdef __sh__
+	slot->mmiOpened();
+#endif
 	return 0;
 }
 
diff --git a/lib/dvb_ci/dvbci_mmi.cpp b/lib/dvb_ci/dvbci_mmi.cpp
index 64006e6..c4c5760 100644
--- a/lib/dvb_ci/dvbci_mmi.cpp
+++ b/lib/dvb_ci/dvbci_mmi.cpp
@@ -25,6 +25,9 @@ eDVBCIMMISession::eDVBCIMMISession(eDVBCISlot *tslot)
 
 eDVBCIMMISession::~eDVBCIMMISession()
 {
+#ifdef __sh__
+	slot->mmiClosed();
+#endif
 	slot->setMMIManager(NULL);
 	eDVBCI_UI::getInstance()->mmiSessionDestroyed(slot->getSlotID());
 }
diff --git a/lib/dvb_ci/dvbci_resmgr.cpp b/lib/dvb_ci/dvbci_resmgr.cpp
index 5590f22..9ed584f 100644
--- a/lib/dvb_ci/dvbci_resmgr.cpp
+++ b/lib/dvb_ci/dvbci_resmgr.cpp
@@ -5,7 +5,12 @@
 
 int eDVBCIResourceManagerSession::receivedAPDU(const unsigned char *tag,const void *data, int len)
 {
+#ifdef __sh__
+	eDebug("eDVBCIResourceManagerSession::%s >", __func__);
+	eDebugNoNewLine("SESSION(%d) %02x %02x %02x (len = %d): ", session_nb, tag[0], tag[1], tag[2], len);
+#else
 	eDebugNoNewLine("SESSION(%d) %02x %02x %02x: ", session_nb, tag[0], tag[1], tag[2]);
+#endif
 	for (int i=0; i<len; i++)
 		eDebugNoNewLine("%02x ", ((const unsigned char*)data)[i]);
 	eDebug("");
diff --git a/lib/dvb_ci/dvbci_session.cpp b/lib/dvb_ci/dvbci_session.cpp
index 3cbd2ec..7fb6ebf 100644
--- a/lib/dvb_ci/dvbci_session.cpp
+++ b/lib/dvb_ci/dvbci_session.cpp
@@ -257,6 +257,12 @@ void eDVBCISession::receiveData(eDVBCISlot *slot, const unsigned char *ptr, size
 		if ((!session_nb) || (session_nb >= SLMS))
 		{
 			eDebug("PROTOCOL: illegal session number %x", session_nb);
+#ifdef __sh__
+			//Dagobert during start-up we seems to have some problems
+			//on some modules which "looses" the connection. So reset it
+			deleteSessions(slot);
+			slot->reset();
+#endif
 			return;
 		}
 
diff --git a/lib/gdi/Makefile.inc b/lib/gdi/Makefile.inc
index c23f05d..af1d6e0 100644
--- a/lib/gdi/Makefile.inc
+++ b/lib/gdi/Makefile.inc
@@ -19,7 +19,8 @@ gdi_libenigma_gdi_a_SOURCES = \
 	gdi/lcd.cpp \
 	gdi/picexif.cpp \
 	gdi/picload.cpp \
-	gdi/region.cpp
+	gdi/region.cpp \
+	gdi/stmfb.cpp
 
 gdiincludedir = $(pkgincludedir)/lib/gdi
 gdiinclude_HEADERS = \
diff --git a/lib/gdi/accel.cpp b/lib/gdi/accel.cpp
index 6908f5e..f7ba136 100644
--- a/lib/gdi/accel.cpp
+++ b/lib/gdi/accel.cpp
@@ -15,8 +15,25 @@
 // #define ACCEL_DEBUG
 
 gAccel *gAccel::instance;
+#if not defined(__sh__)
 #define BCM_ACCEL
+#else
+#define STMFB_ACCEL
+#endif
 
+#ifdef STMFB_ACCEL
+extern int stmfb_accel_init(void);
+extern void stmfb_accel_close(void);
+extern void stmfb_accel_blit(
+		int src_addr, int src_width, int src_height, int src_stride, int src_format,
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int src_x, int src_y, int width, int height,
+		int dst_x, int dst_y, int dwidth, int dheight);
+extern void stmfb_accel_fill(
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int x, int y, int width, int height,
+		unsigned long color);
+#endif
 #ifdef ATI_ACCEL
 extern int ati_accel_init(void);
 extern void ati_accel_close(void);
@@ -53,6 +70,9 @@ gAccel::gAccel():
 {
 	instance = this;
 
+#ifdef STMFB_ACCEL
+	stmfb_accel_init();
+#endif
 #ifdef ATI_ACCEL
 	ati_accel_init();
 #endif
@@ -63,6 +83,9 @@ gAccel::gAccel():
 
 gAccel::~gAccel()
 {
+#ifdef STMFB_ACCEL
+	stmfb_accel_close();
+#endif
 #ifdef ATI_ACCEL
 	ati_accel_close();
 #endif
@@ -146,6 +169,69 @@ bool gAccel::hasAlphaBlendingSupport()
 
 int gAccel::blit(gUnmanagedSurface *dst, gUnmanagedSurface *src, const eRect &p, const eRect &area, int flags)
 {
+#ifdef STMFB_ACCEL
+	int src_format = 0;
+	gUnmanagedSurface *surfaceTmp = new gUnmanagedSurface(area.width(), area.height(), dst->bpp);
+
+	if (src->bpp == 32)
+		src_format = 0;
+	else if ((src->bpp == 8) && (dst->bpp == 32))
+	{
+		src_format = 1;
+		if (accelAlloc(surfaceTmp))
+			return -1;
+
+		__u8 *srcptr=(__u8*)src->data;
+		__u8 *dstptr=(__u8*)surfaceTmp->data;
+		__u32 pal[256];
+
+		for (int i=0; i<256; ++i)
+		{
+			if (src->clut.data && (i<src->clut.colors))
+				pal[i]=(src->clut.data[i].a<<24)|(src->clut.data[i].r<<16)|(src->clut.data[i].g<<8)|(src->clut.data[i].b);
+			else
+				pal[i]=0x010101*i;
+			if ((pal[i]&0xFF000000) >= 0xE0000000)
+				pal[i] = 0xFF000000;
+			pal[i]^=0xFF000000;
+		}
+		srcptr+=area.left()*src->bypp+area.top()*src->stride;
+
+		for (int y=0; y<area.height(); y++)
+		{
+			int width=area.width();
+			unsigned char *psrc=(unsigned char*)srcptr;
+			__u32 *pdst=(__u32*)dstptr;
+
+			while (width--)
+				*pdst++=pal[*psrc++];
+
+			srcptr+=src->stride;
+			dstptr+=area.width() * 4;
+		}
+	} else {
+		if (surfaceTmp->data_phys)
+			accelFree(surfaceTmp);
+		return -1;
+	}
+
+	if (surfaceTmp->data_phys)
+	{
+		stmfb_accel_blit(
+			surfaceTmp->data_phys, 0, 0, area.width() * 4, src_format,
+			dst->data_phys, dst->x, dst->y, dst->stride,
+			0, 0, area.width(), area.height(),
+			p.x(), p.y(), p.width(), p.height());
+		accelFree(surfaceTmp);
+	} else {
+		stmfb_accel_blit(
+			src->data_phys, src->x, src->y, src->stride, src_format,
+			dst->data_phys, dst->x, dst->y, dst->stride,
+			area.left(), area.top(), area.width(), area.height(),
+			p.x(), p.y(), p.width(), p.height());
+	}
+	return 0;
+#endif
 #ifdef ATI_ACCEL
 	ati_accel_blit(
 		src->data_phys, src->x, src->y, src->stride,
@@ -274,9 +360,9 @@ int gAccel::accelAlloc(gUnmanagedSurface* surface)
 
 void gAccel::accelFree(gUnmanagedSurface* surface)
 {
-	int phys_addr = surface->data_phys;
-	if (phys_addr != 0)
+	if(surface != 0 && surface->data_phys != 0)
 	{
+		int phys_addr = surface->data_phys;
 #ifdef ACCEL_DEBUG
 		eDebug("[%s] %p->%x %dx%d:%d", __func__, surface, surface->data_phys, surface->x, surface->y, surface->bpp);
 #endif
diff --git a/lib/gdi/fb.cpp b/lib/gdi/fb.cpp
index 1caf520..e54a124 100644
--- a/lib/gdi/fb.cpp
+++ b/lib/gdi/fb.cpp
@@ -47,11 +47,13 @@ fbClass::fbClass(const char *fb)
 	}
 
 
+#if not defined(__sh__)
 	if (ioctl(fbFd, FBIOGET_VSCREENINFO, &screeninfo)<0)
 	{
 		perror("FBIOGET_VSCREENINFO");
 		goto nolfb;
 	}
+#endif
 
 	fb_fix_screeninfo fix;
 	if (ioctl(fbFd, FBIOGET_FSCREENINFO, &fix)<0)
@@ -62,8 +64,17 @@ fbClass::fbClass(const char *fb)
 
 	available=fix.smem_len;
 	m_phys_mem = fix.smem_start;
+#if defined(__sh__)
+	eDebug("%dk total video mem", available/1024);
+	// The first 1920x1080x4 bytes are reserved
+	// After that we can take 1280x720x4 bytes for our virtual framebuffer
+	available -= 1920*1080*4;
+	eDebug("%dk usable video mem", available/1024);
+	lfb=(unsigned char*)mmap(0, available, PROT_WRITE|PROT_READ, MAP_SHARED, fbFd, 1920*1080*4);
+#else
 	eDebug("%dk video mem", available/1024);
 	lfb=(unsigned char*)mmap(0, available, PROT_WRITE|PROT_READ, MAP_SHARED, fbFd, 0);
+#endif
 	if (!lfb)
 	{
 		perror("mmap");
@@ -86,6 +97,7 @@ nolfb:
 
 int fbClass::showConsole(int state)
 {
+#if not defined(__sh__)
 	int fd=open("/dev/tty0", O_RDWR);
 	if(fd>=0)
 	{
@@ -95,11 +107,19 @@ int fbClass::showConsole(int state)
 		}
 		close(fd);
 	}
+#endif
 	return 0;
 }
 
 int fbClass::SetMode(int nxRes, int nyRes, int nbpp)
 {
+#if defined(__sh__)
+	xRes=nxRes;
+	yRes=nyRes;
+	bpp=32;
+	m_number_of_pages = 1;
+	topDiff=bottomDiff=leftDiff=rightDiff = 0;
+#else
 	screeninfo.xres_virtual=screeninfo.xres=nxRes;
 	screeninfo.yres_virtual=(screeninfo.yres=nyRes)*2;
 	screeninfo.height=0;
@@ -149,8 +169,14 @@ int fbClass::SetMode(int nxRes, int nyRes, int nbpp)
 
 	m_number_of_pages = screeninfo.yres_virtual / nyRes;
 
+#endif
 	ioctl(fbFd, FBIOGET_VSCREENINFO, &screeninfo);
 
+#if defined(__sh__)
+	xResSc=screeninfo.xres;
+	yResSc=screeninfo.yres;
+	stride=xRes*4;
+#else
 	if ((screeninfo.xres!=nxRes) && (screeninfo.yres!=nyRes) && (screeninfo.bits_per_pixel!=nbpp))
 	{
 		eDebug("SetMode failed: wanted: %dx%dx%d, got %dx%dx%d",
@@ -168,15 +194,22 @@ int fbClass::SetMode(int nxRes, int nyRes, int nbpp)
 	}
 	stride=fix.line_length;
 	memset(lfb, 0, stride*yRes);
+#endif
 	blit();
 	return 0;
 }
 
 void fbClass::getMode(int &xres, int &yres, int &bpp)
 {
+#if defined(__sh__)
+	xres = xRes;
+	yres = yRes;
+	bpp = 32;
+#else
 	xres = screeninfo.xres;
 	yres = screeninfo.yres;
 	bpp = screeninfo.bits_per_pixel;
+#endif
 }
 
 int fbClass::setOffset(int off)
@@ -194,10 +227,93 @@ int fbClass::waitVSync()
 
 void fbClass::blit()
 {
+#if defined(__sh__)
+	int modefd=open("/proc/stb/video/3d_mode", O_RDWR);
+	char buf[16] = "off";
+	if (modefd > 0)
+	{
+		read(modefd, buf, 15);
+		buf[15]='\0';
+		close(modefd);
+	}
+
+	STMFBIO_BLT_DATA    bltData;
+	memset(&bltData, 0, sizeof(STMFBIO_BLT_DATA));
+	bltData.operation  = BLT_OP_COPY;
+	bltData.srcOffset  = 1920*1080*4;
+	bltData.srcPitch   = xRes * 4;
+	bltData.dstOffset  = 0;
+	bltData.dstPitch   = xResSc*4;
+	bltData.src_top    = 0;
+	bltData.src_left   = 0;
+	bltData.src_right  = xRes;
+	bltData.src_bottom = yRes;
+	bltData.srcFormat  = SURF_BGRA8888;
+	bltData.dstFormat  = SURF_BGRA8888;
+	bltData.srcMemBase = STMFBGP_FRAMEBUFFER;
+	bltData.dstMemBase = STMFBGP_FRAMEBUFFER;
+
+	if (strncmp(buf,"sbs",3)==0)
+	{
+		bltData.dst_top    = 0 + topDiff;
+		bltData.dst_left   = 0 + leftDiff/2;
+		bltData.dst_right  = xResSc/2 + rightDiff/2;
+		bltData.dst_bottom = yResSc + bottomDiff;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData ) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+		bltData.dst_top    = 0 + topDiff;
+		bltData.dst_left   = xResSc/2 + leftDiff/2;
+		bltData.dst_right  = xResSc + rightDiff/2;
+		bltData.dst_bottom = yResSc + bottomDiff;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData ) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+	}
+	else if (strncmp(buf,"tab",3)==0)
+	{
+		bltData.dst_top    = 0 + topDiff/2;
+		bltData.dst_left   = 0 + leftDiff;
+		bltData.dst_right  = xResSc + rightDiff;
+		bltData.dst_bottom = yResSc/2 + bottomDiff/2;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData ) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+		bltData.dst_top    = yResSc/2 + topDiff/2;
+		bltData.dst_left   = 0 + leftDiff;
+		bltData.dst_right  = xResSc + rightDiff;
+		bltData.dst_bottom = yResSc + bottomDiff/2;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData ) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+	}
+	else
+	{
+		bltData.dst_top    = 0 + topDiff;
+		bltData.dst_left   = 0 + leftDiff;
+		bltData.dst_right  = xResSc + rightDiff;
+		bltData.dst_bottom = yResSc + bottomDiff;
+		if (ioctl(fbFd, STMFBIO_BLT, &bltData ) < 0)
+		{
+			perror("STMFBIO_BLT");
+		}
+	
+	}
+
+	if (ioctl(fbFd, STMFBIO_SYNC_BLITTER) < 0)
+	{
+		perror("STMFBIO_SYNC_BLITTER");
+	}
+#else
 	if (m_manual_blit == 1) {
 		if (ioctl(fbFd, FBIO_BLIT) < 0)
 			perror("FBIO_BLIT");
 	}
+#endif
 }
 
 fbClass::~fbClass()
@@ -232,6 +348,25 @@ int fbClass::lock()
 	}
 	else
 		locked = 1;
+#if defined(__sh__)
+	outcfg.outputid = STMFBIO_OUTPUTID_MAIN;
+	if (ioctl( fbFd, STMFBIO_GET_OUTPUT_CONFIG, &outcfg ) < 0)
+		perror("STMFBIO_GET_OUTPUT_CONFIG\n");
+
+	outinfo.outputid = STMFBIO_OUTPUTID_MAIN;
+	if (ioctl( fbFd, STMFBIO_GET_OUTPUTINFO, &outinfo ) < 0)
+		perror("STMFBIO_GET_OUTPUTINFO\n");
+
+	//if (ioctl( fbFd, STMFBIO_GET_VAR_SCREENINFO_EX, &infoex ) < 0)
+	//	printf("ERROR\n");
+
+	planemode.layerid = 0;
+	if (ioctl( fbFd, STMFBIO_GET_PLANEMODE, &planemode ) < 0)
+		perror("STMFBIO_GET_PLANEMODE\n");
+
+	if (ioctl( fbFd, STMFBIO_GET_VAR_SCREENINFO_EX, &infoex ) < 0)
+		perror("STMFBIO_GET_VAR_SCREENINFO_EX\n");
+#endif
 	return fbFd;
 }
 
@@ -242,25 +377,86 @@ void fbClass::unlock()
 	if (locked == 2)  // re-enable manualBlit
 		enableManualBlit();
 	locked=0;
+#if defined(__sh__)
+	if (ioctl( fbFd, STMFBIO_SET_VAR_SCREENINFO_EX, &infoex ) < 0)
+		perror("STMFBIO_SET_VAR_SCREENINFO_EX\n");
+
+	if (ioctl( fbFd, STMFBIO_SET_PLANEMODE, &planemode ) < 0)
+		perror("STMFBIO_SET_PLANEMODE\n");
+
+	if (ioctl( fbFd, STMFBIO_SET_VAR_SCREENINFO_EX, &infoex ) < 0)
+		perror("STMFBIO_SET_VAR_SCREENINFO_EX\n");
+
+	if (ioctl( fbFd, STMFBIO_SET_OUTPUTINFO, &outinfo ) < 0)
+		perror("STMFBIO_SET_OUTPUTINFO\n");
+
+	if (ioctl( fbFd, STMFBIO_SET_OUTPUT_CONFIG, &outcfg ) < 0)
+		perror("STMFBIO_SET_OUTPUT_CONFIG\n");
+
+	memset(lfb, 0, stride*yRes);
+#endif
 	SetMode(xRes, yRes, bpp);
 	PutCMAP();
 }
 
 void fbClass::enableManualBlit()
 {
+#if not defined(__sh__)
 	unsigned char tmp = 1;
 	if (ioctl(fbFd,FBIO_SET_MANUAL_BLIT, &tmp)<0)
 		perror("FBIO_SET_MANUAL_BLIT");
 	else
 		m_manual_blit = 1;
+#endif
 }
 
 void fbClass::disableManualBlit()
 {
+#if not defined(__sh__)
 	unsigned char tmp = 0;
 	if (ioctl(fbFd,FBIO_SET_MANUAL_BLIT, &tmp)<0)
 		perror("FBIO_SET_MANUAL_BLIT");
 	else
 		m_manual_blit = 0;
+#endif
+}
+
+#if defined(__sh__)
+void fbClass::clearFBblit()
+{
+	//set real frambuffer transparent
+//	memset(lfb, 0x00, xRes * yRes * 4);
+	blit();
+}
+
+int fbClass::getFBdiff(int ret)
+{
+	if(ret == 0)
+		return topDiff;
+	else if(ret == 1)
+		return leftDiff;
+	else if(ret == 2)
+		return rightDiff;
+	else if(ret == 3)
+		return bottomDiff;
+	else
+		return -1;
 }
 
+void fbClass::setFBdiff(int top, int left, int right, int bottom)
+{
+	if(top < 0) top = 0;
+	if(top > yRes) top = yRes;
+	topDiff = top;
+	if(left < 0) left = 0;
+	if(left > xRes) left = xRes;
+	leftDiff = left;
+	if(right > 0) right = 0;
+	if(-right > xRes) right = -xRes;
+	rightDiff = right;
+	if(bottom > 0) bottom = 0;
+	if(-bottom > yRes) bottom = -yRes;
+	bottomDiff = bottom;
+}
+#endif
+
diff --git a/lib/gdi/fb.h b/lib/gdi/fb.h
index 42dd37b..4f082a7 100644
--- a/lib/gdi/fb.h
+++ b/lib/gdi/fb.h
@@ -3,11 +3,23 @@
 
 #include <lib/base/eerror.h>
 #include <linux/fb.h>
+#if defined(__sh__)
+	#include <linux/stmfb.h>
+#endif
 
 class fbClass
 {
 	int fbFd;
 	int xRes, yRes, stride, bpp;
+#if defined(__sh__)
+	struct stmfbio_output_configuration outcfg;
+	struct stmfbio_outputinfo outinfo;
+	struct stmfbio_planeinfo planemode;
+	struct stmfbio_var_screeninfo_ex infoex;
+
+	int xResSc, yResSc;
+	int topDiff, leftDiff, rightDiff, bottomDiff;
+#endif
 	int available;
 	struct fb_var_screeninfo screeninfo;
 	fb_cmap cmap;
@@ -49,6 +61,18 @@ public:
 	int PutCMAP();
 #endif
 	static fbClass *getInstance();
+#ifdef ENABLE_LIBEPLAYER3
+//	"hack" for libeplayer3 fb access
+	int getFD() { return fbFd; }
+	unsigned char * getLFB_Direct() { return lfb; }
+	int getScreenResX() { return xRes; }
+	int getScreenResY() { return yRes; }
+#endif
+#if defined(__sh__)
+	void clearFBblit();
+	int getFBdiff(int ret);
+	void setFBdiff(int top, int right, int left, int bottom);
+#endif
 
 	int lock();
 	void unlock();
diff --git a/lib/gdi/gfbdc.cpp b/lib/gdi/gfbdc.cpp
index 5a46bcd..ec059c7 100644
--- a/lib/gdi/gfbdc.cpp
+++ b/lib/gdi/gfbdc.cpp
@@ -25,8 +25,8 @@ gFBDC::gFBDC()
 		|| (xres == 1920 && yres == 1080)))
 	{
 		/* fallback to a decent default */
-		xres = 720;
-		yres = 576;
+		xres = 1280; //j00zek lets make HD our default for openPLI
+		yres = 720;
 	}
 
 	surface.clut.data = 0;
@@ -177,14 +177,35 @@ void gFBDC::setGamma(int g)
 
 void gFBDC::setResolution(int xres, int yres, int bpp)
 {
+#if defined(__sh__)
+	/* if xres and yres are negative call SetMode with the lates xres and yres
+	 * we need that to read the new screen dimesnions after a resolution change
+	 * without changing the frambuffer dimensions
+	 */
+	int m_xres;
+	int m_yres;
+	int m_bpp;
+	fb->getMode(m_xres, m_yres, m_bpp);
+
+	if (xres<0 && yres<0 ) {
+		fb->SetMode(m_xres, m_yres, bpp);
+		return;
+	}
+#else
 	if (m_pixmap && (surface.x == xres) && (surface.y == yres) && (surface.bpp == bpp))
 		return;
+#endif
 
 	if (gAccel::getInstance())
 		gAccel::getInstance()->releaseAccelMemorySpace();
 
 	fb->SetMode(xres, yres, bpp);
 
+#if defined(__sh__)
+	for (int y = 0; y<yres; y++) { // make whole screen transparent
+		memset(fb->lfb+y*fb->Stride(), 0x00, fb->Stride());
+	}
+#endif
 	surface.x = xres;
 	surface.y = yres;
 	surface.bpp = bpp;
diff --git a/lib/gdi/glcddc.cpp b/lib/gdi/glcddc.cpp
index 45bccfb..82ca7ce 100644
--- a/lib/gdi/glcddc.cpp
+++ b/lib/gdi/glcddc.cpp
@@ -5,6 +5,21 @@
 
 gLCDDC *gLCDDC::instance;
 
+#ifdef HAVE_GRAPHLCD
+static inline int time_after(struct timespec oldtime, uint32_t delta_ms)
+{
+	// calculate the oldtime + add on the delta
+	uint64_t oldtime_ms = (oldtime.tv_sec * 1000) + (oldtime.tv_nsec / 1000000);
+	oldtime_ms += delta_ms;
+	// calculate the nowtime
+	struct timespec nowtime;
+	clock_gettime(CLOCK_MONOTONIC, &nowtime);
+	uint64_t nowtime_ms = (nowtime.tv_sec * 1000) + (nowtime.tv_nsec / 1000000);
+	// check
+	return nowtime_ms > oldtime_ms;
+}
+#endif
+
 gLCDDC::gLCDDC()
 {
 	lcd = new eDBoxLCD();
@@ -23,11 +38,18 @@ gLCDDC::gLCDDC()
 	eDebug("LCD resolution: %d x %d x %d (stride: %d)", surface.x, surface.y, surface.bpp, surface.stride);
 
 	m_pixmap = new gPixmap(&surface);
+#ifdef HAVE_GRAPHLCD
+	clock_gettime(CLOCK_MONOTONIC, &last_update);
+#endif
 }
 
 gLCDDC::~gLCDDC()
 {
+#ifndef HAVE_GRAPHLCD
+//konfetti: not sure why, but calling the destructor if external lcd (pearl) is selected
+//e2 crashes. this is also true if the destructor does not contain any code !!!
 	delete lcd;
+#endif
 	instance = 0;
 }
 
@@ -46,8 +68,16 @@ void gLCDDC::exec(const gOpcode *o)
 		break;
 #endif
 	case gOpcode::flush:
+#ifdef HAVE_GRAPHLCD
+		if (update)
+		{
+			lcd->update();
+			clock_gettime(CLOCK_MONOTONIC, &last_update);
+		}
+#else
 //		if (update)
 			lcd->update();
+#endif
 	default:
 		gDC::exec(o);
 		break;
diff --git a/lib/gdi/glcddc.h b/lib/gdi/glcddc.h
index 474d09e..36c0391 100644
--- a/lib/gdi/glcddc.h
+++ b/lib/gdi/glcddc.h
@@ -10,6 +10,9 @@ class gLCDDC: public gDC
 	static gLCDDC *instance;
 	int update;
 	void exec(const gOpcode *opcode);
+#ifdef HAVE_GRAPHLCD
+	struct timespec last_update;
+#endif
 	gUnmanagedSurface surface;
 public:
 	gLCDDC();
diff --git a/lib/gdi/gpixmap.cpp b/lib/gdi/gpixmap.cpp
index 6d5f55d..076ed07 100644
--- a/lib/gdi/gpixmap.cpp
+++ b/lib/gdi/gpixmap.cpp
@@ -152,11 +152,13 @@ gSurface::~gSurface()
 	if (data)
 	{
 		delete [] (unsigned char*)data;
+		data = 0;
 		removed_pixmap(y * stride);
 	}
 	if (clut.data)
 	{
 		delete [] clut.data;
+		clut.data = 0;
 	}
 }
 
@@ -200,6 +202,9 @@ void gPixmap::fill(const gRegion &region, const gColor &color)
 			if (surface->clut.data && color < surface->clut.colors)
 				col = surface->clut.data[color].argb();
 			else
+#if defined(__sh__)
+if ((col&0xFF000000) == 0xFF000000) col = 0xFF000000;
+#endif
 				col = 0x10101 * color;
 
 			col^=0xFF000000;
@@ -234,6 +239,9 @@ void gPixmap::fill(const gRegion &region, const gRGB &color)
 			uint32_t col;
 
 			col = color.argb();
+#if defined(__sh__)
+if ((col&0xFF000000) == 0xFF000000) col = 0xFF000000;
+#endif
 			col^=0xFF000000;
 
 #ifdef GPIXMAP_DEBUG
@@ -441,7 +449,8 @@ void gPixmap::blit(const gPixmap &src, const eRect &_pos, const gRegion &clip, i
 		Stopwatch s;
 #endif
 		if (accel) {
-			if (!gAccel::getInstance()->blit(surface, src.surface, area, srcarea, flag)) {
+			if (!(src.surface->bpp==8 && surface->bpp==32) && 
+					(!gAccel::getInstance()->blit(surface, src.surface, area, srcarea, flag))) {
 #ifdef GPIXMAP_DEBUG
 				s.stop();
 				eDebug("[BLITBENCH] accel blit took %u us", s.elapsed_us());
@@ -807,6 +816,7 @@ void gPixmap::mergePalette(const gPixmap &target)
 	}
 
 	delete [] lookup;
+	lookup = 0;
 }
 
 static inline int sgn(int a)
diff --git a/lib/gdi/lcd.cpp b/lib/gdi/lcd.cpp
index 57dd0f8..fc10dee 100644
--- a/lib/gdi/lcd.cpp
+++ b/lib/gdi/lcd.cpp
@@ -60,6 +60,7 @@ void eLCD::renderText(ePoint start, const char *text)
 }
 #endif
 
+#ifndef HAVE_GRAPHLCD
 eDBoxLCD::eDBoxLCD()
 {
 	int xres=132, yres=64, bpp=8;
@@ -301,3 +302,141 @@ void eDBoxLCD::update()
 	}
 #endif
 }
+
+#else
+
+void eDBoxLCD::setFlipped(bool onoff)
+{
+	flipped = onoff;
+	update();
+}
+
+/* **************************************************************** */
+/* Pearl LCD */
+
+eDBoxLCD::eDBoxLCD()
+{
+	eDebug("eDBoxLCD::eDBoxLCD >");
+
+	displayNumber = 0;
+	is_oled = 1;
+
+	instance=this;
+
+	if (GLCD::Config.Load("/etc/graphlcd.conf") == false)
+	{
+		eDebug("Error loading config file!\n");
+		return;
+	}
+	if (GLCD::Config.driverConfigs.size() <= 0)
+	{
+		eDebug("ERROR: No displays specified in config file!\n");
+	}
+
+	GLCD::Config.driverConfigs[displayNumber].upsideDown ^= 0;
+	GLCD::Config.driverConfigs[displayNumber].invert ^= 0;
+
+	lcd = GLCD::CreateDriver(GLCD::Config.driverConfigs[displayNumber].id, &GLCD::Config.driverConfigs[displayNumber]);
+
+	if (!lcd)
+	{
+		eDebug("ERROR: Failed creating display object\n");
+		return;
+	}
+	if (lcd->Init() != 0)
+	{
+#if 0
+	// Returning an error here will break the code at various other places
+		eDebug("ERROR: Failed initializing display\n");
+		delete lcd;
+		lcd = NULL;
+		return;
+#endif
+	}
+	lcd->SetBrightness(GLCD::Config.driverConfigs[displayNumber].brightness);
+
+	lcd->GetFeature((std::string) "depth", depth);
+	width = GLCD::Config.driverConfigs[displayNumber].width;
+	height = GLCD::Config.driverConfigs[displayNumber].height;
+
+	eDebug("config -> (w %d, h %d)", width, height);
+
+	bitmap = new GLCD::cBitmap(width, height);
+	bitmap->Clear();
+
+	lcd->SetScreen(bitmap->Data(), bitmap->Width(), bitmap->Height());
+	lcd->Refresh(true);
+
+	lcdfd = 1; //needed for detected()
+	setSize(width, height, depth);
+
+	eDebug("eDBoxLCD::eDBoxLCD (w %d, h %d, depth %d)<", width, height, depth);
+}
+
+void eDBoxLCD::setInverted(unsigned char inv)
+{
+	eDebug("eDBoxLCD::setInverted");
+	inverted = inv;
+	update();
+}
+
+int eDBoxLCD::setLCDContrast(int contrast)
+{
+	eDebug("[LCD] setLCDContrast not supported");
+	return(0);
+}
+
+int eDBoxLCD::setLCDBrightness(int brightness)
+{
+	eDebug("eDBoxLCD::setLCDBrightness");
+/* fixme range check */
+	lcd->SetBrightness(brightness);
+	return(0);
+}
+
+eDBoxLCD::~eDBoxLCD()
+{
+	eDebug("eDBoxLCD::~eDBoxLCD");
+}
+
+eDBoxLCD *eDBoxLCD::getInstance()
+{
+	eDebug("eDBoxLCD::getInstance");
+	return instance;
+}
+
+void eDBoxLCD::update()
+{
+	if (lcdfd == 1)
+	{
+		bitmap->Clear();
+		for (int x = 0; x < width; x++)
+			for (int y = 0; y < height; y++)
+			{
+				__u16 *buf16  = (__u16*) _buffer;
+#if BYTE_ORDER == LITTLE_ENDIAN
+				__u16 col16 = bswap_16(*((__u16*)(((__u16*)buf16) + y * width + x)));
+#else
+				__u16 col16 = *((__u16*)(((__u16*)buf16) + y * width + x));
+#endif
+				__u8 red, green, blue, alpha; 
+				__u32 color32;
+
+				/* BBBBB GGGGGG RRRRR */
+				blue  = ((col16 & 0xF800) >> 11) * ( 255 / 31);
+				green = ((col16 & 0x7E0) >> 5) * (255 / 63);
+				red   = (col16 & 0x1f) * (255 / 31);
+				alpha = 255;
+
+				color32 = alpha << 24 | red << 16 | green << 8 | blue;
+
+				if (inverted)
+					color32 = 0xFFFFFF - color32;
+
+				bitmap->DrawPixel(x, y, color32);
+			}
+		lcd->SetScreen(bitmap->Data(), bitmap->Width(), bitmap->Height());
+		lcd->Refresh(false); /* partial update */
+	}
+}
+#endif
diff --git a/lib/gdi/lcd.h b/lib/gdi/lcd.h
index 6044939..7d46847 100644
--- a/lib/gdi/lcd.h
+++ b/lib/gdi/lcd.h
@@ -5,6 +5,17 @@
 #include <lib/gdi/esize.h>
 #include <lib/gdi/erect.h>
 
+#ifdef HAVE_GRAPHLCD
+#include <glcdgraphics/bitmap.h>
+#include <glcdgraphics/glcd.h>
+#include <glcdgraphics/image.h>
+#include <glcddrivers/config.h>
+#include <glcddrivers/driver.h>
+#include <glcddrivers/drivers.h>
+#include <glcdgraphics/extformats.h>
+#include <byteswap.h>
+#endif
+
 #define LCD_CONTRAST_MIN 0
 #define LCD_CONTRAST_MAX 63
 #define LCD_BRIGHTNESS_MIN 0
@@ -48,6 +59,13 @@ class eDBoxLCD: public eLCD
 	unsigned char inverted;
 	bool flipped;
 	int is_oled;
+#ifdef HAVE_GRAPHLCD
+	GLCD::cDriver * lcd;
+	GLCD::cBitmap * bitmap;
+	int displayNumber;
+	int depth;
+	int width, height;
+#endif
 #ifdef SWIG
 	eDBoxLCD();
 	~eDBoxLCD();
diff --git a/lib/gdi/picload.cpp b/lib/gdi/picload.cpp
index cb1d02b..d92394d 100644
--- a/lib/gdi/picload.cpp
+++ b/lib/gdi/picload.cpp
@@ -519,7 +519,7 @@ inline void m_rend_gif_decodecolormap(unsigned char *cmb, unsigned char *rgbb, C
 static void gif_load(Cfilepara* filepara)
 {
 	unsigned char *pic_buffer = NULL;
-	int px, py, i, j;
+	int px, py, i, j, ErrorCode;
 	unsigned char *fbptr;
 	unsigned char *slb=NULL;
 	GifFileType *gft;
@@ -529,7 +529,7 @@ static void gif_load(Cfilepara* filepara)
 	int cmaps;
 	int extcode;
 
-	gft = DGifOpenFileName(filepara->file);
+	gft = DGifOpenFileName(filepara->file, &ErrorCode);
 	if (gft == NULL)
 		return;
 	do
@@ -600,11 +600,11 @@ static void gif_load(Cfilepara* filepara)
 	}
 	while (rt != TERMINATE_RECORD_TYPE);
 
-	DGifCloseFile(gft);
+	DGifCloseFile(gft, &ErrorCode);
 	return;
 ERROR_R:
 	eDebug("[Picload] <Error gif>");
-	DGifCloseFile(gft);
+	DGifCloseFile(gft, &ErrorCode);
 }
 
 //---------------------------------------------------------------------------------------------
diff --git a/lib/gdi/stmfb.cpp b/lib/gdi/stmfb.cpp
new file mode 100644
index 0000000..dce3a05
--- /dev/null
+++ b/lib/gdi/stmfb.cpp
@@ -0,0 +1,75 @@
+/*
+  Interface to the Dreambox dm800/dm8000 proprietary accel interface.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <linux/fb.h>
+#include <sys/mman.h>
+#include <sys/ioctl.h>
+#include <linux/stmfb.h>
+
+
+#include <lib/base/ebase.h>
+
+static int fb_fd;
+static int exec_list(void);
+
+int stmfb_accel_init(void)
+{
+	fb_fd = open("/dev/fb0", O_RDWR);
+	if (fb_fd < 0)
+	{
+		perror("/dev/fb0");
+		return 1;
+	}
+	eDebug("STMFB accel interface available\n");
+	return 0;
+}
+
+void stmfb_accel_close(void)
+{
+	close(fb_fd);
+}
+
+void stmfb_accel_blit(
+		int src_addr, int src_width, int src_height, int src_stride, int src_format,
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int src_x, int src_y, int width, int height,
+		int dst_x, int dst_y, int dwidth, int dheight)
+{
+	STMFBIO_BLT_DATA bltData;
+	memset(&bltData, 0, sizeof(STMFBIO_BLT_DATA));
+
+	bltData.operation  = BLT_OP_COPY;
+	bltData.srcOffset  = (src_addr - dst_addr) + (1920*1080*4);
+	bltData.srcPitch   = src_stride;
+	bltData.src_left   = src_x;
+	bltData.src_top    = src_y;
+	bltData.src_right  = src_x + width;
+	bltData.src_bottom = src_y + height;
+	bltData.srcFormat  = SURF_BGRA8888;
+
+	bltData.dstOffset  = 1920*1080*4;
+	bltData.dstPitch   = dst_stride;
+	bltData.dst_left   = dst_x;
+	bltData.dst_top    = dst_y;
+	bltData.dst_right  = dst_x + dwidth;
+	bltData.dst_bottom = dst_y + dheight;
+	bltData.dstFormat  = SURF_BGRA8888;
+
+	if (ioctl(fb_fd, STMFBIO_BLT, &bltData ) < 0)
+	{
+		eDebug("Error ioctl FBIO_BLIT");
+	}
+}
+
+void stmfb_accel_fill(
+		int dst_addr, int dst_width, int dst_height, int dst_stride,
+		int x, int y, int width, int height,
+		unsigned long color)
+{
+//	printf("unimplemented bcm_accel_fill\n");
+}
diff --git a/lib/python/Components/Converter/RemainingToText.py b/lib/python/Components/Converter/RemainingToText.py
index f2aa5a5..d715ae9 100644
--- a/lib/python/Components/Converter/RemainingToText.py
+++ b/lib/python/Components/Converter/RemainingToText.py
@@ -8,6 +8,9 @@ class RemainingToText(Converter, object):
 	IN_SECONDS = 3
 	PROGRESS = 4
 	WITH_SECONDSPROGRESS = 5
+#+++>
+	FOLLOW = 6
+#+++<
 
 	def __init__(self, type):
 		Converter.__init__(self, type)
@@ -21,6 +24,10 @@ class RemainingToText(Converter, object):
 			self.type = self.PROGRESS
 		elif type == "WithSecondsProgress":
 			self.type = self.WITH_SECONDSPROGRESS
+#+++>
+		elif type == "FOLLOW":
+			self.type = self.FOLLOW
+#+++<
 		else:
 			self.type = self.DEFAULT
 
@@ -52,6 +59,13 @@ class RemainingToText(Converter, object):
 					return "%s%d:%02d" % (prefix, hours, minutes)
 				elif self.type == self.IN_SECONDS:
 					return prefix+str(tsecs)
+#+++>
+		elif self.type == self.FOLLOW:
+			if remaining is not None:
+				return "in %d min" % (remaining / 60)
+			else:
+				return "%d min" % (duration / 60)
+#+++<
 				elif self.type == self.DEFAULT:
 					if remaining <= duration:
 						prefix = "+"
diff --git a/lib/python/Components/Harddisk.py b/lib/python/Components/Harddisk.py
index 9a40a06..d08ff1e 100644
--- a/lib/python/Components/Harddisk.py
+++ b/lib/python/Components/Harddisk.py
@@ -71,21 +71,11 @@ class Harddisk:
 			self.dev_path = '/dev/' + self.device
 			self.disk_path = self.dev_path
 
+#+++>
 		elif self.type == DEVTYPE_DEVFS:
-			tmp = readFile(self.sysfsPath('dev')).split(':')
-			s_major = int(tmp[0])
-			s_minor = int(tmp[1])
-			for disc in os.listdir("/dev/discs"):
-				dev_path = os.path.realpath('/dev/discs/' + disc)
-				disk_path = dev_path + '/disc'
-				try:
-					rdev = os.stat(disk_path).st_rdev
-				except OSError:
-					continue
-				if s_major == os.major(rdev) and s_minor == os.minor(rdev):
-					self.dev_path = dev_path
-					self.disk_path = disk_path
-					break
+			self.dev_path = '/dev/' + self.device
+			self.disk_path = self.dev_path
+#+++<
 
 		print "new Harddisk", self.device, '->', self.dev_path, '->', self.disk_path
 		if not removable:
@@ -683,6 +673,12 @@ class HarddiskManager:
 		for item in getProcMounts():
 			if item[0] == dev:
 				return item[1]
+#+++>
+		#Check if has autofs mountpoint
+		mount = self.getAutofsMountpoint(device)
+		if mount:
+			return mount
+#+++<
 		return None
 
 	def addHotplugPartition(self, device, physdev = None):
@@ -698,6 +694,10 @@ class HarddiskManager:
 		error, blacklisted, removable, is_cdrom, partitions, medium_found = self.getBlockDevInfo(device)
 		if not blacklisted and medium_found:
 			description = self.getUserfriendlyDeviceName(device, physdev)
+#+++>
+			if description.startswith("External Storage"):
+				return False, False, False, False, [], False
+#+++<
 			p = Partition(mountpoint = self.getMountpoint(device), description = description, force_mounted = True, device = device)
 			self.partitions.append(p)
 			if p.mountpoint: # Plugins won't expect unmounted devices
diff --git a/lib/python/Components/NimManager.py b/lib/python/Components/NimManager.py
index 8658eb7..9d8eeaf 100644
--- a/lib/python/Components/NimManager.py
+++ b/lib/python/Components/NimManager.py
@@ -20,6 +20,10 @@ from Tools import Directories
 import xml.etree.cElementTree
 
 def getConfigSatlist(orbpos, satlist):
+#+++>  CAUSE OF CRASH!
+	if not satlist:
+		return None
+#+++<
 	default_orbpos = None
 	for x in satlist:
 		if x[0] == orbpos:
@@ -511,7 +515,7 @@ class SecConfigure:
 		self.update()
 
 class NIM(object):
-	def __init__(self, slot, type, description, has_outputs = True, internally_connectable = None, multi_type = {}, frontend_id = None, i2c = None, is_empty = False):
+	def __init__(self, slot, type, description, has_outputs = True, internally_connectable = None, multi_type = {}, frontend_id = None, i2c = None, is_empty = False, multistream = False):
 		self.slot = slot
 
 		if type not in ("DVB-S", "DVB-C", "DVB-T", "DVB-S2", "DVB-T2", "DVB-C2", "ATSC", None):
@@ -521,6 +525,7 @@ class NIM(object):
 		self.type = type
 		self.description = description
 		self.has_outputs = has_outputs
+		self.multistream = multistream
 		self.internally_connectable = internally_connectable
 		self.multi_type = multi_type
 		self.i2c = i2c
@@ -609,6 +614,9 @@ class NIM(object):
 	def isEmpty(self):
 		return self.__is_empty
 
+	def hasMultistream(self):
+		return self.multistream
+
 	# empty tuners are supported!
 	def isSupported(self):
 		return (self.frontend_id is not None) or self.__is_empty
@@ -773,6 +781,9 @@ class NimManager:
 					modes = entries[current_slot].get("multi_type", {})
 					modes[split2[1]] = split[1].strip()
 					entries[current_slot]["multi_type"] = modes
+			elif line.startswith("Multistream:"):
+				input = str(line[len("Multistream:") + 1:])
+				entries[current_slot]["multistream"] = (input == "yes")
 			elif line.startswith("I2C_Device:"):
 				input = int(line[len("I2C_Device:") + 1:])
 				entries[current_slot]["i2c"] = input
@@ -792,6 +803,8 @@ class NimManager:
 				entry["i2c"] = None
 			if not (entry.has_key("has_outputs")):
 				entry["has_outputs"] = True
+			if not (entry.has_key("multistream")):
+				entry["multistream"] = False
 			if entry.has_key("frontend_device"): # check if internally connectable
 				if path.exists("/proc/stb/frontend/%d/rf_switch" % entry["frontend_device"]):
 					entry["internally_connectable"] = entry["frontend_device"] - 1
@@ -801,7 +814,7 @@ class NimManager:
 				entry["frontend_device"] = entry["internally_connectable"] = None
 			if not (entry.has_key("multi_type")):
 				entry["multi_type"] = {}
-			self.nim_slots.append(NIM(slot = id, description = entry["name"], type = entry["type"], has_outputs = entry["has_outputs"], internally_connectable = entry["internally_connectable"], multi_type = entry["multi_type"], frontend_id = entry["frontend_device"], i2c = entry["i2c"], is_empty = entry["isempty"]))
+			self.nim_slots.append(NIM(slot = id, description = entry["name"], type = entry["type"], has_outputs = entry["has_outputs"], internally_connectable = entry["internally_connectable"], multi_type = entry["multi_type"], frontend_id = entry["frontend_device"], i2c = entry["i2c"], is_empty = entry["isempty"], multistream = entry["multistream"]))
 
 	def hasNimType(self, chktype):
 		for slot in self.nim_slots:
diff --git a/lib/python/Components/Renderer/Progress.py b/lib/python/Components/Renderer/Progress.py
index a5968aa..c29cd23 100644
--- a/lib/python/Components/Renderer/Progress.py
+++ b/lib/python/Components/Renderer/Progress.py
@@ -13,23 +13,39 @@ class Progress(VariableValue, Renderer):
 	GUI_WIDGET = eSlider
 
 	def changed(self, what):
-		if what[0] == self.CHANGED_CLEAR:
-			(self.range, self.value) = ((0, 1), 0)
-			return
-
-		range = self.source.range or 100
-		value = self.source.value
-		if value is None:
-			value = 0
-		(self.range, self.value) = ((0, range), value)
+#+++>
+		try:
+			if what[0] == self.CHANGED_CLEAR:
+				(self.range, self.value) = ((0, 1), 0)
+				return
+
+			range = (self.source and self.source.range) or 100
+			value = (self.source and self.source.value) or 0
+			if value is None:
+				value = 0
+			(self.range, self.value) = ((0, range), value)
+		except:
+			None
+#+++<
+ 
 
 	def postWidgetCreate(self, instance):
-		instance.setRange(self.__start, self.__end)
+#+++>
+		try:
+			instance.setRange(self.__start, self.__end)
+		except:
+			None
+#+++<
 
 	def setRange(self, range):
-		(self.__start, self.__end) = range
-		if self.instance is not None:
-			self.instance.setRange(self.__start, self.__end)
+#+++>
+		try:
+			(self.__start, self.__end) = range
+			if self.instance is not None:
+				self.instance.setRange(self.__start, self.__end)
+		except:
+			None
+#+++<
 
 	def getRange(self):
 		return (self.__start, self.__end)
diff --git a/lib/python/Components/UsageConfig.py b/lib/python/Components/UsageConfig.py
index 2dd4dee..2f29099 100644
--- a/lib/python/Components/UsageConfig.py
+++ b/lib/python/Components/UsageConfig.py
@@ -197,7 +197,7 @@ def InitUsageConfig():
 	config.usage.recording_frontend_priority = ConfigSelection(default = "-2", choices = nims)
 	config.misc.disable_background_scan = ConfigYesNo(default = False)
 
-	config.usage.show_event_progress_in_servicelist = ConfigSelection(default = 'barright', choices = [
+	config.usage.show_event_progress_in_servicelist = ConfigSelection(default = 'barleft', choices = [
 		('barleft', _("Progress bar left")),
 		('barright', _("Progress bar right")),
 		('percleft', _("Percentage left")),
diff --git a/lib/python/Components/VolumeControl.py b/lib/python/Components/VolumeControl.py
index e28a7cd..dc43560 100644
--- a/lib/python/Components/VolumeControl.py
+++ b/lib/python/Components/VolumeControl.py
@@ -72,12 +72,24 @@ class VolumeControl:
 
 	def volMute(self, showMuteSymbol=True, force=False):
 		vol = self.volctrl.getVolume()
+#+++>
+		if config.audio.volume.value != 0:
+			vol = config.audio.volume.value
+		else:
+			vol = self.volctrl.getVolume()
+#+++<
 		if vol or force:
 			self.volctrl.volumeToggleMute()
 			if self.volctrl.isMuted():
 				if showMuteSymbol:
 					self.muteDialog.show()
 				self.volumeDialog.setValue(0)
+#+++>
+				self.volctrl.setVolume(0,0)
+#+++<
 			else:
 				self.muteDialog.hide()
 				self.volumeDialog.setValue(vol)
+#+++>
+				self.volctrl.setVolume(vol, vol)
+#+++<
diff --git a/lib/python/Makefile.inc b/lib/python/Makefile.inc
index 510c6d4..0cd7b71 100644
--- a/lib/python/Makefile.inc
+++ b/lib/python/Makefile.inc
@@ -32,7 +32,7 @@ EXTRA_DIST += \
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/python/enigma_python.Pcpp@am__quote@
 
 .i.cpp:
-	$(AM_V_GEN)$(SWIG) $(AX_SWIG_PYTHON_OPT) -MT $@ -MD -MF $(DEPDIR)/$*.Tpo -I$(top_srcdir) -O -nortti -nothreads -o $@ $<
+	$(AM_V_GEN)$(SWIG) $(AX_SWIG_PYTHON_OPT) -MT $@ -MD -MF $(DEPDIR)/$*.Tpo -I$(top_srcdir) -D__sh__ -O -nortti -nothreads -o $@ $<
 	$(AM_V_at)mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Pcpp
 	$(AM_V_at)$(PYTHON) $(srcdir)/python/enigma_py_patcher.py python/enigma.py
 
diff --git a/lib/python/Plugins/Extensions/Makefile.am b/lib/python/Plugins/Extensions/Makefile.am
index da3513b..eaff670 100755
--- a/lib/python/Plugins/Extensions/Makefile.am
+++ b/lib/python/Plugins/Extensions/Makefile.am
@@ -1,7 +1,6 @@
 installdir = $(pkglibdir)/python/Plugins/Extensions
 
-SUBDIRS = TuxboxPlugins CutListEditor PicturePlayer MediaScanner MediaPlayer GraphMultiEPG SocketMMI
-# SUBDIRS += DVDBurn
+SUBDIRS = CutListEditor PicturePlayer MediaScanner MediaPlayer GraphMultiEPG SocketMMI DVDBurn
 
 if HAVE_LIBDDVD
 SUBDIRS += DVDPlayer
diff --git a/lib/python/Plugins/SystemPlugins/HdmiCEC/plugin.py b/lib/python/Plugins/SystemPlugins/HdmiCEC/plugin.py
index e5996cb..a4ffb0a 100644
--- a/lib/python/Plugins/SystemPlugins/HdmiCEC/plugin.py
+++ b/lib/python/Plugins/SystemPlugins/HdmiCEC/plugin.py
@@ -111,7 +111,7 @@ def startSetup(menuid):
 
 def Plugins(**kwargs):
 	from os import path
-	if path.exists("/dev/hdmi_cec") or path.exists("/dev/misc/hdmi_cec0"):
+	if path.exists("/dev/hdmi_cec") or path.exists("/lib/modules/cec.ko"):
 		import Components.HdmiCec
 		from Plugins.Plugin import PluginDescriptor
 		return [PluginDescriptor(where = PluginDescriptor.WHERE_MENU, fnc = startSetup)]
diff --git a/lib/python/Plugins/SystemPlugins/Hotplug/plugin.py b/lib/python/Plugins/SystemPlugins/Hotplug/plugin.py
index 97ba058..2019910 100644
--- a/lib/python/Plugins/SystemPlugins/Hotplug/plugin.py
+++ b/lib/python/Plugins/SystemPlugins/Hotplug/plugin.py
@@ -9,6 +9,8 @@ def processHotplugData(self, v):
 	action = v.get("ACTION")
 	device = v.get("DEVPATH")
 	physdevpath = v.get("PHYSDEVPATH")
+	if physdevpath == "-":
+		physdevpath = None
 	media_state = v.get("X_E2_MEDIA_STATUS")
 
 	dev = device.split('/')[-1]
diff --git a/lib/python/Plugins/SystemPlugins/Makefile.am b/lib/python/Plugins/SystemPlugins/Makefile.am
index 888a480..3b70593 100755
--- a/lib/python/Plugins/SystemPlugins/Makefile.am
+++ b/lib/python/Plugins/SystemPlugins/Makefile.am
@@ -2,9 +2,9 @@ installdir = $(pkglibdir)/python/Plugins/SystemPlugins
 
 SUBDIRS = SoftwareManager PositionerSetup Satfinder \
 	SkinSelector SatelliteEquipmentControl Videomode VideoTune Hotplug \
-	DefaultServicesScanner DiseqcTester CommonInterfaceAssignment \
+	DefaultServicesScanner DiseqcTester \
 	CableScan FastScan OSDPositionSetup OSD3DSetup HdmiCEC VideoClippingSetup \
-	VideoEnhancement WirelessLan NetworkWizard
+	VideoEnhancement WirelessLan NetworkWizard VFD-Icons
 
 if HAVE_TEMPFANCONTROL
 SUBDIRS += TempFanControl
diff --git a/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE b/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE
new file mode 100644
index 0000000..4f7ec17
--- /dev/null
+++ b/lib/python/Plugins/SystemPlugins/VFD-Icons/LICENSE
@@ -0,0 +1,9 @@
+This plugin is licensed under the Creative Commons 
+Attribution-NonCommercial-ShareAlike 3.0 Unported 
+License. To view a copy of this license, visit
+http://creativecommons.org/licenses/by-nc-sa/3.0/ or send a letter to Creative
+Commons, 559 Nathan Abbott Way, Stanford, California 94305, USA.
+
+This plugin is NOT free software. It is open source, you are allowed to
+modify it (if you keep the license), but it may not be commercially 
+distributed other than under the conditions noted above.
diff --git a/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am b/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am
new file mode 100644
index 0000000..0a34954
--- /dev/null
+++ b/lib/python/Plugins/SystemPlugins/VFD-Icons/Makefile.am
@@ -0,0 +1,9 @@
+installdir = $(pkglibdir)/python/Plugins/SystemPlugins/VFD-Icons
+
+SUBDIRS = meta
+
+install_PYTHON = \
+	__init__.py \
+	plugin.py
+
+dist_install_DATA = LICENSE
diff --git a/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py b/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py
new file mode 100644
index 0000000..139597f
--- /dev/null
+++ b/lib/python/Plugins/SystemPlugins/VFD-Icons/__init__.py
@@ -0,0 +1,2 @@
+
+
diff --git a/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am b/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am
new file mode 100644
index 0000000..0a1bb5a
--- /dev/null
+++ b/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/Makefile.am
@@ -0,0 +1,3 @@
+installdir = $(datadir)/meta
+
+dist_install_DATA = plugin_vfd-icons.xml
diff --git a/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml b/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml
new file mode 100644
index 0000000..ae71463
--- /dev/null
+++ b/lib/python/Plugins/SystemPlugins/VFD-Icons/meta/plugin_vfd-icons.xml
@@ -0,0 +1,20 @@
+<default>
+	<prerequisites>
+		<hardware type="dm8000" />
+		<tag type="System" />
+	</prerequisites>
+	<info>
+		<author>Team Ducktales</author>
+		<name>VFD-Icons</name>
+		<packagename>enigma2-plugin-systemplugins-vfd-icons</packagename>
+		<packagetype>public</packagetype> <!-- internal/public , public is default, internal metas are not displayed inside plugin manager -->
+		<shortdescription>Displays text on vfd</shortdescription>
+		<description>Displays text on vfd.
+		</description>
+	</info>
+
+	<files type="package"> <!-- without version, without .ipk -->
+		<file type="package" name="enigma2-plugin-systemplugins-vfd-icons" />
+	</files>
+
+</default>
diff --git a/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py b/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py
new file mode 100644
index 0000000..1edcf32
--- /dev/null
+++ b/lib/python/Plugins/SystemPlugins/VFD-Icons/plugin.py
@@ -0,0 +1,152 @@
+# -*- coding: utf-8 -*-
+from Plugins.Plugin import PluginDescriptor
+import ServiceReference
+from enigma import iPlayableService, eTimer, eServiceCenter, iServiceInformation
+from enigma import evfd
+import time
+from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
+
+class VFDIcons:
+	def __init__(self, session):
+		# Save Session&Servicelist, Create Timer, Init Services
+		self.session = session
+		self.service = None
+		self.onClose = [ ]
+		self.__event_tracker = ServiceEventTracker(screen=self,eventmap=
+			{
+				iPlayableService.evUpdatedInfo: self.__evUpdatedInfo,
+				iPlayableService.evUpdatedEventInfo: self.__evUpdatedEventInfo,
+				iPlayableService.evVideoSizeChanged: self.__evVideoSizeChanged,
+				iPlayableService.evSeekableStatusChanged: self.__evSeekableStatusChanged,
+				iPlayableService.evStart: self.__evStart,
+			})
+		session.nav.record_event.append(self.gotRecordEvent)
+		self.mp3Available = False
+		self.dolbyAvailable = False
+		
+	def __evStart(self):
+		print "[__evStart]"
+		self.__evSeekableStatusChanged()
+
+	def __evUpdatedInfo(self):
+		print "[__evUpdatedInfo]"
+		self.checkAudioTracks()
+		self.writeChannelName()
+		self.showCrypted()
+		self.showDolby()
+		self.showMp3()
+
+	def writeChannelName(self):
+		print "[writeChannelName]"
+		servicename = ""
+		currPlay = self.session.nav.getCurrentService()
+		if currPlay != None and self.mp3Available:
+			# show the MP3 tag
+			servicename = currPlay.info().getInfoString(iServiceInformation.sTagTitle)
+		else:
+			# show the service name
+			self.service = self.session.nav.getCurrentlyPlayingServiceReference()
+			if not self.service is None:
+				service = self.service.toCompareString()
+				servicename = ServiceReference.ServiceReference(service).getServiceName().replace('\xc2\x87', '').replace('\xc2\x86', '').ljust(16)
+				subservice = self.service.toString().split("::")
+				if subservice[0].count(':') == 9:
+					servicename = subservice[1].replace('\xc2\x87', '').replace('\xc3\x9f', 'ss').replace('\xc2\x86', '').ljust(16)
+				else:
+					servicename=servicename
+			else:
+				print "no Service found"
+
+		print "vfd display text:", servicename[0:63]
+		evfd.getInstance().vfd_write_string(servicename[0:63])
+		return 1
+
+	def showCrypted(self):
+		print "[showCrypted]"
+		service=self.session.nav.getCurrentService()
+		if service is not None:
+			info=service.info()
+			crypted = info and info.getInfo(iServiceInformation.sIsCrypted) or -1
+			if crypted == 1 : #set crypt symbol
+				evfd.getInstance().vfd_set_icon(0x13,1)
+			else:
+				evfd.getInstance().vfd_set_icon(0x13,0)
+
+	def checkAudioTracks(self):
+		self.dolbyAvailable = False
+		self.mp3Available = False
+		service=self.session.nav.getCurrentService()
+		if service is not None:
+			audio = service.audioTracks()
+			if audio:
+				n = audio.getNumberOfTracks()
+				for x in range(n):
+					i = audio.getTrackInfo(x)
+					description = i.getDescription();
+					if description.find("MP3") != -1:
+						self.mp3Available = True
+					if description.find("AC3") != -1 or description.find("DTS") != -1:
+						self.dolbyAvailable = True
+
+	def showDolby(self):
+		print "[showDolby]"
+		if self.dolbyAvailable:
+			evfd.getInstance().vfd_set_icon(0x17,1)
+		else:
+			evfd.getInstance().vfd_set_icon(0x17,0)
+
+	def showMp3(self):
+		print "[showMp3]"
+		if self.mp3Available:
+			evfd.getInstance().vfd_set_icon(0x15,1)
+		else:
+			evfd.getInstance().vfd_set_icon(0x15,0)
+
+	def __evUpdatedEventInfo(self):
+		print "[__evUpdatedEventInfo]"
+
+	def getSeekState(self):
+		service = self.session.nav.getCurrentService()
+		if service is None:
+			return False
+		seek = service.seek()
+		if seek is None:
+			return False
+		return seek.isCurrentlySeekable()
+
+	def __evSeekableStatusChanged(self):
+		print "[__evSeekableStatusChanged]"
+		if self.getSeekState():
+			evfd.getInstance().vfd_set_icon(0x1A,1)
+		else:
+			evfd.getInstance().vfd_set_icon(0x1A,0)
+
+	def __evVideoSizeChanged(self):
+		print "[__evVideoSizeChanged]"
+		service=self.session.nav.getCurrentService()
+		if service is not None:
+			info=service.info()
+			height = info and info.getInfo(iServiceInformation.sVideoHeight) or -1
+			if height > 576 : #set HD symbol
+				evfd.getInstance().vfd_set_icon(0x11,1)
+			else:
+				evfd.getInstance().vfd_set_icon(0x11,0)
+
+	def gotRecordEvent(self, service, event):
+		recs = self.session.nav.getRecordings()
+		nrecs = len(recs)
+		if nrecs > 0: #set rec symbol
+			evfd.getInstance().vfd_set_icon(0x1e,1)
+		else:
+			evfd.getInstance().vfd_set_icon(0x1e,0)
+
+VFDIconsInstance = None
+
+def main(session, **kwargs):
+	# Create Instance if none present, show Dialog afterwards
+	global VFDIconsInstance
+	if VFDIconsInstance is None:
+		VFDIconsInstance = VFDIcons(session)
+
+def Plugins(**kwargs):
+	return [ PluginDescriptor(name="VFDIcons", description="Icons in VFD", where = PluginDescriptor.WHERE_SESSIONSTART, fnc=main ) ]
diff --git a/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py b/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py
index 7f39456..0a01ecd 100644
--- a/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py
+++ b/lib/python/Plugins/SystemPlugins/Videomode/VideoHardware.py
@@ -14,54 +14,36 @@ class VideoHardware:
 
 	modes = { }  # a list of (high-level) modes for a certain port.
 
-	rates["PAL"] =			{ "50Hz":	{ 50: "pal" },
-								"60Hz":		{ 60: "pal60" },
-								"multi":	{ 50: "pal", 60: "pal60" } }
+	rates["PAL"] =			{ "50Hz":	{ 50: "pal" } }
 
-	rates["NTSC"] =			{ "60Hz": 	{ 60: "ntsc" } }
+	rates["576i"] =			{ "50Hz":	{ 50: "576i50" } }
 
-	rates["Multi"] =		{ "multi": 	{ 50: "pal", 60: "ntsc" } }
+	rates["576p"] =			{ "50Hz":	{ 50: "576p50" } }
 
-	rates["480i"] =			{ "60Hz": 	{ 60: "480i" } }
-
-	rates["576i"] =			{ "50Hz": 	{ 50: "576i" } }
-
-	rates["480p"] =			{ "60Hz": 	{ 60: "480p" } }
-
-	rates["576p"] =			{ "50Hz": 	{ 50: "576p" } }
-
-	rates["720p"] =			{ "50Hz": 	{ 50: "720p50" },
-								"60Hz": 	{ 60: "720p" },
-								"multi": 	{ 50: "720p50", 60: "720p" } }
+	rates["720p"] =			{ "50Hz":	{ 50: "720p50" },
+								"60Hz":	{ 60: "720p60" } }
 
 	rates["1080i"] =		{ "50Hz":	{ 50: "1080i50" },
-								"60Hz":		{ 60: "1080i" },
-								"multi":	{ 50: "1080i50", 60: "1080i" } }
+								"60Hz":	{ 60: "1080i60" } }
 
-	rates["1080p"] =		{ "50Hz":	{ 50: "1080p50" },
-								"60Hz":		{ 60: "1080p" },
-								"multi":	{ 50: "1080p50", 60: "1080p" } }
+	rates["1080p"] =		{ "23Hz":	{ 50: "1080p23" },
+								"24Hz":	{ 60: "1080p24" },
+								"25Hz":	{ 60: "1080p25" },
+								"29Hz":	{ 60: "1080p29" },
+								"30Hz":	{ 60: "1080p30" },
+								"50Hz":	{ 60: "1080p50" },
+								"60Hz":	{ 60: "1080p60" } }
 
 	rates["PC"] = {
-		"1024x768": { 60: "1024x768" }, # not possible on DM7025
-		"800x600" : { 60: "800x600" },  # also not possible
-		"720x480" : { 60: "720x480" },
-		"720x576" : { 60: "720x576" },
-		"1280x720": { 60: "1280x720" },
-		"1280x720 multi": { 50: "1280x720_50", 60: "1280x720" },
-		"1920x1080": { 60: "1920x1080"},
-		"1920x1080 multi": { 50: "1920x1080", 60: "1920x1080_50" },
-		"1280x1024" : { 60: "1280x1024"},
-		"1366x768" : { 60: "1366x768"},
-		"1366x768 multi" : { 50: "1366x768", 60: "1366x768_50" },
-		"1280x768": { 60: "1280x768" },
-		"640x480" : { 60: "640x480" }
+		"1024x768"  : { 60: "1024x768_60", 70: "1024x768_70", 75: "1024x768_75", 90: "1024x768_90", 100: "1024x768_100" }, #43 60 70 72 75 90 100
+		"1280x1024" : { 60: "1280x1024_60", 70: "1280x1024_70", 75: "1280x1024_75" }, #43 47 60 70 74 75
+		"1600x1200" : { 60: "1600x1200_60" }, #60 66 76
 	}
 
-	modes["Scart"] = ["PAL", "NTSC", "Multi"]
-	modes["YPbPr"] = ["720p", "1080i", "576p", "480p", "576i", "480i"]
-	modes["DVI"] = ["720p", "1080p", "1080i", "576p", "480p", "576i", "480i"]
-	modes["DVI-PC"] = ["PC"]
+	modes["Scart"] = ["PAL"]
+	modes["Component"] = ["720p", "1080p", "1080i", "576p", "576i"]
+	modes["HDMI"] = ["720p", "1080p", "1080i", "576p", "576i"]
+	modes["HDMI-PC"] = ["PC"]
 
 	def getOutputAspect(self):
 		ret = (16,9)
@@ -109,14 +91,14 @@ class VideoHardware:
 		portlist = self.getPortList()
 		has1080p50 = False
 		for port in portlist:
-			if port == 'DVI' and HardwareInfo().has_hdmi():
+			if port == 'HDMI' and HardwareInfo().has_hdmi():
 				if "1080p50" in self.modes_available:
 					has1080p50 = True
 
 		if has1080p50:
-			self.widescreen_modes = set(["720p", "1080i", "1080p"])
+			self.widescreen_modes = set(["576i", "576p", "720p", "1080i", "1080p"])
 		else:
-			self.widescreen_modes = set(["720p", "1080i"])
+			self.widescreen_modes = set(["576i", "576p", "720p", "1080i"])
 
 		# take over old AVSwitch component :)
 		from Components.AVSwitch import AVSwitch
@@ -125,6 +107,16 @@ class VideoHardware:
 		config.av.wss.notifiers = [ ]
 		AVSwitch.getOutputAspect = self.getOutputAspect
 
+#+++>
+		config.av.colorformat_hdmi = ConfigSelection(choices = {"hdmi_rgb": _("RGB"), "hdmi_yuv": _("YUV"), "hdmi_422": _("422")}, default="hdmi_rgb")
+		config.av.colorformat_yuv = ConfigSelection(choices = {"yuv": _("YUV")}, default="yuv")
+		config.av.hdmi_audio_source = ConfigSelection(choices = {"pcm": _("PCM"), "spdif": _("SPDIF")}, default="pcm")
+		config.av.threedmode = ConfigSelection(choices = {"off": _("Off"), "sbs": _("Side by Side"),"tab": _("Top and Bottom")}, default="off")
+		config.av.threedmode.addNotifier(self.set3DMode)
+		config.av.colorformat_hdmi.addNotifier(self.setHDMIColor)
+		config.av.colorformat_yuv.addNotifier(self.setYUVColor)
+		config.av.hdmi_audio_source.addNotifier(self.setHDMIAudioSource)
+#+++<
 		config.av.aspect.addNotifier(self.updateAspect)
 		config.av.wss.addNotifier(self.updateAspect)
 		config.av.policy_169.addNotifier(self.updateAspect)
@@ -156,6 +148,8 @@ class VideoHardware:
 	def isModeAvailable(self, port, mode, rate):
 		rate = self.rates[mode][rate]
 		for mode in rate.values():
+			if port == "HDMI-PC":
+				return True
 			if mode not in self.modes_available:
 				return False
 		return True
@@ -192,7 +186,12 @@ class VideoHardware:
 		except IOError:
 			print "writing initial videomode to /etc/videomode failed."
 
+		#call setResolution() with -1,-1 to read the new scrren dimesions without changing the framebuffer resolution
+		from enigma import gMainDC
+		gMainDC.getInstance().setResolution(-1, -1)
+
 		self.updateAspect(None)
+		self.updateColor(port)
 
 	def saveMode(self, port, mode, rate):
 		print "saveMode", port, mode, rate
@@ -210,7 +209,8 @@ class VideoHardware:
 		return True
 
 	def isPortUsed(self, port):
-		if port == "DVI":
+#		if port == "DVI":
+		if port == "HDMI":
 			self.readPreferredModes()
 			return len(self.modes_preferred) != 0
 		else:
@@ -335,6 +335,33 @@ class VideoHardware:
 		except IOError:
 			pass
 
+#+++>
+	def set3DMode(self, configElement):
+		open("/proc/stb/video/3d_mode", "w").write(configElement.value)
+
+	def setHDMIColor(self, configElement):
+		map = {"hdmi_rgb": 0, "hdmi_yuv": 1, "hdmi_422": 2}
+		open("/proc/stb/avs/0/colorformat", "w").write(configElement.value)
+
+	def setYUVColor(self, configElement):
+		map = {"yuv": 0}
+		open("/proc/stb/avs/0/colorformat", "w").write(configElement.value)
+
+	def setHDMIAudioSource(self, configElement):
+		open("/proc/stb/hdmi/audio_source", "w").write(configElement.value)
+
+	def updateColor(self, port):
+		print "updateColor: ", port
+		if port == "HDMI":
+			self.setHDMIColor(config.av.colorformat_hdmi)
+		elif port == "Component":
+			self.setYUVColor(config.av.colorformat_yuv)
+		elif port == "Scart":
+			map = {"cvbs": 0, "rgb": 1, "svideo": 2, "yuv": 3}
+			from enigma import eAVSwitch
+			eAVSwitch.getInstance().setColorFormat(map[config.av.colorformat.value])
+#+++<
+
 config.av.edid_override = ConfigYesNo(default = False)
 video_hw = VideoHardware()
 video_hw.setConfiguredMode()
diff --git a/lib/python/Plugins/SystemPlugins/Videomode/plugin.py b/lib/python/Plugins/SystemPlugins/Videomode/plugin.py
index c16a1c1..f3fd6fc 100644
--- a/lib/python/Plugins/SystemPlugins/Videomode/plugin.py
+++ b/lib/python/Plugins/SystemPlugins/Videomode/plugin.py
@@ -67,6 +67,9 @@ class VideoSetup(Screen, ConfigListScreen):
 				self.list.append(getConfigListEntry(_("Resolution"), config.av.videorate[config.av.videomode[config.av.videoport.value].value], _("Configure the screen resolution in PC output mode.")))
 			else:
 				self.list.append(getConfigListEntry(_("Refresh rate"), config.av.videorate[config.av.videomode[config.av.videoport.value].value], _("Configure the refresh rate of the screen.")))
+#+++>
+		self.list.append(getConfigListEntry(_("3D Mode"), config.av.threedmode))
+#+++<
 
 		port = config.av.videoport.value
 		if port not in config.av.videomode:
@@ -90,6 +93,14 @@ class VideoSetup(Screen, ConfigListScreen):
 
 #		if config.av.videoport.value == "DVI":
 #			self.list.append(getConfigListEntry(_("Allow Unsupported Modes"), config.av.edid_override))
+#+++>
+		if config.av.videoport.value == "Component":
+			self.list.append(getConfigListEntry(_("Color Format"), config.av.colorformat_yuv))
+
+		if config.av.videoport.value == "HDMI":
+			self.list.append(getConfigListEntry(_("Color Format"), config.av.colorformat_hdmi))
+			self.list.append(getConfigListEntry(_("Audio Source"), config.av.hdmi_audio_source))
+#+++<
 		if config.av.videoport.value == "Scart":
 			self.list.append(getConfigListEntry(_("Color format"), config.av.colorformat, _("Configure which color format should be used on the SCART output.")))
 			if level >= 1:
diff --git a/lib/python/Screens/ChannelSelection.py b/lib/python/Screens/ChannelSelection.py
index b765e98..f25d124 100644
--- a/lib/python/Screens/ChannelSelection.py
+++ b/lib/python/Screens/ChannelSelection.py
@@ -5,6 +5,11 @@ import Screens.InfoBar
 import Components.ParentalControl
 from Components.Button import Button
 from Components.ServiceList import ServiceList, refreshServiceList
+#+++>
+from Components.Sources.StaticText import StaticText
+from Components.Label import Label
+from os import path as os_path, system, unlink
+#+++<
 from Components.ActionMap import NumberActionMap, ActionMap, HelpableActionMap
 from Components.MenuList import MenuList
 from Components.ServiceEventTracker import ServiceEventTracker, InfoBarBase
@@ -698,6 +703,9 @@ class ChannelSelectionEdit:
 		self.editMode = False
 		self.confirmRemove = True
 
+#+++>
+		self["title"] = StaticText()
+#+++<
 		class ChannelSelectionEditActionMap(ActionMap):
 			def __init__(self, csel, contexts=[ ], actions={ }, prio=0):
 				ActionMap.__init__(self, contexts, actions, prio)
@@ -978,6 +986,9 @@ class ChannelSelectionEdit:
 			else:
 				new_title += ' ' + _("[favourite edit]")
 		self.setTitle(new_title)
+#+++>
+		self["title"].setText(new_title)
+#+++<
 		self.__marked = self.servicelist.getRootServices()
 		for x in self.__marked:
 			self.servicelist.addMarked(eServiceReference(x))
@@ -1005,6 +1016,9 @@ class ChannelSelectionEdit:
 		self.bouquet_mark_edit = OFF
 		self.mutableList = None
 		self.setTitle(self.saved_title)
+#+++>
+		self["title"].setText(self.saved_title)
+#+++<
 		self.saved_title = None
 		# self.servicePath is just a reference to servicePathTv or Radio...
 		# so we never ever do use the asignment operator in self.servicePath
@@ -1080,6 +1094,9 @@ class ChannelSelectionEdit:
 			self.mutableList.flushChanges() # FIXME add check if changes was made
 			self.mutableList = None
 			self.setTitle(self.saved_title)
+#+++>
+			self["title"].setText(self.saved_title)
+#+++<
 			self.saved_title = None
 			self.servicelist.resetRoot()
 			self.servicelist.l.setHideNumberMarker(config.usage.hide_number_markers.value)
@@ -1091,6 +1108,9 @@ class ChannelSelectionEdit:
 			self.saved_title = self.getTitle()
 			pos = self.saved_title.find(')')
 			self.setTitle(self.saved_title[:pos+1] + ' ' + _("[move mode]") + self.saved_title[pos+1:]);
+#+++>
+			self["title"].setText(self.saved_title[:pos+1] + ' ' + _("[move mode]") + self.saved_title[pos+1:])
+#+++<
 			self.servicelist.l.setHideNumberMarker(False)
 			self.servicelist.setCurrent(self.servicelist.getCurrent())
 		self["Service"].editmode = True
@@ -1146,6 +1166,11 @@ class ChannelSelectionBase(Screen):
 		self["list"] = ServiceList(self)
 		self.servicelist = self["list"]
 
+#+++>
+		self["boquet"] = Label(_("Channel Selection"))
+		self["title"] = StaticText()
+#+++<
+
 		self.numericalTextInput = NumericalTextInput(handleTimeout=False)
 		self.numericalTextInput.setUseableChars(u'1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ')
 
@@ -1237,6 +1262,9 @@ class ChannelSelectionBase(Screen):
 			title = title[:pos]
 		title += _(" (TV)")
 		self.setTitle(title)
+#+++>
+		self["title"].setText(title)
+#+++<
 
 	def setRadioMode(self):
 		self.mode = MODE_RADIO
@@ -1248,6 +1276,9 @@ class ChannelSelectionBase(Screen):
 			title = title[:pos]
 		title += _(" (Radio)")
 		self.setTitle(title)
+#+++>
+		self["title"].setText(title)
+#+++<
 
 	def setRoot(self, root, justSet=False):
 		if self.startRoot is None:
@@ -1302,6 +1333,9 @@ class ChannelSelectionBase(Screen):
 					end_ref = None
 				nameStr = self.getServiceName(base_ref)
 				titleStr += ' - ' + nameStr
+#+++>
+				self["boquet"].setText("Channel Selection")
+#+++<
 				if end_ref is not None:
 					if Len > 2:
 						titleStr += '/../'
@@ -1309,7 +1343,13 @@ class ChannelSelectionBase(Screen):
 						titleStr += '/'
 					nameStr = self.getServiceName(end_ref)
 					titleStr += nameStr
+#+++>
+					self["boquet"].setText(nameStr)
+#+++<
 				self.setTitle(titleStr)
+#+++>
+				self["title"].setText(titleStr)
+#+++<
 
 	def moveUp(self):
 		self.servicelist.moveUp()
@@ -2343,6 +2383,11 @@ class SimpleChannelSelection(ChannelSelectionBase):
 
 	def layoutFinished(self):
 		self.setModeTv()
+
+#+++>
+		self["title"].setText(self.title)
+#+++<
+
 		if self.currentBouquet:
 			ref = Screens.InfoBar.InfoBar.instance.servicelist.getRoot()
 			if ref:
diff --git a/lib/python/Screens/InfoBar.py b/lib/python/Screens/InfoBar.py
index 27c6135..8d13ac5 100644
--- a/lib/python/Screens/InfoBar.py
+++ b/lib/python/Screens/InfoBar.py
@@ -10,6 +10,9 @@ from Screens.MessageBox import MessageBox
 
 profile("LOAD:enigma")
 import enigma
+#+++>
+from enigma import iServiceInformation, iPlayableService
+#+++<
 
 profile("LOAD:InfoBarGenerics")
 from Screens.InfoBarGenerics import InfoBarShowHide, \
@@ -20,7 +23,7 @@ from Screens.InfoBarGenerics import InfoBarShowHide, \
 	InfoBarServiceNotifications, InfoBarPVRState, InfoBarCueSheetSupport, InfoBarBuffer, \
 	InfoBarSummarySupport, InfoBarMoviePlayerSummarySupport, InfoBarTimeshiftState, InfoBarTeletextPlugin, InfoBarExtensions, \
 	InfoBarSubtitleSupport, InfoBarPiP, InfoBarPlugins, InfoBarServiceErrorPopupSupport, InfoBarJobman, InfoBarPowersaver, \
-	InfoBarHDMI, setResumePoint, delResumePoint
+	InfoBarHDMI, InfoBarAspectSelection, InfoBarSleepTimer, setResumePoint, delResumePoint
 from Screens.Hotkey import InfoBarHotkey
 
 profile("LOAD:InitBar_Components")
@@ -38,7 +41,7 @@ class InfoBar(InfoBarBase, InfoBarShowHide,
 	InfoBarSubserviceSelection, InfoBarTimeshift, InfoBarSeek, InfoBarCueSheetSupport, InfoBarBuffer,
 	InfoBarSummarySupport, InfoBarTimeshiftState, InfoBarTeletextPlugin, InfoBarExtensions,
 	InfoBarPiP, InfoBarPlugins, InfoBarSubtitleSupport, InfoBarServiceErrorPopupSupport, InfoBarJobman, InfoBarPowersaver,
-	InfoBarHDMI, InfoBarHotkey, Screen):
+	InfoBarHDMI, InfoBarHotkey, InfoBarAspectSelection, InfoBarSleepTimer, Screen):
 
 	ALLOW_SUSPEND = True
 	instance = None
@@ -50,6 +53,11 @@ class InfoBar(InfoBarBase, InfoBarShowHide,
 				"showMovies": (self.showMovies, _("Play recorded movies...")),
 				"showRadio": (self.showRadio, _("Show the radio player...")),
 				"showTv": (self.showTv, _("Show the tv player...")),
+				"toogleTvRadio": (self.toogleTvRadio, _("toggels betwenn tv and radio...")),
+				"volumeUp": (self._volUp, _("...")),
+				"volumeDown": (self._volDown, _("...")),
+				"resolution": (self.resolution, _("...")),
+				"aspect": (self.aspect, _("...")),
 			}, prio=2)
 
 		self.allowPiP = True
@@ -61,7 +69,7 @@ class InfoBar(InfoBarBase, InfoBarShowHide,
 				InfoBarAdditionalInfo, InfoBarNotifications, InfoBarDish, InfoBarSubserviceSelection, InfoBarBuffer, \
 				InfoBarTimeshift, InfoBarSeek, InfoBarCueSheetSupport, InfoBarSummarySupport, InfoBarTimeshiftState, \
 				InfoBarTeletextPlugin, InfoBarExtensions, InfoBarPiP, InfoBarSubtitleSupport, InfoBarJobman, InfoBarPowersaver, \
-				InfoBarPlugins, InfoBarServiceErrorPopupSupport, InfoBarHotkey, InfoBarHDMI:
+				InfoBarAspectSelection, InfoBarSleepTimer,InfoBarPlugins, InfoBarServiceErrorPopupSupport, InfoBarHotkey, InfoBarHDMI:
 			x.__init__(self)
 
 		self.helpList.append((self["actions"], "InfobarActions", [("showMovies", _("Watch recordings..."))]))
@@ -76,6 +84,88 @@ class InfoBar(InfoBarBase, InfoBarShowHide,
 		assert InfoBar.instance is None, "class InfoBar is a singleton class and just one instance of this class is allowed!"
 		InfoBar.instance = self
 
+	def aspect(self):
+		selection = 0
+		tlist = []
+		try:
+			policy = open("/proc/stb/video/policy_choices").read()[:-1]
+		except IOError:
+			print "couldn't read available policymodes."
+			policy_available = [ ]
+			return
+		policy_available = policy.split(' ')
+		for x in policy_available:
+			tlist.append((x[0].upper() + x[1:], _(x)))
+
+		mode = open("/proc/stb/video/policy").read()[:-1]
+		for x in range(len(tlist)):
+			if tlist[x][1] == mode:
+				selection = x
+
+		keys = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ]
+		from Screens.ChoiceBox import ChoiceBox
+		self.session.openWithCallback(self.aspectSelect, ChoiceBox, title=_("Please select an aspect ratio..."), list = tlist, selection = selection, keys = keys)
+
+	def aspectSelect(self, aspect):
+		if not aspect is None:
+			if isinstance(aspect[1], str):
+				open("/proc/stb/video/policy", "w").write(aspect[1])
+		return
+
+	def resolution(self):
+		xresString = open("/proc/stb/vmpeg/0/xres", "r").read()
+		yresString = open("/proc/stb/vmpeg/0/yres", "r").read()
+		fpsString = open("/proc/stb/vmpeg/0/framerate", "r").read()
+		xres = int(xresString, 16)
+		yres = int(yresString, 16)
+		fps = int(fpsString, 16)
+		fpsFloat = float(fps)
+		fpsFloat = fpsFloat/1000
+
+		selection = 0
+		tlist = []
+		tlist.append(("Video: " + str(xres) + "x" + str(yres) + "@" + str(fpsFloat) + "hz", ""))
+		tlist.append(("--", ""))
+		tlist.append(("576i", "576i50"))
+		tlist.append(("576p", "576p50"))
+		tlist.append(("720p@50hz", "720p50"))
+		tlist.append(("720p@60hz", "720p60"))
+		tlist.append(("1080i@50hz", "1080i50"))
+		tlist.append(("1080i@60hz", "1080i60"))
+		tlist.append(("1080p@23.976hz", "1080p23"))
+		tlist.append(("1080p@24hz", "1080p24"))
+		tlist.append(("1080p@25hz", "1080p25"))
+		tlist.append(("1080p@30hz", "1080p30"))
+		tlist.append(("1080p@50hz", "1080p50"))
+		tlist.append(("1080p@59hz", "1080p59"))
+		tlist.append(("1080p@60hz", "1080p60"))
+		keys = ["green", "", "yellow", "blue", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ]
+
+		mode = open("/proc/stb/video/videomode").read()[:-1]
+		for x in range(len(tlist)):
+			if tlist[x][1] == mode:
+				selection = x
+		from Screens.ChoiceBox import ChoiceBox
+		self.session.openWithCallback(self.ResolutionSelect, ChoiceBox, title=_("Please select a resolution..."), list = tlist, selection = selection, keys = keys)
+
+	def ResolutionSelect(self, Resolution):
+		if not Resolution is None:
+			if isinstance(Resolution[1], str):
+				open("/proc/stb/video/videomode", "w").write(Resolution[1])
+				from enigma import gMainDC
+				gMainDC.getInstance().setResolution(-1, -1)
+		return
+
+	def _volUp(self):
+		print "_volUp"
+		from Components.VolumeControl import VolumeControl
+		VolumeControl.instance.volUp()
+
+	def _volDown(self):
+		print "_volDown"
+		from Components.VolumeControl import VolumeControl
+		VolumeControl.instance.volDown()
+
 	def __onClose(self):
 		InfoBar.instance = None
 
@@ -94,6 +184,22 @@ class InfoBar(InfoBarBase, InfoBarShowHide,
 		self.__serviceStarted(True)
 		self.onExecBegin.remove(self.__checkServiceStarted)
 
+	def toogleTvRadio(self): 
+		service = self.session.nav.getCurrentService()
+		info = service.info()
+		AudioPID = info.getInfo(iServiceInformation.sAudioPID)
+		VideoPID = info.getInfo(iServiceInformation.sVideoPID)
+
+		print "sAudioPID", AudioPID
+		print "sVideoPID", VideoPID
+
+		if VideoPID == -1:
+			print "radio->tv"
+			self.showTv2()
+		else:
+			print "tv->radio"
+			self.showRadio2()
+
 	def serviceStarted(self):  #override from InfoBarShowHide
 		new = self.servicelist.newServicePlayed()
 		if self.execing:
@@ -117,6 +223,19 @@ class InfoBar(InfoBarBase, InfoBarShowHide,
 			from Screens.ChannelSelection import ChannelSelectionRadio
 			self.session.openWithCallback(self.ChannelSelectionRadioClosed, ChannelSelectionRadio, self)
 
+	def showTv2(self):
+		self.showTvChannelList(False)
+		self.openServiceList()
+
+	def showRadio2(self):
+		if config.usage.e1like_radio_mode.value:
+			self.showRadioChannelList(False)
+			self.openServiceList()
+		else:
+			self.rds_display.hide() # in InfoBarRdsDecoder
+			from Screens.ChannelSelection import ChannelSelectionRadio
+			self.session.openWithCallback(self.ChannelSelectionRadioClosed, ChannelSelectionRadio, self)
+
 	def ChannelSelectionRadioClosed(self, *arg):
 		self.rds_display.show()  # in InfoBarRdsDecoder
 		self.servicelist.correctChannelNumber()
@@ -137,6 +256,7 @@ class InfoBar(InfoBarBase, InfoBarShowHide,
 class MoviePlayer(InfoBarBase, InfoBarShowHide, InfoBarMenu, InfoBarSeek, InfoBarShowMovies, InfoBarInstantRecord,
 		InfoBarAudioSelection, HelpableScreen, InfoBarNotifications, InfoBarServiceNotifications, InfoBarPVRState,
 		InfoBarCueSheetSupport, InfoBarMoviePlayerSummarySupport, InfoBarSubtitleSupport, Screen, InfoBarTeletextPlugin,
+		InfoBarAspectSelection, InfoBarSubserviceSelection,
 		InfoBarServiceErrorPopupSupport, InfoBarExtensions, InfoBarPlugins, InfoBarPiP, InfoBarHDMI, InfoBarHotkey):
 
 	ENABLE_RESUME_SUPPORT = True
@@ -145,6 +265,8 @@ class MoviePlayer(InfoBarBase, InfoBarShowHide, InfoBarMenu, InfoBarSeek, InfoBa
 	def __init__(self, session, service, slist=None, lastservice=None, infobar=None):
 		Screen.__init__(self, session)
 
+		InfoBarAspectSelection.__init__(self)
+
 		self["actions"] = HelpableActionMap(self, "MoviePlayerActions",
 			{
 				"InfoButtonPressed": (self.openEventView, _("open Info...")),
@@ -294,11 +416,21 @@ class MoviePlayer(InfoBarBase, InfoBarShowHide, InfoBarMenu, InfoBarSeek, InfoBa
 					return
 
 		if answer in ("quit", "quitanddeleteconfirmed"):
+#+++>
+			# make sure that playback is unpaused otherwise the
+			# player driver might stop working
+			self.setSeekState(self.SEEK_STATE_PLAY)
+#+++<
 			self.close()
 		elif answer in ("movielist", "deleteandmovielistconfirmed"):
 			ref = self.session.nav.getCurrentlyPlayingServiceOrGroup()
 			self.returning = True
 			self.session.openWithCallback(self.movieSelected, Screens.MovieSelection.MovieSelection, ref)
+#+++>
+			# make sure that playback is unpaused otherwise the
+			# player driver might stop working
+			self.setSeekState(self.SEEK_STATE_PLAY)
+#+++<
 			self.session.nav.stopService()
 			if not config.movielist.stop_service.value:
 				self.session.nav.playService(self.lastservice)
@@ -518,4 +650,8 @@ class MoviePlayer(InfoBarBase, InfoBarShowHide, InfoBarMenu, InfoBarSeek, InfoBa
 		Notifications.AddPopup(text = _("%s/%s: %s") % (index, n, self.ref2HumanName(ref)), type = MessageBox.TYPE_INFO, timeout = 5)
 
 	def ref2HumanName(self, ref):
-		return enigma.eServiceCenter.getInstance().info(ref).getName(ref)		
+		return enigma.eServiceCenter.getInstance().info(ref).getName(ref)
+
+	def sleepTimer(self):
+		from Screens.SleepTimerEdit import SleepTimerEdit
+		self.session.open(SleepTimerEdit)
diff --git a/lib/python/Screens/InfoBarGenerics.py b/lib/python/Screens/InfoBarGenerics.py
index 6723801..0c1f1d5 100644
--- a/lib/python/Screens/InfoBarGenerics.py
+++ b/lib/python/Screens/InfoBarGenerics.py
@@ -9,7 +9,7 @@ from Components.MovieList import AUDIO_EXTENSIONS, MOVIE_EXTENSIONS, DVD_EXTENSI
 from Components.PluginComponent import plugins
 from Components.ServiceEventTracker import ServiceEventTracker
 from Components.Sources.Boolean import Boolean
-from Components.config import config, ConfigBoolean, ConfigClock, ConfigText
+from Components.config import config, ConfigBoolean, ConfigClock, ConfigSubsection, ConfigYesNo, ConfigText
 from Components.SystemInfo import SystemInfo
 from Components.UsageConfig import preferredInstantRecordPath, defaultMoviePath, ConfigSelection
 from Components.VolumeControl import VolumeControl
@@ -107,7 +107,7 @@ def saveResumePoints():
 	global resumePointCache, resumePointCacheLast
 	import cPickle
 	try:
-		f = open('/home/root/resumepoints.pkl', 'wb')
+		f = open('/etc/enigma2/resumepoints.pkl', 'wb')
 		cPickle.dump(resumePointCache, f, cPickle.HIGHEST_PROTOCOL)
 	except Exception, ex:
 		print "[InfoBar] Failed to write resumepoints:", ex
@@ -116,7 +116,7 @@ def saveResumePoints():
 def loadResumePoints():
 	import cPickle
 	try:
-		return cPickle.load(open('/home/root/resumepoints.pkl', 'rb'))
+		return cPickle.load(open('/etc/enigma2/resumepoints.pkl', 'rb'))
 	except Exception, ex:
 		print "[InfoBar] Failed to load resumepoints:", ex
 		return {}
@@ -224,6 +224,7 @@ class InfoBarShowHide(InfoBarScreenSaver):
 	STATE_HIDING = 1
 	STATE_SHOWING = 2
 	STATE_SHOWN = 3
+	STATE_EPG = 4
 
 	def __init__(self):
 		self["ShowHideActions"] = ActionMap( ["InfobarShowHideActions"] ,
@@ -327,6 +328,12 @@ class InfoBarShowHide(InfoBarScreenSaver):
 		else:
 			self.toggleShow()
 
+	def epg(self):
+		self.__state = self.STATE_EPG
+		self.hide()
+		self.hideTimer.stop()
+		self.openEventView()
+
 	def toggleShow(self):
 		if self.__state == self.STATE_HIDDEN:
 			self.showFirstInfoBar()
@@ -341,7 +348,9 @@ class InfoBarShowHide(InfoBarScreenSaver):
 			self.show()
 			self.secondInfoBarScreen.show()
 			self.startHideTimer()
-		else:
+		elif self.__state == self.STATE_SHOWN:
+			self.epg()
+		elif self.__state == self.STATE_EPG:
 			self.hide()
 			self.hideTimer.stop()
 
@@ -1933,7 +1942,7 @@ class InfoBarExtensions:
 
 	def updateExtensions(self):
 		self.extensionsList = []
-		self.availableKeys = [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", "red", "green", "yellow", "blue" ]
+		self.availableKeys = [ "red", "green", "yellow", "blue", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0" ]
 		self.extensionKeys = {}
 		for x in self.list:
 			if x[0] == self.EXTENSION_SINGLE:
@@ -2484,16 +2493,16 @@ class InfoBarSubserviceSelection:
 				idx += 1
 
 			if self.bouquets and len(self.bouquets):
-				keys = ["red", "blue", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
+				keys = ["red", "blue", "yellow", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
 				if config.usage.multibouquet.value:
-					tlist = [(_("Quick zap"), "quickzap", service.subServices()), (_("Add to bouquet"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("--", "")] + tlist
+					tlist = [(_("Quick zap"), "quickzap", service.subServices()), (_("Add to bouquet"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("Exit", "exit"), ("--", "")] + tlist
 				else:
-					tlist = [(_("Quick zap"), "quickzap", service.subServices()), (_("Add to favourites"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("--", "")] + tlist
-				selection += 3
+					tlist = [(_("Quick zap"), "quickzap", service.subServices()), (_("Add to favourites"), "CALLFUNC", self.addSubserviceToBouquetCallback), ("Exit", "exit"), ("--", "")] + tlist
+				selection += 4
 			else:
-				tlist = [(_("Quick zap"), "quickzap", service.subServices()), ("--", "")] + tlist
-				keys = ["red", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
-				selection += 2
+				tlist = [(_("Quick zap"), "quickzap", service.subServices()), ("Exit", "exit"), ("--", "")] + tlist
+				keys = ["red", "yellow", "",  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ] + [""] * n
+				selection += 3
 
 			self.session.openWithCallback(self.subserviceSelected, ChoiceBox, title=_("Please select a sub service..."), list = tlist, selection = selection, keys = keys, skin_name = "SubserviceSelection")
 
@@ -3083,6 +3092,143 @@ class InfoBarServiceErrorPopupSupport:
 				if hasattr(self, "dishDialog") and not self.dishDialog.dishState():
 					Notifications.AddPopup(text = error, type = MessageBox.TYPE_ERROR, timeout = 5, id = "ZapError")
 
+class InfoBarAspectSelection:
+	def __init__(self):
+		self["AspectSelectionAction"] = HelpableActionMap(self, "InfobarAspectSelectionActions",
+			{
+				"aspectSelection": (self.ExGreen_toggleGreen, _("Aspect list...")),
+			})
+
+		self["key_green"] = Boolean(True)
+		self["key_yellow"] = Boolean(True)
+		self["key_blue"] = Boolean(True)
+
+	def ExGreen_doResolution(self):
+		self.resolutionSelection()
+
+	def ExGreen_toggleGreen(self, arg=""):
+		self.aspectSelection()
+
+	def aspectSelection(self):
+		selection = 0
+		tlist = []
+		tlist.append((_("Subservice list..."), "subservice"))
+		tlist.append((_("Resolution"), "resolution"))
+		tlist.append((_("3D Modus"), "tdmodus"))
+		tlist.append(("--", ""))
+		tlist.append(("Letterbox", "letterbox"))
+		tlist.append(("PanScan", "panscan"))
+		tlist.append(("Non Linear", "non"))
+		tlist.append(("Bestfit", "bestfit"))
+
+		mode = open("/proc/stb/video/policy").read()[:-1]
+		print mode
+		for x in range(len(tlist)):
+			if tlist[x][1] == mode:
+				selection = x
+
+		keys = ["green", "yellow", "blue", "", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ]
+		self.session.openWithCallback(self.aspectSelected, ChoiceBox, title=_("Please select an aspect ratio..."), list = tlist, selection = selection, keys = keys) 
+
+	def aspectSelected(self, aspect):
+		if not aspect is None:
+			if isinstance(aspect[1], str):
+				if aspect[1] == "resolution":
+					self.ExGreen_doResolution()
+				elif aspect[1] == "tdmodus":
+					self.tdmodus()
+				elif aspect[1] == "subservice":
+					self.subserviceSelection()
+				else:
+					open("/proc/stb/video/policy", "w").write(aspect[1])
+		return
+
+	def tdmodus(self):
+		selection = 0
+		tlist = []
+		tlist.append((_("off"), "off"))
+		tlist.append((_("Side-by-Side"), "sbs"))
+		tlist.append((_("Top and Bottom"), "tab"))
+		keys = ["green", "yellow", "blue"]
+		self.session.openWithCallback(self.tdSelected, ChoiceBox, title=_("Please select an 3D modus..."), list = tlist, selection = selection, keys = keys)
+
+	def tdSelected(self, tdmod):
+		if not tdmod is None:
+			if isinstance(tdmod[1], str):
+				if tdmod[1] == "off":
+					config.av.threedmode.value = "off"
+					config.av.threedmode.save()
+					command('killall 3d-mode')
+				elif tdmod[1] == "sbs":
+					config.av.threedmode.value = "sbs"
+					config.av.threedmode.save()
+					command('3d-mode 40 &')
+				elif tdmod[1] == "tab":
+					config.av.threedmode.value = "tab"
+					config.av.threedmode.save()
+		return
+
+	def resolutionSelection(self):
+		xresString = open("/proc/stb/vmpeg/0/xres", "r").read()
+		yresString = open("/proc/stb/vmpeg/0/yres", "r").read()
+		fpsString = open("/proc/stb/vmpeg/0/framerate", "r").read()
+		xres = int(xresString, 16)
+		yres = int(yresString, 16)
+		fps = int(fpsString, 16)
+		fpsFloat = float(fps)
+		fpsFloat = fpsFloat/1000
+
+		selection = 0
+		tlist = []
+		tlist.append((_("Exit"), "exit"))
+		tlist.append((_("Auto(not available)"), "auto"))
+		tlist.append(("Video: " + str(xres) + "x" + str(yres) + "@" + str(fpsFloat) + "hz", ""))
+		tlist.append(("--", ""))
+		tlist.append(("576i", "576i50"))
+		tlist.append(("576p", "576p50"))
+		tlist.append(("720p@50hz", "720p50"))
+		tlist.append(("720p@60hz", "720p60"))
+		tlist.append(("1080i@50hz", "1080i50"))
+		tlist.append(("1080i@60hz", "1080i60"))
+		tlist.append(("1080p@23.976hz", "1080p23"))
+		tlist.append(("1080p@24hz", "1080p24"))
+		tlist.append(("1080p@25hz", "1080p25"))
+		tlist.append(("1080p@29hz", "1080p29"))
+		tlist.append(("1080p@30hz", "1080p30"))
+		tlist.append(("1080p@50hz", "1080p50"))
+		tlist.append(("1080p@59hz", "1080p59"))
+		tlist.append(("1080p@60hz", "1080p60"))
+
+		keys = ["green", "yellow", "blue", "", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" ]
+
+		mode = open("/proc/stb/video/videomode").read()[:-1]
+		print mode
+		for x in range(len(tlist)):
+			if tlist[x][1] == mode:
+				selection = x
+
+		self.session.openWithCallback(self.ResolutionSelected, ChoiceBox, title=_("Please select a resolution..."), list = tlist, selection = selection, keys = keys)
+
+	def ResolutionSelected(self, Resolution):
+		if not Resolution is None:
+			if isinstance(Resolution[1], str):
+				if Resolution[1] != "auto":
+					open("/proc/stb/video/videomode", "w").write(Resolution[1])
+					from enigma import gMainDC
+					gMainDC.getInstance().setResolution(-1, -1)
+		return
+
+class InfoBarSleepTimer:
+	def __init__(self):
+		self.addExtension((self.getSleepTimerName, self.showSleepTimerSetup, lambda: True), "blue")
+
+	def getSleepTimerName(self):
+		return _("Sleep Timer")
+
+	def showSleepTimerSetup(self):
+		from Screens.SleepTimerEdit import SleepTimerEdit
+		self.session.open(SleepTimerEdit)
+
 class InfoBarPowersaver:
 	def __init__(self):
 		self.inactivityTimer = eTimer()
diff --git a/lib/python/Screens/ScanSetup.py b/lib/python/Screens/ScanSetup.py
index 5f9f5a1..bb7b444 100644
--- a/lib/python/Screens/ScanSetup.py
+++ b/lib/python/Screens/ScanSetup.py
@@ -17,7 +17,7 @@ from Components.Converter.ChannelNumbers import channelnumbers
 def buildTerTransponder(frequency,
 		inversion=2, bandwidth = 7000000, fechigh = 6, feclow = 6,
 		modulation = 2, transmission = 2, guard = 4,
-		hierarchy = 4, system = 0, plpid = 0):
+		hierarchy = 4, system = 0, plp_id = 0):
 #	print "freq", frequency, "inv", inversion, "bw", bandwidth, "fech", fechigh, "fecl", feclow, "mod", modulation, "tm", transmission, "guard", guard, "hierarchy", hierarchy
 	parm = eDVBFrontendParametersTerrestrial()
 	parm.frequency = frequency
@@ -30,7 +30,7 @@ def buildTerTransponder(frequency,
 	parm.guard_interval = guard
 	parm.hierarchy = hierarchy
 	parm.system = system
-	parm.plpid = plpid
+	parm.plp_id = plp_id
 	return parm
 
 def getInitialTransponderList(tlist, pos):
@@ -48,6 +48,9 @@ def getInitialTransponderList(tlist, pos):
 			parm.modulation = x[6]
 			parm.rolloff = x[8]
 			parm.pilot = x[9]
+			parm.is_id = x[10]
+			parm.pls_mode = x[11]
+			parm.pls_code = x[12]
 			tlist.append(parm)
 
 def getInitialCableTransponderList(tlist, nim):
@@ -69,13 +72,21 @@ def getInitialTerrestrialTransponderList(tlist, region):
 	#self.transponders[self.parsedTer].append((2,freq,bw,const,crh,crl,guard,transm,hierarchy,inv))
 
 	#def buildTerTransponder(frequency, inversion = 2, bandwidth = 3, fechigh = 6, feclow = 6,
-				#modulation = 2, transmission = 2, guard = 4, hierarchy = 4):
+				#modulation = 2, transmission = 2, guard = 4, hierarchy = 4, system = 0, plp_id = 0):
 
 	for x in list:
 		if x[0] == 2: #TERRESTRIAL
 			parm = buildTerTransponder(x[1], x[9], x[2], x[4], x[5], x[3], x[7], x[6], x[8], x[10], x[11])
 			tlist.append(parm)
 
+def getRegionTerrestrialTransponderList(region):
+	tlist = []
+	for x in nimmanager.getTranspondersTerrestrial(region):
+		if x[0] == 2: #TERRESTRIAL
+			parm = buildTerTransponder(x[1], x[9], x[2], x[4], x[5], x[3], x[7], x[6], x[8], x[10], x[11])
+			tlist.append((parm, str(x[1] / 1000)))
+	return tlist
+
 cable_bands = {
 	"DVBC_BAND_EU_VHF_I" : 1 << 0,
 	"DVBC_BAND_EU_MID" : 1 << 1,
@@ -400,6 +411,10 @@ class ScanSetup(ConfigListScreen, Screen, CableTransponderSearchSupport):
 					self.list.append(self.modulationEntry)
 					self.list.append(getConfigListEntry(_('Roll-off'), self.scan_sat.rolloff))
 					self.list.append(getConfigListEntry(_('Pilot'), self.scan_sat.pilot))
+					if nim.hasMultistream():
+						self.list.append(getConfigListEntry(_('Input Stream ID'), self.scan_sat.is_id))
+						self.list.append(getConfigListEntry(_("PLS Mode"), self.scan_sat.pls_mode))
+						self.list.append(getConfigListEntry(_('PLS Code'), self.scan_sat.pls_code))
 			elif self.scan_type.value == "predefined_transponder" and self.satList[index_to_scan]:
 				self.updateSatList()
 				self.preDefSatList = getConfigListEntry(_('Satellite'), self.scan_satselection[index_to_scan])
@@ -508,7 +523,9 @@ class ScanSetup(ConfigListScreen, Screen, CableTransponderSearchSupport):
 			"polarization": eDVBFrontendParametersSatellite.Polarisation_Horizontal,
 			"fec": eDVBFrontendParametersSatellite.FEC_Auto,
 			"fec_s2": eDVBFrontendParametersSatellite.FEC_9_10,
-			"modulation": eDVBFrontendParametersSatellite.Modulation_QPSK }
+			"modulation": eDVBFrontendParametersSatellite.Modulation_QPSK,
+			"pls_mode": eDVBFrontendParametersSatellite.PLS_Root,
+			"pls_code": 1 }
 		defaultCab = {
 			"frequency": 466,
 			"inversion": eDVBFrontendParametersCable.Inversion_Unknown,
@@ -541,6 +558,9 @@ class ScanSetup(ConfigListScreen, Screen, CableTransponderSearchSupport):
 					defaultSat["fec_s2"] = frontendData.get("fec_inner", eDVBFrontendParametersSatellite.FEC_Auto)
 					defaultSat["rolloff"] = frontendData.get("rolloff", eDVBFrontendParametersSatellite.RollOff_alpha_0_35)
 					defaultSat["pilot"] = frontendData.get("pilot", eDVBFrontendParametersSatellite.Pilot_Unknown)
+					defaultSat["is_id"] = frontendData.get("is_id", 0)
+					defaultSat["pls_mode"] = frontendData.get("pls_mode", eDVBFrontendParametersSatellite.PLS_Root)
+					defaultSat["pls_code"] = frontendData.get("pls_code", 1)
 				else:
 					defaultSat["fec"] = frontendData.get("fec_inner", eDVBFrontendParametersSatellite.FEC_Auto)
 				defaultSat["modulation"] = frontendData.get("modulation", eDVBFrontendParametersSatellite.Modulation_QPSK)
@@ -635,7 +655,9 @@ class ScanSetup(ConfigListScreen, Screen, CableTransponderSearchSupport):
 			(eDVBFrontendParametersSatellite.FEC_9_10, "9/10")])
 		self.scan_sat.modulation = ConfigSelection(default = defaultSat["modulation"], choices = [
 			(eDVBFrontendParametersSatellite.Modulation_QPSK, "QPSK"),
-			(eDVBFrontendParametersSatellite.Modulation_8PSK, "8PSK")])
+			(eDVBFrontendParametersSatellite.Modulation_8PSK, "8PSK"),
+			(eDVBFrontendParametersSatellite.Modulation_16APSK, "16APSK"),
+			(eDVBFrontendParametersSatellite.Modulation_32APSK, "32APSK")])
 		self.scan_sat.rolloff = ConfigSelection(default = defaultSat.get("rolloff", eDVBFrontendParametersSatellite.RollOff_alpha_0_35), choices = [
 			(eDVBFrontendParametersSatellite.RollOff_alpha_0_35, "0.35"),
 			(eDVBFrontendParametersSatellite.RollOff_alpha_0_25, "0.25"),
@@ -645,6 +667,12 @@ class ScanSetup(ConfigListScreen, Screen, CableTransponderSearchSupport):
 			(eDVBFrontendParametersSatellite.Pilot_Off, _("Off")),
 			(eDVBFrontendParametersSatellite.Pilot_On, _("On")),
 			(eDVBFrontendParametersSatellite.Pilot_Unknown, _("Auto"))])
+		self.scan_sat.is_id = ConfigInteger(default = defaultSat.get("is_id",0), limits = (0, 255))
+		self.scan_sat.pls_mode = ConfigSelection(default = defaultSat["pls_mode"], choices = [
+			(eDVBFrontendParametersSatellite.PLS_Root, _("Root")),
+			(eDVBFrontendParametersSatellite.PLS_Gold, _("Gold")),
+			(eDVBFrontendParametersSatellite.PLS_Combo, _("Combo"))])
+		self.scan_sat.pls_code = ConfigInteger(default = defaultSat.get("pls_code",1), limits = (0, 262142))
 
 		# cable
 		self.scan_cab.frequency = ConfigInteger(default = defaultCab["frequency"], limits = (50, 999))
@@ -685,6 +713,11 @@ class ScanSetup(ConfigListScreen, Screen, CableTransponderSearchSupport):
 		# WORKAROUND: we can't use BW-auto
 		self.scan_ter.bandwidth = ConfigSelection(default = defaultTer["bandwidth"], choices = [
 			(1712000, "1.712MHz"),
+			(8000000, "8MHz"),
+			(7000000, "7MHz"),
+			(6000000, "6MHz"),
+			])
+		self.scan_ter.bandwidth_t2 = ConfigSelection(default = defaultTer["bandwidth"], choices = [
 			(5000000, "5MHz"),
 			(6000000, "6MHz"),
 			(7000000, "7MHz"),
@@ -697,18 +730,14 @@ class ScanSetup(ConfigListScreen, Screen, CableTransponderSearchSupport):
 			(eDVBFrontendParametersTerrestrial.FEC_2_3, "2/3"),
 			(eDVBFrontendParametersTerrestrial.FEC_3_4, "3/4"),
 			(eDVBFrontendParametersTerrestrial.FEC_5_6, "5/6"),
-			(eDVBFrontendParametersTerrestrial.FEC_6_7, "6/7"),
 			(eDVBFrontendParametersTerrestrial.FEC_7_8, "7/8"),
-			(eDVBFrontendParametersTerrestrial.FEC_8_9, "8/9"),
 			(eDVBFrontendParametersTerrestrial.FEC_Auto, _("Auto"))])
 		self.scan_ter.feclow = ConfigSelection(default = defaultTer["feclow"], choices = [
 			(eDVBFrontendParametersTerrestrial.FEC_1_2, "1/2"),
 			(eDVBFrontendParametersTerrestrial.FEC_2_3, "2/3"),
 			(eDVBFrontendParametersTerrestrial.FEC_3_4, "3/4"),
 			(eDVBFrontendParametersTerrestrial.FEC_5_6, "5/6"),
-			(eDVBFrontendParametersTerrestrial.FEC_6_7, "6/7"),
 			(eDVBFrontendParametersTerrestrial.FEC_7_8, "7/8"),
-			(eDVBFrontendParametersTerrestrial.FEC_8_9, "8/9"),
 			(eDVBFrontendParametersTerrestrial.FEC_Auto, _("Auto"))])
 		self.scan_ter.modulation = ConfigSelection(default = defaultTer["modulation"], choices = [
 			(eDVBFrontendParametersTerrestrial.Modulation_QPSK, "QPSK"),
@@ -782,7 +811,7 @@ class ScanSetup(ConfigListScreen, Screen, CableTransponderSearchSupport):
 		self.last_scan_typecable = "single_transponder"
 		self.cable_toggle = {"single_transponder":"complete", "complete":"single_transponder"}
 		self.scan_typeterrestrial = ConfigSelection(default = defaultTerrSearchType, choices = [("single_transponder", _("User defined transponder")), ("predefined_transponder", _("Predefined transponder")), ("complete", _("Complete"))])
-		self.scan_input_as = ConfigSelection(default = "channel", choices = [("frequency", _("Frequency")), ("channel", _("Channel"))])
+		self.scan_input_as = ConfigSelection(default = "frequency", choices = [("frequency", _("Frequency")), ("channel", _("Channel"))])
 		self.scan_clearallservices = ConfigSelection(default = "no", choices = [("no", _("no")), ("yes", _("yes")), ("yes_hold_feeds", _("yes (keep feeds)"))])
 		self.scan_onlyfree = ConfigYesNo(default = False)
 		self.scan_networkScan = ConfigYesNo(default = False)
diff --git a/lib/python/Screens/Standby.py b/lib/python/Screens/Standby.py
index e30b0f9..60f6859 100644
--- a/lib/python/Screens/Standby.py
+++ b/lib/python/Screens/Standby.py
@@ -9,12 +9,16 @@ from GlobalActions import globalActionMap
 import RecordTimer
 from enigma import eDVBVolumecontrol, eTimer, eDVBLocalTimeHandler
 from time import time, localtime
+from subprocess import call
 
 inStandby = None
 
 class Standby(Screen):
 	def Power(self):
 		print "leave standby"
+#+++>
+		call("/bin/vdstandby -d &", shell="true")
+#+++<
 		#set input to encoder
 		self.avswitch.setInput("ENCODER")
 		#restart last played service
@@ -86,6 +90,9 @@ class Standby(Screen):
 			self.avswitch.setInput("SCART")
 		else:
 			self.avswitch.setInput("AUX")
+#+++>
+		call("/bin/vdstandby -a &", shell="true")
+#+++<
 
 		gotoShutdownTime = int(config.usage.standby_to_shutdown_timer.value)
 		if gotoShutdownTime:
diff --git a/lib/python/Screens/Wizard.py b/lib/python/Screens/Wizard.py
index 0091631..3561141 100644
--- a/lib/python/Screens/Wizard.py
+++ b/lib/python/Screens/Wizard.py
@@ -14,6 +14,9 @@ from enigma import eTimer, eEnv
 
 from xml.sax import make_parser
 from xml.sax.handler import ContentHandler
+#+++>
+from enigma import evfd
+#+++<
 
 class WizardSummary(Screen):
 	def __init__(self, session, parent):
@@ -351,6 +354,9 @@ class Wizard(Screen):
 				if self.updateValues in self.onShown:
 					self.onShown.remove(self.updateValues)
 
+#+++>
+		open("/proc/progress", "w").write("100")
+#+++<
 		if print_now:
 			print "Now: " + str(self.currStep)
 
@@ -443,6 +449,9 @@ class Wizard(Screen):
 			if self.wizard[self.currStep].has_key("onselect"):
 				self.selection = self["list"].current[-1]
 				print "self.selection:", self.selection
+#+++>
+				evfd.getInstance().vfd_write_string("-> " + self.selection)
+#+++<
 				exec("self." + self.wizard[self.currStep]["onselect"] + "()")
 
 	def resetCounter(self):
diff --git a/lib/python/Tools/KeyBindings.py b/lib/python/Tools/KeyBindings.py
index 84749aa..c8cbe2b 100644
--- a/lib/python/Tools/KeyBindings.py
+++ b/lib/python/Tools/KeyBindings.py
@@ -45,7 +45,10 @@ keyDescriptions = [{
 		KEYIDS["KEY_9"]: ("9",),
 		KEYIDS["KEY_EXIT"]: ("EXIT",),
 		KEYIDS["KEY_STOP"]: ("STOP",),
-		KEYIDS["KEY_RECORD"]: ("RECORD",)
+		KEYIDS["KEY_RECORD"]: ("RECORD",),
+		KEYIDS["KEY_EPG"]: ("EPG",),
+		KEYIDS["KEY_REWIND"]: ("REWIND",),
+		KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",)
 	},
 	{
 		KEYIDS["BTN_0"]: ("UP", "fp"),
@@ -87,7 +90,10 @@ keyDescriptions = [{
 		KEYIDS["KEY_9"]: ("9",),
 		KEYIDS["KEY_EXIT"]: ("EXIT",),
 		KEYIDS["KEY_STOP"]: ("TV", "SHIFT"),
-		KEYIDS["KEY_RECORD"]: ("RADIO", "SHIFT")
+		KEYIDS["KEY_RECORD"]: ("RADIO", "SHIFT"),
+		KEYIDS["KEY_EPG"]: ("EPG",),
+		KEYIDS["KEY_REWIND"]: ("REWIND",),
+		KEYIDS["KEY_FASTFORWARD"]: ("FASTFORWARD",)
 	},
 	{
 		KEYIDS["BTN_0"]: ("UP", "fp"),
diff --git a/lib/python/Tools/Transponder.py b/lib/python/Tools/Transponder.py
index d6ae277..ce4ca4e 100644
--- a/lib/python/Tools/Transponder.py
+++ b/lib/python/Tools/Transponder.py
@@ -27,7 +27,8 @@ def ConvertToHumanReadable(tp, type = None):
 		ret["modulation"] = {
 			eDVBFrontendParametersSatellite.Modulation_Auto : _("Auto"),
 			eDVBFrontendParametersSatellite.Modulation_QPSK : "QPSK",
-			eDVBFrontendParametersSatellite.Modulation_QAM16 : "QAM16",
+			eDVBFrontendParametersSatellite.Modulation_16APSK : "16APSK",
+			eDVBFrontendParametersSatellite.Modulation_32APSK : "32APSK",
 			eDVBFrontendParametersSatellite.Modulation_8PSK : "8PSK"}.get(tp.get("modulation"))
 		ret["orbital_position"] = nimmanager.getSatName(int(tp.get("orbital_position")))
 		ret["polarization"] = {
@@ -53,6 +54,11 @@ def ConvertToHumanReadable(tp, type = None):
 				eDVBFrontendParametersSatellite.Pilot_Unknown : _("Auto"),
 				eDVBFrontendParametersSatellite.Pilot_On : _("On"),
 				eDVBFrontendParametersSatellite.Pilot_Off : _("Off")}.get(tp.get("pilot"))
+			ret["pls_mode"] = {
+				eDVBFrontendParametersSatellite.PLS_Root : _("Root"),
+				eDVBFrontendParametersSatellite.PLS_Gold : _("Gold"),
+				eDVBFrontendParametersSatellite.PLS_Combo : _("Combo"),
+				eDVBFrontendParametersSatellite.PLS_Unknown : _("Unknown")}.get(tp.get("pls_mode"))
 	elif type == "DVB-C":
 		ret["tuner_type"] = _("Cable")
 		ret["modulation"] = {
@@ -94,21 +100,21 @@ def ConvertToHumanReadable(tp, type = None):
 		ret["code_rate_lp"] = {
 			eDVBFrontendParametersTerrestrial.FEC_Auto : _("Auto"),
 			eDVBFrontendParametersTerrestrial.FEC_1_2 : "1/2",
+			eDVBFrontendParametersTerrestrial.FEC_3_5 : "3/5",
 			eDVBFrontendParametersTerrestrial.FEC_2_3 : "2/3",
 			eDVBFrontendParametersTerrestrial.FEC_3_4 : "3/4",
+			eDVBFrontendParametersTerrestrial.FEC_4_5 : "4/5",
 			eDVBFrontendParametersTerrestrial.FEC_5_6 : "5/6",
-			eDVBFrontendParametersTerrestrial.FEC_6_7 : "6/7",
-			eDVBFrontendParametersTerrestrial.FEC_7_8 : "7/8",
-			eDVBFrontendParametersTerrestrial.FEC_8_9 : "8/9"}.get(tp.get("code_rate_lp"))
+			eDVBFrontendParametersTerrestrial.FEC_7_8 : "7/8"}.get(tp.get("code_rate_lp"))
 		ret["code_rate_hp"] = {
 			eDVBFrontendParametersTerrestrial.FEC_Auto : _("Auto"),
 			eDVBFrontendParametersTerrestrial.FEC_1_2 : "1/2",
+			eDVBFrontendParametersTerrestrial.FEC_3_5 : "3/5",
 			eDVBFrontendParametersTerrestrial.FEC_2_3 : "2/3",
 			eDVBFrontendParametersTerrestrial.FEC_3_4 : "3/4",
+			eDVBFrontendParametersTerrestrial.FEC_4_5 : "4/5",
 			eDVBFrontendParametersTerrestrial.FEC_5_6 : "5/6",
-			eDVBFrontendParametersTerrestrial.FEC_6_7 : "6/7",
-			eDVBFrontendParametersTerrestrial.FEC_7_8 : "7/8",
-			eDVBFrontendParametersTerrestrial.FEC_8_9 : "8/9"}.get(tp.get("code_rate_hp"))
+			eDVBFrontendParametersTerrestrial.FEC_7_8 : "7/8"}.get(tp.get("code_rate_hp"))
 		ret["constellation"] = {
 			eDVBFrontendParametersTerrestrial.Modulation_Auto : _("Auto"),
 			eDVBFrontendParametersTerrestrial.Modulation_QPSK : "QPSK",
@@ -131,7 +137,10 @@ def ConvertToHumanReadable(tp, type = None):
 			eDVBFrontendParametersTerrestrial.GuardInterval_1_32 : "1/32",
 			eDVBFrontendParametersTerrestrial.GuardInterval_1_16 : "1/16",
 			eDVBFrontendParametersTerrestrial.GuardInterval_1_8 : "1/8",
-			eDVBFrontendParametersTerrestrial.GuardInterval_1_4 : "1/4"}.get(tp.get("guard_interval"))
+			eDVBFrontendParametersTerrestrial.GuardInterval_1_4 : "1/4",
+			eDVBFrontendParametersTerrestrial.GuardInterval_1_128 : "1/128",
+			eDVBFrontendParametersTerrestrial.GuardInterval_19_128 : "19/128",
+			eDVBFrontendParametersTerrestrial.GuardInterval_19_256 : "19/256"}.get(tp.get("guard_interval"))
 		ret["hierarchy_information"] = {
 			eDVBFrontendParametersTerrestrial.Hierarchy_Auto : _("Auto"),
 			eDVBFrontendParametersTerrestrial.Hierarchy_None : _("None"),
diff --git a/lib/python/enigma_python.i b/lib/python/enigma_python.i
index dd4b8c7..8280417 100644
--- a/lib/python/enigma_python.i
+++ b/lib/python/enigma_python.i
@@ -109,6 +109,7 @@ is usually caused by not marking PSignals as immutable.
 #include <lib/python/python.h>
 #include <lib/python/python_helpers.h>
 #include <lib/gdi/picload.h>
+#include <lib/driver/vfd.h> 
 %}
 
 %feature("ref")   iObject "$this->AddRef(); /* eDebug(\"AddRef (%s:%d)!\", __FILE__, __LINE__); */ "
@@ -251,6 +252,7 @@ typedef long time_t;
 %include <lib/python/python.h>
 %include <lib/python/pythonconfig.h>
 %include <lib/gdi/picload.h>
+%include <lib/driver/vfd.h>
 /**************  eptr  **************/
 
 /**************  signals  **************/
@@ -417,7 +419,9 @@ extern int getPrevAsciiCode();
 extern void addFont(const char *filename, const char *alias, int scale_factor, int is_replacement, int renderflags = 0);
 extern const char *getEnigmaVersionString();
 extern const char *getBoxType();
+#ifdef ENABLE_MEDIAFWGSTREAMER
 extern const char *getGStreamerVersionString();
+#endif
 extern void dump_malloc_stats(void);
 %}
 
@@ -428,7 +432,9 @@ extern void quitMainloop(int exit_code);
 extern eApplication *getApplication();
 extern const char *getEnigmaVersionString();
 extern const char *getBoxType();
+#ifdef ENABLE_MEDIAFWGSTREAMER
 extern const char *getGStreamerVersionString();
+#endif
 extern void dump_malloc_stats(void);
 
 %include <lib/python/python_console.i>
diff --git a/lib/service/Makefile.inc b/lib/service/Makefile.inc
index 55c2e33..64d108a 100644
--- a/lib/service/Makefile.inc
+++ b/lib/service/Makefile.inc
@@ -15,6 +15,13 @@ service_libenigma_service_a_SOURCES = \
 	service/servicedvbstream.cpp \
 	service/servicehdmi.cpp
 
+if ENABLE_LIBEPLAYER3 
+if ENABLE_MEDIAFWGSTREAMER
+service_libenigma_service_a_SOURCES += \
+	service/serviceeplayer3.cpp
+endif
+endif
+
 serviceincludedir = $(pkgincludedir)/lib/service
 serviceinclude_HEADERS = \
 	service/event.h \
@@ -29,6 +36,13 @@ serviceinclude_HEADERS = \
 	service/servicedvbstream.h \
 	service/servicehdmi.h
 
+if ENABLE_LIBEPLAYER3 
+if ENABLE_MEDIAFWGSTREAMER
+serviceinclude_HEADERS += \
+	service/serviceeplayer3.h
+endif
+endif
+
 if HAVE_LIBXINE
 service_libenigma_service_a_SOURCES += \
 	service/servicexine.cpp
@@ -41,4 +55,4 @@ service_libenigma_service_a_SOURCES += \
 	service/servicedvd.cpp
 serviceinclude_HEADERS += \
 	service/servicedvd.h
-endif
\ No newline at end of file
+endif
diff --git a/lib/service/listboxservice.cpp b/lib/service/listboxservice.cpp
index e4c3921..23f8211 100644
--- a/lib/service/listboxservice.cpp
+++ b/lib/service/listboxservice.cpp
@@ -150,14 +150,14 @@ int eListboxServiceContent::getPrevMarkerPos()
 	{
 		--i;
 		--index;
-		if (!(i->flags & eServiceReference::isMarker && !(i->flags & eServiceReference::isInvisible)))
+		if (! ((i->flags & eServiceReference::isMarker) && !(i->flags & eServiceReference::isInvisible)))
 			break;
 	}
 	while (index)
 	{
 		--i;
 		--index;
-		if (i->flags & eServiceReference::isMarker && !(i->flags & eServiceReference::isInvisible))
+		if ((i->flags & eServiceReference::isMarker) && !(i->flags & eServiceReference::isInvisible))
 			break;
 	}
 	return cursorResolve(index);
@@ -173,7 +173,7 @@ int eListboxServiceContent::getNextMarkerPos()
 	{
 		++i;
 		++index;
-		if (i->flags & eServiceReference::isMarker && !(i->flags & eServiceReference::isInvisible))
+		if ((i->flags & eServiceReference::isMarker) && !(i->flags & eServiceReference::isInvisible))
 			break;
 	}
 	return cursorResolve(index);
diff --git a/lib/service/servicedvb.cpp b/lib/service/servicedvb.cpp
index b236e8a..4e46949 100644
--- a/lib/service/servicedvb.cpp
+++ b/lib/service/servicedvb.cpp
@@ -641,6 +641,9 @@ eServiceFactoryDVB::eServiceFactoryDVB()
 	if (sc)
 	{
 		std::list<std::string> extensions;
+#if defined(__sh__) //Topfield original recording extension
+		extensions.push_back("rec");
+#endif
 		extensions.push_back("ts");
 		extensions.push_back("trp");
 		sc->addServiceFactory(eServiceFactoryDVB::id, this, extensions);
diff --git a/lib/service/servicedvbrecord.cpp b/lib/service/servicedvbrecord.cpp
index 3e91bb1..3584847 100644
--- a/lib/service/servicedvbrecord.cpp
+++ b/lib/service/servicedvbrecord.cpp
@@ -10,6 +10,10 @@
 #include <netinet/in.h>
 
 
+#if defined(__sh__)
+#include <sys/vfs.h>
+#include <linux/magic.h>
+#endif
 DEFINE_REF(eDVBServiceRecord);
 
 eDVBServiceRecord::eDVBServiceRecord(const eServiceReferenceDVB &ref, bool isstreamclient): m_ref(ref)
@@ -303,9 +307,43 @@ int eDVBServiceRecord::doRecord()
 
 	if (!m_record && m_tuned && !m_streaming && !m_simulate)
 	{
+#if defined(__sh__)
+		int flags = O_WRONLY|O_CREAT|O_LARGEFILE;
+		struct statfs sbuf;
+#endif
 		eDebug("Recording to %s...", m_filename.c_str());
 		::remove(m_filename.c_str());
+#if defined(__sh__)
+		//we must creat a file for statfs
 		int fd = ::open(m_filename.c_str(), O_WRONLY|O_CREAT|O_LARGEFILE, 0666);
+		::close(fd);
+		if (statfs(m_filename.c_str(), &sbuf) < 0)
+		{
+			eDebug("eDVBServiceRecord - can't get fs type assuming none NFS!");
+		} else
+		{
+			if (sbuf.f_type == EXT3_SUPER_MAGIC)
+				eDebug("eDVBServiceRecord - Ext2/3/4 Filesystem\n");
+			else
+			if (sbuf.f_type == NFS_SUPER_MAGIC)
+			{
+				eDebug("eDVBServiceRecord - NFS Filesystem; add O_DIRECT to flags\n");
+				flags |= O_DIRECT;
+			}
+			else
+			if (sbuf.f_type == USBDEVICE_SUPER_MAGIC)
+				eDebug("eDVBServiceRecord - USB Device\n");
+			else
+			if (sbuf.f_type == SMB_SUPER_MAGIC)
+				eDebug("eDVBServiceRecord - SMBs Device\n");
+			else 
+			if (sbuf.f_type == MSDOS_SUPER_MAGIC)
+				eDebug("eDVBServiceRecord - MSDOS Device\n");
+		}
+		fd = ::open(m_filename.c_str(), flags, 0644);
+#else
+		int fd = ::open(m_filename.c_str(), O_WRONLY|O_CREAT|O_LARGEFILE, 0644);
+#endif
 		if (fd == -1)
 		{
 			eDebug("eDVBServiceRecord - can't open recording file!");
diff --git a/lib/service/serviceeplayer3.cpp b/lib/service/serviceeplayer3.cpp
new file mode 100644
index 0000000..a05070a
--- /dev/null
+++ b/lib/service/serviceeplayer3.cpp
@@ -0,0 +1,1157 @@
+	/* note: this requires gstreamer 0.10.x and a big list of plugins. */
+	/* it's currently hardcoded to use a big-endian alsasink as sink. */
+#include <lib/base/ebase.h>
+#include <lib/base/eerror.h>
+#include <lib/base/init_num.h>
+#include <lib/base/init.h>
+#include <lib/base/nconfig.h>
+#include <lib/base/object.h>
+#include <lib/dvb/decoder.h>
+#include <lib/components/file_eraser.h>
+#include <lib/gui/esubtitle.h>
+#include <lib/service/serviceeplayer3.h>
+#include <lib/service/service.h>
+#include <lib/gdi/gpixmap.h>
+
+#include <string>
+#include <sys/stat.h>
+
+#define HTTP_TIMEOUT 60
+
+typedef enum
+{
+	GST_PLAY_FLAG_VIDEO         = 0x00000001,
+	GST_PLAY_FLAG_AUDIO         = 0x00000002,
+	GST_PLAY_FLAG_TEXT          = 0x00000004,
+	GST_PLAY_FLAG_VIS           = 0x00000008,
+	GST_PLAY_FLAG_SOFT_VOLUME   = 0x00000010,
+	GST_PLAY_FLAG_NATIVE_AUDIO  = 0x00000020,
+	GST_PLAY_FLAG_NATIVE_VIDEO  = 0x00000040,
+	GST_PLAY_FLAG_DOWNLOAD      = 0x00000080,
+	GST_PLAY_FLAG_BUFFERING     = 0x00000100
+} GstPlayFlags;
+
+// eServiceFactoryEPlayer3
+
+/*
+ * gstreamer suffers from a bug causing sparse streams to loose sync, after pause/resume / skip
+ * see: https://bugzilla.gnome.org/show_bug.cgi?id=619434
+ * As a workaround, we run the subsink in sync=false mode
+ */
+#define GSTREAMER_SUBTITLE_SYNC_MODE_BUG
+/**/
+
+void ep3Blit(){
+	fbClass *fb = fbClass::getInstance();
+	fb->blit();
+}
+
+
+eServiceFactoryEPlayer3::eServiceFactoryEPlayer3()
+{
+	ePtr<eServiceCenter> sc;
+
+	eServiceCenter::getPrivInstance(sc);
+	if (sc)
+	{
+		std::list<std::string> extensions;
+		//extensions.push_back("dts");
+		//extensions.push_back("mp2");
+		//extensions.push_back("mp3");
+		//extensions.push_back("ogg");
+		//extensions.push_back("ogm");
+		//extensions.push_back("ogv");
+		extensions.push_back("mpg");
+		extensions.push_back("vob");
+		//extensions.push_back("wav");
+		//extensions.push_back("wave");
+		extensions.push_back("m4v");
+		extensions.push_back("mkv");
+		extensions.push_back("avi");
+		extensions.push_back("divx");
+		extensions.push_back("dat");
+		//extensions.push_back("flac");
+		//extensions.push_back("flv");
+		extensions.push_back("mp4");
+		extensions.push_back("mov");
+		//extensions.push_back("m4a");
+		//extensions.push_back("3gp");
+		//extensions.push_back("3g2");
+		//extensions.push_back("asf");
+#if defined(__sh__)
+		extensions.push_back("mpeg");
+		extensions.push_back("m2ts");
+		extensions.push_back("trp");
+		extensions.push_back("vdr");
+		extensions.push_back("mts");
+		extensions.push_back("rar");
+		extensions.push_back("img");
+		extensions.push_back("iso");
+		extensions.push_back("ifo");
+		extensions.push_back("wmv");
+#endif
+		//extensions.push_back("wma");
+		sc->addServiceFactory(eServiceFactoryEPlayer3::id, this, extensions);
+	}
+
+	m_service_info = new eStaticServiceEPlayer3Info();
+}
+
+eServiceFactoryEPlayer3::~eServiceFactoryEPlayer3()
+{
+	ePtr<eServiceCenter> sc;
+
+	eServiceCenter::getPrivInstance(sc);
+	if (sc)
+		sc->removeServiceFactory(eServiceFactoryEPlayer3::id);
+}
+
+DEFINE_REF(eServiceFactoryEPlayer3)
+
+	// iServiceHandler
+RESULT eServiceFactoryEPlayer3::play(const eServiceReference &ref, ePtr<iPlayableService> &ptr)
+{
+		// check resources...
+	ptr = new eServiceEPlayer3(ref);
+	return 0;
+}
+
+RESULT eServiceFactoryEPlayer3::record(const eServiceReference &ref, ePtr<iRecordableService> &ptr)
+{
+	ptr=0;
+	return -1;
+}
+
+RESULT eServiceFactoryEPlayer3::list(const eServiceReference &, ePtr<iListableService> &ptr)
+{
+	ptr=0;
+	return -1;
+}
+
+RESULT eServiceFactoryEPlayer3::info(const eServiceReference &ref, ePtr<iStaticServiceInformation> &ptr)
+{
+	ptr = m_service_info;
+	return 0;
+}
+
+class eEPlayer3ServiceOfflineOperations: public iServiceOfflineOperations
+{
+	DECLARE_REF(eEPlayer3ServiceOfflineOperations);
+	eServiceReference m_ref;
+public:
+	eEPlayer3ServiceOfflineOperations(const eServiceReference &ref);
+
+	RESULT deleteFromDisk(int simulate);
+	RESULT getListOfFilenames(std::list<std::string> &);
+	RESULT reindex();
+};
+
+DEFINE_REF(eEPlayer3ServiceOfflineOperations);
+
+eEPlayer3ServiceOfflineOperations::eEPlayer3ServiceOfflineOperations(const eServiceReference &ref): m_ref((const eServiceReference&)ref)
+{
+}
+
+RESULT eEPlayer3ServiceOfflineOperations::deleteFromDisk(int simulate)
+{
+	if (!simulate)
+	{
+		std::list<std::string> res;
+		if (getListOfFilenames(res))
+			return -1;
+
+		eBackgroundFileEraser *eraser = eBackgroundFileEraser::getInstance();
+		if (!eraser)
+			eDebug("FATAL !! can't get background file eraser");
+
+		for (std::list<std::string>::iterator i(res.begin()); i != res.end(); ++i)
+		{
+			eDebug("Removing %s...", i->c_str());
+			if (eraser)
+				eraser->erase(i->c_str());
+			else
+				::unlink(i->c_str());
+		}
+	}
+	return 0;
+}
+
+RESULT eEPlayer3ServiceOfflineOperations::getListOfFilenames(std::list<std::string> &res)
+{
+	res.clear();
+	res.push_back(m_ref.path);
+	return 0;
+}
+
+RESULT eEPlayer3ServiceOfflineOperations::reindex()
+{
+	return -1;
+}
+
+
+RESULT eServiceFactoryEPlayer3::offlineOperations(const eServiceReference &ref, ePtr<iServiceOfflineOperations> &ptr)
+{
+	ptr = new eEPlayer3ServiceOfflineOperations(ref);
+	return 0;
+}
+
+// eStaticServiceEPlayer3Info
+
+
+// eStaticServiceEPlayer3Info is seperated from eServiceEPlayer3 to give information
+// about unopened files.
+
+// probably eServiceEPlayer3 should use this class as well, and eStaticServiceEPlayer3Info
+// should have a database backend where ID3-files etc. are cached.
+// this would allow listing the mp3 database based on certain filters.
+
+DEFINE_REF(eStaticServiceEPlayer3Info)
+
+eStaticServiceEPlayer3Info::eStaticServiceEPlayer3Info()
+{
+}
+
+RESULT eStaticServiceEPlayer3Info::getName(const eServiceReference &ref, std::string &name)
+{
+	if ( ref.name.length() )
+		name = ref.name;
+	else
+	{
+		size_t last = ref.path.rfind('/');
+		if (last != std::string::npos)
+			name = ref.path.substr(last+1);
+		else
+			name = ref.path;
+	}
+	return 0;
+}
+
+int eStaticServiceEPlayer3Info::getLength(const eServiceReference &ref)
+{
+	return -1;
+}
+
+int eStaticServiceEPlayer3Info::getInfo(const eServiceReference &ref, int w)
+{
+	switch (w)
+	{
+	case iServiceInformation::sTimeCreate:
+		{
+			struct stat s;
+			if (stat(ref.path.c_str(), &s) == 0)
+			{
+				return s.st_mtime;
+			}
+		}
+		break;
+	case iServiceInformation::sFileSize:
+		{
+			struct stat s;
+			if (stat(ref.path.c_str(), &s) == 0)
+			{
+				return s.st_size;
+			}
+		}
+		break;
+	}
+	return iServiceInformation::resNA;
+}
+
+long long eStaticServiceEPlayer3Info::getFileSize(const eServiceReference &ref)
+{
+	struct stat s;
+	if (stat(ref.path.c_str(), &s) == 0)
+	{
+		return s.st_size;
+	}
+	return 0;
+}
+
+DEFINE_REF(eStreamBufferEPlayer3Info)
+
+eStreamBufferEPlayer3Info::eStreamBufferEPlayer3Info(int percentage, int inputrate, int outputrate, int space, int size)
+: bufferPercentage(percentage),
+	inputRate(inputrate),
+	outputRate(outputrate),
+	bufferSpace(space),
+	bufferSize(size)
+{
+}
+
+int eStreamBufferEPlayer3Info::getBufferPercentage() const
+{
+	return bufferPercentage;
+}
+
+int eStreamBufferEPlayer3Info::getAverageInputRate() const
+{
+	return inputRate;
+}
+
+int eStreamBufferEPlayer3Info::getAverageOutputRate() const
+{
+	return outputRate;
+}
+
+int eStreamBufferEPlayer3Info::getBufferSpace() const
+{
+	return bufferSpace;
+}
+
+int eStreamBufferEPlayer3Info::getBufferSize() const
+{
+	return bufferSize;
+}
+
+// eServiceEPlayer3
+int eServiceEPlayer3::ac3_delay = 0,
+    eServiceEPlayer3::pcm_delay = 0;
+
+eServiceEPlayer3::eServiceEPlayer3(eServiceReference ref)
+	:m_ref(ref), m_pump(eApp, 1)
+{
+	m_subtitle_sync_timer = eTimer::create(eApp);
+	m_streamingsrc_timeout = 0;
+
+	m_currentAudioStream = -1;
+	m_currentSubtitleStream = -1;
+	m_cachedSubtitleStream = 0; /* report the first subtitle stream to be 'cached'. TODO: use an actual cache. */
+	m_subtitle_widget = 0;
+	m_currentTrickRatio = 1.0;
+	m_buffer_size = 8 * 1024 * 1024;
+
+	m_prev_decoder_time = -1;
+	m_decoder_time_valid_state = 0;
+	m_errorInfo.missing_codec = "";
+
+
+	CONNECT(m_subtitle_sync_timer->timeout, eServiceEPlayer3::pushSubtitles);
+
+	m_aspect = m_width = m_height = m_framerate = m_progressive = -1;
+
+	m_state = stIdle;
+	eDebug("eServiceEPlayer3::construct!");
+
+	const char *filename = m_ref.path.c_str();
+	const char *ext = strrchr(filename, '.');
+	if (!ext)
+		ext = filename + strlen(filename);
+
+	player = (Context_t*) malloc(sizeof(Context_t));
+
+	if (player)
+	{
+		player->playback  = &PlaybackHandler;
+		player->output    = &OutputHandler;
+		player->container = &ContainerHandler;
+		player->manager   = &ManagerHandler;
+		printf("%s\n", player->output->Name);
+	}
+
+	//Registration of output devices
+	if (player && player->output)
+	{
+		player->output->Command(player,OUTPUT_ADD, (void*)"audio");
+		player->output->Command(player,OUTPUT_ADD, (void*)"video");
+		player->output->Command(player,OUTPUT_ADD, (void*)"subtitle");
+	}
+
+	if (player && player->output && player->output->subtitle)
+	{
+		fbClass *fb = fbClass::getInstance();
+		SubtitleOutputDef_t out;
+		out.screen_width = fb->getScreenResX();
+		out.screen_height = fb->getScreenResY();
+		out.shareFramebuffer = 1;
+		out.framebufferFD = fb->getFD();
+		out.destination = fb->getLFB_Direct();
+		out.destStride = fb->Stride();
+		out.framebufferBlit = ep3Blit;
+		player->output->subtitle->Command(player, (OutputCmd_t)OUTPUT_SET_SUBTITLE_OUTPUT, (void*) &out);
+	}
+
+	//create playback path
+	char file[800] = {""};
+
+	if (!strncmp("http://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("rtsp://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("rtmp://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("rtmpe://", m_ref.path.c_str(), 8))
+		;
+	else if (!strncmp("rtmpt://", m_ref.path.c_str(), 8))
+		;
+	else if (!strncmp("rtmps://", m_ref.path.c_str(), 8))
+		;
+	else if (!strncmp("rtmpte://", m_ref.path.c_str(), 9))
+		;
+	else if (!strncmp("rtp://", m_ref.path.c_str(), 6))
+		;
+	else if (!strncmp("upnp://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("mms://", m_ref.path.c_str(), 6))
+		;
+	else if (!strncmp("file://", m_ref.path.c_str(), 7))
+		;
+	else
+		strcat(file, "file://");
+	strcat(file, m_ref.path.c_str());
+
+	//try to open file
+	if (player && player->playback && player->playback->Command(player, PLAYBACK_OPEN, file) >= 0)
+	{
+		//VIDEO
+		//We dont have to register video tracks, or do we ?
+		//AUDIO
+		if (player && player->manager && player->manager->audio)
+		{
+			char ** TrackList = NULL;
+			player->manager->audio->Command(player, MANAGER_LIST, &TrackList);
+			if (TrackList != NULL)
+			{
+				printf("AudioTrack List\n");
+				int i = 0;
+				for (i = 0; TrackList[i] != NULL; i+=2)
+				{
+					printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
+					audioStream audio;
+					audio.language_code = TrackList[i];
+
+					// atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC
+					if (    !strncmp("A_MPEG/L3",   TrackList[i+1], 9))
+						audio.type = atMP3;
+					else if (!strncmp("A_MP3",      TrackList[i+1], 5))
+						audio.type = atMP3;
+					else if (!strncmp("A_AC3",      TrackList[i+1], 5))
+						audio.type = atAC3;
+					else if (!strncmp("A_DTS",      TrackList[i+1], 5))
+						audio.type = atDTS;
+					else if (!strncmp("A_AAC",      TrackList[i+1], 5))
+						audio.type = atAAC;
+					else if (!strncmp("A_PCM",      TrackList[i+1], 5))
+						audio.type = atPCM;
+					else if (!strncmp("A_VORBIS",   TrackList[i+1], 8))
+						audio.type = atOGG;
+					else if (!strncmp("A_FLAC",     TrackList[i+1], 6))
+						audio.type = atFLAC;
+					else
+						audio.type = atUnknown;
+
+					m_audioStreams.push_back(audio);
+					free(TrackList[i]);
+					free(TrackList[i+1]);
+				}
+				free(TrackList);
+			}
+		}
+		//SUB
+		if (player && player->manager && player->manager->subtitle)
+		{
+			char ** TrackList = NULL;
+			player->manager->subtitle->Command(player, MANAGER_LIST, &TrackList);
+			if (TrackList != NULL)
+			{
+				printf("SubtitleTrack List\n");
+				int i = 0;
+				for (i = 0; TrackList[i] != NULL; i+=2)
+				{
+					printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
+					subtitleStream sub;
+					sub.language_code = TrackList[i];
+					//  stPlainText, stSSA, stSRT
+					if (    !strncmp("S_TEXT/SSA",   TrackList[i+1], 10) ||
+							!strncmp("S_SSA", TrackList[i+1], 5))
+						sub.type = stSSA;
+					else if (!strncmp("S_TEXT/ASS",   TrackList[i+1], 10) ||
+							!strncmp("S_AAS", TrackList[i+1], 5))
+						sub.type = stSSA;
+					else if (!strncmp("S_TEXT/SRT",   TrackList[i+1], 10) ||
+							!strncmp("S_SRT", TrackList[i+1], 5))
+						sub.type = stSRT;
+					else
+						sub.type = stPlainText;
+
+					m_subtitleStreams.push_back(sub);
+					free(TrackList[i]);
+					free(TrackList[i+1]);
+				}
+				free(TrackList);
+			}
+		}
+		m_event(this, evStart);
+	}
+	else
+	{
+		//Creation failed, no playback support for insert file, so delete playback context
+		//FIXME: How to tell e2 that we failed?
+		if (player && player->output)
+		{
+			player->output->Command(player,OUTPUT_DEL, (void*)"audio");
+			player->output->Command(player,OUTPUT_DEL, (void*)"video");
+			player->output->Command(player,OUTPUT_DEL, (void*)"subtitle");
+		}
+
+		if (player && player->playback)
+			player->playback->Command(player,PLAYBACK_CLOSE, NULL);
+
+		if (player)
+			free(player);
+		player = NULL;
+	}
+	//m_state = stRunning;
+	eDebug("eServiceEPlayer3-<\n");
+}
+
+eServiceEPlayer3::~eServiceEPlayer3()
+{
+	if (m_subtitle_widget) m_subtitle_widget->destroy();
+	m_subtitle_widget = 0;
+
+	if (m_state == stRunning)
+		stop();
+}
+
+DEFINE_REF(eServiceEPlayer3);
+
+RESULT eServiceEPlayer3::connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
+{
+	connection = new eConnection((iPlayableService*)this, m_event.connect(event));
+	m_event(this, evSeekableStatusChanged);
+	return 0;
+}
+
+RESULT eServiceEPlayer3::start()
+{
+	if (m_state != stIdle)
+	{
+		eDebug("eServiceEPlayer3::%s < m_state != stIdle", __func__);
+		return -1;
+	}
+
+	m_state = stRunning;
+
+	if (player && player->output && player->playback)
+	{
+		player->output->Command(player, OUTPUT_OPEN, NULL);
+		player->playback->Command(player, PLAYBACK_PLAY, NULL);
+	}
+
+	m_event(this, evStart);
+
+	return 0;
+}
+
+void eServiceEPlayer3::sourceTimeout()
+{
+	eDebug("eServiceEPlayer3::http source timeout! issuing eof...");
+	m_event((iPlayableService*)this, evEOF);
+}
+
+RESULT eServiceEPlayer3::stop()
+{
+	if (m_state == stIdle)
+	{
+		eDebug("eServiceEPlayer3::%s < m_state == stIdle", __func__);
+		return -1;
+	}
+
+	if (m_state == stStopped)
+		return -1;
+
+	eDebug("eServiceEPlayer3::stop %s", m_ref.path.c_str());
+
+	if (player && player->playback && player->output)
+	{
+		player->playback->Command(player, PLAYBACK_STOP, NULL);
+		player->output->Command(player, OUTPUT_CLOSE, NULL);
+	}
+
+	if (player && player->output)
+	{
+		player->output->Command(player,OUTPUT_DEL, (void*)"audio");
+		player->output->Command(player,OUTPUT_DEL, (void*)"video");
+		player->output->Command(player,OUTPUT_DEL, (void*)"subtitle");
+	}
+
+	if (player && player->playback)
+		player->playback->Command(player,PLAYBACK_CLOSE, NULL);
+
+	if (player)
+		free(player);
+
+	if (player != NULL)
+		player = NULL;
+
+	m_state = stStopped;
+
+	return 0;
+}
+
+RESULT eServiceEPlayer3::setTarget(int target)
+{
+	return -1;
+}
+
+RESULT eServiceEPlayer3::pause(ePtr<iPauseableService> &ptr)
+{
+	ptr=this;
+	return 0;
+}
+
+int speed_mapping[] =
+{
+ /* e2_ratio   speed */
+	2,         1,
+	4,         3,
+	8,         7,
+	16,        15,
+	32,        31,
+	64,        63,
+	128,      127,
+	-2,       -5,
+	-4,      -10,
+	-8,      -20,
+	-16,      -40,
+	-32,      -80,
+	-64,     -160,
+	-128,     -320,
+	-1,       -1
+};
+
+int getSpeed(int ratio)
+{
+	int i = 0;
+	while (speed_mapping[i] != -1)
+	{
+		if (speed_mapping[i] == ratio)
+			return speed_mapping[i+1];
+		i += 2;
+	}
+	return -1;
+}
+
+RESULT eServiceEPlayer3::setSlowMotion(int ratio)
+{
+// konfetti: in libeplayer3 we changed this because I dont like application specific stuff in a library
+	int speed = getSpeed(ratio);
+	if (player && player->playback && (speed != -1))
+	{
+		int result = 0;
+		if (ratio > 1)
+			result = player->playback->Command(player, PLAYBACK_SLOWMOTION, (void*)&speed);
+
+		if (result != 0)
+			return -1;
+	}
+	return 0;
+}
+
+RESULT eServiceEPlayer3::setFastForward(int ratio)
+{
+// konfetti: in libeplayer3 we changed this because I dont like application specific stuff in a library
+	int speed = getSpeed(ratio);
+	if (player && player->playback && (speed != -1))
+	{
+		int result = 0;
+		if (ratio > 1)
+			result = player->playback->Command(player, PLAYBACK_FASTFORWARD, (void*)&speed);
+		else if (ratio < -1)
+		{
+			//speed = speed * -1;
+			result = player->playback->Command(player, PLAYBACK_FASTBACKWARD, (void*)&speed);
+		}
+		else
+			result = player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+
+		if (result != 0)
+			return -1;
+	}
+	return 0;
+}
+
+		// iPausableService
+RESULT eServiceEPlayer3::pause()
+{
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_PAUSE, NULL);
+
+	return 0;
+}
+
+RESULT eServiceEPlayer3::unpause()
+{
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+
+	return 0;
+}
+
+	/* iSeekableService */
+RESULT eServiceEPlayer3::seek(ePtr<iSeekableService> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::getLength(pts_t &pts)
+{
+	double length = 0;
+
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_LENGTH, &length);
+
+	if (length <= 0)
+		return -1;
+
+	pts = length * 90000;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::seekToImpl(pts_t to)
+{
+	return 0;
+}
+
+RESULT eServiceEPlayer3::seekTo(pts_t to)
+{
+	RESULT ret = -1;
+
+	float pos = (to/90000.0)-10;
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SEEK, (void*)&pos);
+
+	ret =0;
+	return ret;
+}
+
+RESULT eServiceEPlayer3::seekRelative(int direction, pts_t to)
+{
+	pts_t ppos;
+	if (getPlayPosition(ppos) < 0) return -1;
+	ppos += to * direction;
+	if (ppos < 0)
+		ppos = 0;
+
+	float pos = direction*(to/90000.0);
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SEEK, (void*)&pos);
+
+	return 0;
+}
+
+RESULT eServiceEPlayer3::getPlayPosition(pts_t &pts)
+{
+	if (player && player->playback && !player->playback->isPlaying)
+	{
+		eDebug("eServiceEPlayer3::%s !!!!EOF!!!! < -1", __func__);
+		if(m_state == stRunning)
+			m_event((iPlayableService*)this, evEOF);
+		pts = 0;
+		return -1;
+	}
+
+	unsigned long long int vpts = 0;
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_PTS, &vpts);
+
+	if (vpts<=0)
+		return -1;
+
+	/* len is in nanoseconds. we have 90 000 pts per second. */
+	pts = vpts>0?vpts:pts;;
+
+	return 0;
+}
+
+RESULT eServiceEPlayer3::setTrickmode(int trick)
+{
+		/* trickmode is not yet supported by our dvbmediasinks. */
+	return -1;
+}
+
+RESULT eServiceEPlayer3::isCurrentlySeekable()
+{
+	return 3;
+}
+
+RESULT eServiceEPlayer3::info(ePtr<iServiceInformation>&i)
+{
+	i = this;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::getName(std::string &name)
+{
+	std::string title = m_ref.getName();
+	if (title.empty())
+	{
+		name = m_ref.path;
+		size_t n = name.rfind('/');
+		if (n != std::string::npos)
+			name = name.substr(n + 1);
+	}
+	else
+		name = title;
+	return 0;
+}
+
+int eServiceEPlayer3::getInfo(int w)
+{
+	switch (w)
+	{
+	case sServiceref: return m_ref;
+	case sVideoHeight: return m_height;
+	case sVideoWidth: return m_width;
+	case sFrameRate: return m_framerate;
+	case sProgressive: return m_progressive;
+	case sAspect: return m_aspect;
+	case sTagTitle:
+	case sTagArtist:
+	case sTagAlbum:
+	case sTagTitleSortname:
+	case sTagArtistSortname:
+	case sTagAlbumSortname:
+	case sTagDate:
+	case sTagComposer:
+	case sTagGenre:
+	case sTagComment:
+	case sTagExtendedComment:
+	case sTagLocation:
+	case sTagHomepage:
+	case sTagDescription:
+	case sTagVersion:
+	case sTagISRC:
+	case sTagOrganization:
+	case sTagCopyright:
+	case sTagCopyrightURI:
+	case sTagContact:
+	case sTagLicense:
+	case sTagLicenseURI:
+	case sTagCodec:
+	case sTagAudioCodec:
+	case sTagVideoCodec:
+	case sTagEncoder:
+	case sTagLanguageCode:
+	case sTagKeywords:
+	case sTagChannelMode:
+	case sUser+12:
+#if not defined(__sh__)
+		return resIsString;
+#endif
+	case sTagTrackGain:
+	case sTagTrackPeak:
+	case sTagAlbumGain:
+	case sTagAlbumPeak:
+	case sTagReferenceLevel:
+	case sTagBeatsPerMinute:
+	case sTagImage:
+	case sTagPreviewImage:
+	case sTagAttachment:
+		return resIsPyObject;
+	default:
+		return resNA;
+	}
+
+	return 0;
+}
+
+std::string eServiceEPlayer3::getInfoString(int w)
+{
+	char * tag = NULL;
+	char * res_str = NULL;
+	switch (w)
+	{
+	case sTagTitle:
+		tag = strdup("Title");
+		break;
+	case sTagArtist:
+		tag = strdup("Artist");
+		break;
+	case sTagAlbum:
+		tag = strdup("Album");
+		break;
+	case sTagComment:
+		tag = strdup("Comment");
+		break;
+	case sTagTrackNumber:
+		tag = strdup("Track");
+		break;
+	case sTagGenre:
+		tag = strdup("Genre");
+		break;
+	case sTagDate:
+		tag = strdup("Year");
+		break;
+	case sTagVideoCodec:
+		tag = strdup("VideoType");
+		break;
+	case sTagAudioCodec:
+		tag = strdup("AudioType");
+		break;
+	default:
+		return "";
+	}
+
+	if (player && player->playback)
+	{
+		/*Hellmaster1024: we need to save the adress of tag to free the strduped mem
+		  the command will retun a new adress for a new strduped string.
+		  Both Strings need to be freed! */
+		res_str = tag;
+		player->playback->Command(player, PLAYBACK_INFO, &res_str);
+		/* Hellmaster1024: in case something went wrong maybe no new adress is returned */
+		if (tag != res_str)
+		{
+			std::string res = res_str;
+			free(tag);
+			free(res_str);
+			return res;
+		}
+		else
+		{
+			free(tag);
+			return "";
+		}
+	}
+	free(tag);
+
+	return "";
+}
+
+RESULT eServiceEPlayer3::audioChannel(ePtr<iAudioChannelSelection> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::audioTracks(ePtr<iAudioTrackSelection> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::subtitle(ePtr<iSubtitleOutput> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+RESULT eServiceEPlayer3::audioDelay(ePtr<iAudioDelay> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+int eServiceEPlayer3::getNumberOfTracks()
+{
+ 	return m_audioStreams.size();
+}
+
+int eServiceEPlayer3::getCurrentTrack()
+{
+	return m_currentAudioStream;
+}
+
+RESULT eServiceEPlayer3::selectTrack(unsigned int i)
+{
+	int ret = selectAudioStream(i);
+
+	return ret;
+}
+
+int eServiceEPlayer3::selectAudioStream(int i)
+{
+	if (i != m_currentAudioStream)
+	{
+		if (player && player->playback)
+			player->playback->Command(player, PLAYBACK_SWITCH_AUDIO, (void*)&i);
+		m_currentAudioStream = i;
+		return 0;
+	}
+	return -1;
+}
+
+int eServiceEPlayer3::getCurrentChannel()
+{
+	return STEREO;
+}
+
+RESULT eServiceEPlayer3::selectChannel(int i)
+{
+	eDebug("eServiceEPlayer3::selectChannel(%i)",i);
+	return 0;
+}
+
+RESULT eServiceEPlayer3::getTrackInfo(struct iAudioTrackInfo &info, unsigned int i)
+{
+ 	if (i >= m_audioStreams.size())
+		return -2;
+
+	if (m_audioStreams[i].type == atMPEG)
+		info.m_description = "MPEG";
+	else if (m_audioStreams[i].type == atMP3)
+		info.m_description = "MP3";
+	else if (m_audioStreams[i].type == atAC3)
+		info.m_description = "AC3";
+	else if (m_audioStreams[i].type == atAAC)
+		info.m_description = "AAC";
+	else if (m_audioStreams[i].type == atDTS)
+		info.m_description = "DTS";
+	else if (m_audioStreams[i].type == atPCM)
+		info.m_description = "PCM";
+	else if (m_audioStreams[i].type == atOGG)
+		info.m_description = "OGG";
+
+	if (info.m_language.empty())
+		info.m_language = m_audioStreams[i].language_code;
+	return 0;
+}
+
+eAutoInitPtr<eServiceFactoryEPlayer3> init_eServiceFactoryEPlayer3(eAutoInitNumbers::service+1, "eServiceFactoryEPlayer3");
+
+void eServiceEPlayer3::eplayerCBsubtitleAvail(long int duration_ms, size_t len, char * buffer, void* user_data)
+{
+	eDebug("eServiceEPlayer3::%s >", __func__);
+	unsigned char tmp[len+1];
+	memcpy(tmp, buffer, len);
+	tmp[len] = 0;
+	eDebug("gstCBsubtitleAvail: %s", tmp);
+	eServiceEPlayer3 *_this = (eServiceEPlayer3*)user_data;
+	if ( _this->m_subtitle_widget )
+	{
+		ePangoSubtitlePage page;
+		gRGB rgbcol(0xD0,0xD0,0xD0);
+		page.m_elements.push_back(ePangoSubtitlePageElement(rgbcol, (const char*)tmp));
+		page.m_timeout = duration_ms;
+		(_this->m_subtitle_widget)->setPage(page);
+	}
+	eDebug("eServiceEPlayer3::%s <", __func__);
+}
+
+void eServiceEPlayer3::pushSubtitles()
+{
+}
+
+RESULT eServiceEPlayer3::enableSubtitles(iSubtitleUser *user, struct SubtitleTrack &track)
+{
+	if (m_currentSubtitleStream != track.pid)
+	{
+		m_subtitle_sync_timer->stop();
+		m_subtitle_pages.clear();
+		m_prev_decoder_time = -1;
+		m_decoder_time_valid_state = 0;
+
+		m_subtitle_widget = user;
+
+	}
+
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SWITCH_SUBTITLE, (void*)&track.pid);
+
+	return 0;
+}
+
+RESULT eServiceEPlayer3::disableSubtitles()
+{
+	eDebug("eServiceEPlayer3::disableSubtitles");
+
+	m_subtitle_sync_timer->stop();
+	m_subtitle_pages.clear();
+	m_prev_decoder_time = -1;
+	m_decoder_time_valid_state = 0;
+	if (m_subtitle_widget) m_subtitle_widget->destroy();
+	m_subtitle_widget = 0;
+
+	int pid = -1;
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SWITCH_SUBTITLE, (void*)&pid);
+
+	return 0;
+}
+
+RESULT eServiceEPlayer3::getCachedSubtitle(struct SubtitleTrack &track)
+{
+
+	bool autoturnon = eConfigManager::getConfigBoolValue("config.subtitles.pango_autoturnon", true);
+	if (!autoturnon)
+		return -1;
+
+	if (m_cachedSubtitleStream >= 0 && m_cachedSubtitleStream < (int)m_subtitleStreams.size())
+	{
+		track.type = 2;
+		track.pid = m_cachedSubtitleStream;
+		track.page_number = int(m_subtitleStreams[m_cachedSubtitleStream].type);
+		track.magazine_number = 0;
+		return 0;
+	}
+	return -1;
+}
+
+RESULT eServiceEPlayer3::getSubtitleList(std::vector<struct SubtitleTrack> &subtitlelist)
+{
+// 	eDebug("eServiceEPlayer3::getSubtitleList");
+	int stream_idx = 0;
+
+	for (std::vector<subtitleStream>::iterator IterSubtitleStream(m_subtitleStreams.begin()); IterSubtitleStream != m_subtitleStreams.end(); ++IterSubtitleStream)
+	{
+		subtype_t type = IterSubtitleStream->type;
+		switch(type)
+		{
+		case stUnknown:
+		case stVOB:
+		case stPGS:
+			break;
+		default:
+		{
+			struct SubtitleTrack track;
+			track.type = 2;
+			track.pid = stream_idx;
+			track.page_number = int(type);
+			track.magazine_number = 0;
+			track.language_code = IterSubtitleStream->language_code;
+			subtitlelist.push_back(track);
+		}
+		}
+		stream_idx++;
+	}
+	eDebug("eServiceEPlayer3::getSubtitleList finished");
+	return 0;
+}
+
+RESULT eServiceEPlayer3::streamed(ePtr<iStreamedService> &ptr)
+{
+	ptr = this;
+	return 0;
+}
+
+ePtr<iStreamBufferInfo> eServiceEPlayer3::getBufferCharge()
+{
+	return new eStreamBufferEPlayer3Info(m_bufferInfo.bufferPercent, m_bufferInfo.avgInRate, m_bufferInfo.avgOutRate, m_bufferInfo.bufferingLeft, m_buffer_size);
+}
+
+int eServiceEPlayer3::setBufferSize(int size)
+{
+	m_buffer_size = size;
+	return 0;
+}
+
+int eServiceEPlayer3::getAC3Delay()
+{
+	return ac3_delay;
+}
+
+int eServiceEPlayer3::getPCMDelay()
+{
+	return pcm_delay;
+}
+
+void eServiceEPlayer3::setAC3Delay(int delay)
+{
+
+}
+
+void eServiceEPlayer3::setPCMDelay(int delay)
+{
+}
diff --git a/lib/service/serviceeplayer3.h b/lib/service/serviceeplayer3.h
new file mode 100644
index 0000000..3c44792
--- /dev/null
+++ b/lib/service/serviceeplayer3.h
@@ -0,0 +1,301 @@
+#ifndef __serviceeplayer3_h
+#define __serviceeplayer3_h
+
+#include <lib/base/message.h>
+#include <lib/service/iservice.h>
+#include <lib/dvb/pmt.h>
+#include <lib/dvb/subtitle.h>
+#include <lib/dvb/teletext.h>
+
+#include <common.h>
+#include <subtitle.h>
+#define gint int
+#define gint64 int64_t
+extern OutputHandler_t		OutputHandler;
+extern PlaybackHandler_t	PlaybackHandler;
+extern ContainerHandler_t	ContainerHandler;
+extern ManagerHandler_t	ManagerHandler;
+
+/* for subtitles */
+#include <lib/gui/esubtitle.h>
+
+class eStaticServiceEPlayer3Info;
+
+class eServiceFactoryEPlayer3: public iServiceHandler
+{
+	DECLARE_REF(eServiceFactoryEPlayer3);
+public:
+	eServiceFactoryEPlayer3();
+	virtual ~eServiceFactoryEPlayer3();
+	enum { id = 0x1003 };
+
+		// iServiceHandler
+	RESULT play(const eServiceReference &, ePtr<iPlayableService> &ptr);
+	RESULT record(const eServiceReference &, ePtr<iRecordableService> &ptr);
+	RESULT list(const eServiceReference &, ePtr<iListableService> &ptr);
+	RESULT info(const eServiceReference &, ePtr<iStaticServiceInformation> &ptr);
+	RESULT offlineOperations(const eServiceReference &, ePtr<iServiceOfflineOperations> &ptr);
+private:
+	ePtr<eStaticServiceEPlayer3Info> m_service_info;
+};
+
+class eStaticServiceEPlayer3Info: public iStaticServiceInformation
+{
+	DECLARE_REF(eStaticServiceEPlayer3Info);
+	friend class eServiceFactoryEPlayer3;
+	eStaticServiceEPlayer3Info();
+public:
+	RESULT getName(const eServiceReference &ref, std::string &name);
+	int getLength(const eServiceReference &ref);
+	int getInfo(const eServiceReference &ref, int w);
+	int isPlayable(const eServiceReference &ref, const eServiceReference &ignore, bool simulate) { return 1; }
+	long long getFileSize(const eServiceReference &ref);
+};
+
+class eStreamBufferEPlayer3Info: public iStreamBufferInfo
+{
+	DECLARE_REF(eStreamBufferEPlayer3Info);
+	int bufferPercentage;
+	int inputRate;
+	int outputRate;
+	int bufferSpace;
+	int bufferSize;
+
+public:
+	eStreamBufferEPlayer3Info(int percentage, int inputrate, int outputrate, int space, int size);
+
+	int getBufferPercentage() const;
+	int getAverageInputRate() const;
+	int getAverageOutputRate() const;
+	int getBufferSpace() const;
+	int getBufferSize() const;
+};
+
+class eServiceEPlayer3InfoContainer: public iServiceInfoContainer
+{
+	DECLARE_REF(eServiceEPlayer3InfoContainer);
+
+	double doubleValue;
+
+
+	unsigned char *bufferData;
+	unsigned int bufferSize;
+
+public:
+	eServiceEPlayer3InfoContainer();
+	~eServiceEPlayer3InfoContainer();
+
+	double getDouble(unsigned int index) const;
+	unsigned char *getBuffer(unsigned int &size) const;
+
+	void setDouble(double value);
+};
+
+typedef enum { atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC, atWMA } audiotype_t;
+typedef enum { stUnknown, stPlainText, stSSA, stASS, stSRT, stVOB, stPGS } subtype_t;
+typedef enum { ctNone, ctMPEGTS, ctMPEGPS, ctMKV, ctAVI, ctMP4, ctVCD, ctCDA, ctASF, ctOGG } containertype_t;
+
+class eServiceEPlayer3: public iPlayableService, public iPauseableService,
+	public iServiceInformation, public iSeekableService, public iAudioTrackSelection, public iAudioChannelSelection, 
+	public iSubtitleOutput, public iStreamedService, public iAudioDelay, public Object
+{
+	DECLARE_REF(eServiceEPlayer3);
+public:
+	virtual ~eServiceEPlayer3();
+
+		// iPlayableService
+	RESULT connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection);
+	RESULT start();
+	RESULT stop();
+	RESULT setTarget(int target);
+	
+	RESULT pause(ePtr<iPauseableService> &ptr);
+	RESULT setSlowMotion(int ratio);
+	RESULT setFastForward(int ratio);
+
+	RESULT seek(ePtr<iSeekableService> &ptr);
+	RESULT audioTracks(ePtr<iAudioTrackSelection> &ptr);
+	RESULT audioChannel(ePtr<iAudioChannelSelection> &ptr);
+	RESULT subtitle(ePtr<iSubtitleOutput> &ptr);
+	RESULT audioDelay(ePtr<iAudioDelay> &ptr);
+
+		// not implemented (yet)
+	RESULT frontendInfo(ePtr<iFrontendInformation> &ptr) { ptr = 0; return -1; }
+	RESULT subServices(ePtr<iSubserviceList> &ptr) { ptr = 0; return -1; }
+	RESULT timeshift(ePtr<iTimeshiftService> &ptr) { ptr = 0; return -1; }
+	RESULT cueSheet(ePtr<iCueSheet> &ptr) { ptr = 0; return -1; }
+
+	RESULT rdsDecoder(ePtr<iRdsDecoder> &ptr) { ptr = 0; return -1; }
+	RESULT keys(ePtr<iServiceKeys> &ptr) { ptr = 0; return -1; }
+	RESULT stream(ePtr<iStreamableService> &ptr) { ptr = 0; return -1; }
+
+		// iPausableService
+	RESULT pause();
+	RESULT unpause();
+	
+	RESULT info(ePtr<iServiceInformation>&);
+	
+		// iSeekableService
+	RESULT getLength(pts_t &SWIG_OUTPUT);
+	RESULT seekTo(pts_t to);
+	RESULT seekRelative(int direction, pts_t to);
+	RESULT getPlayPosition(pts_t &SWIG_OUTPUT);
+	RESULT setTrickmode(int trick);
+	RESULT isCurrentlySeekable();
+
+		// iServiceInformation
+	RESULT getName(std::string &name);
+	int getInfo(int w);
+	std::string getInfoString(int w);
+
+		// iAudioTrackSelection	
+	int getNumberOfTracks();
+	RESULT selectTrack(unsigned int i);
+	RESULT getTrackInfo(struct iAudioTrackInfo &, unsigned int n);
+	int getCurrentTrack();
+
+		// iAudioChannelSelection	
+	int getCurrentChannel();
+	RESULT selectChannel(int i);
+
+		// iSubtitleOutput
+	RESULT enableSubtitles(iSubtitleUser *user, SubtitleTrack &track);
+	RESULT disableSubtitles();
+	RESULT getSubtitleList(std::vector<SubtitleTrack> &sublist);
+	RESULT getCachedSubtitle(SubtitleTrack &track);
+
+		// iStreamedService
+	RESULT streamed(ePtr<iStreamedService> &ptr);
+	ePtr<iStreamBufferInfo> getBufferCharge();
+	int setBufferSize(int size);
+
+		// iAudioDelay
+	int getAC3Delay();
+	int getPCMDelay();
+	void setAC3Delay(int);
+	void setPCMDelay(int);
+
+	struct audioStream
+	{
+		audiotype_t type;
+		std::string language_code; /* iso-639, if available. */
+		std::string codec; /* clear text codec description */
+		audioStream()
+			:type(atUnknown)
+		{
+		}
+	};
+	struct subtitleStream
+	{
+		subtype_t type;
+		std::string language_code; /* iso-639, if available. */
+		int id;
+		subtitleStream()
+		{
+		}
+	};
+	struct sourceStream
+	{
+		audiotype_t audiotype;
+		containertype_t containertype;
+		bool is_video;
+		bool is_streaming;
+		sourceStream()
+			:audiotype(atUnknown), containertype(ctNone), is_video(false), is_streaming(false)
+		{
+		}
+	};
+
+	struct bufferInfo
+	{
+		gint bufferPercent;
+		gint avgInRate;
+		gint avgOutRate;
+		gint64 bufferingLeft;
+		bufferInfo()
+			:bufferPercent(0), avgInRate(0), avgOutRate(0), bufferingLeft(-1)
+		{
+		}
+	};
+	struct errorInfo
+	{
+		std::string error_message;
+		std::string missing_codec;
+	};
+
+private:
+	static int pcm_delay;
+	static int ac3_delay;
+	int m_currentAudioStream;
+	int m_currentSubtitleStream;
+	int m_cachedSubtitleStream;
+	int selectAudioStream(int i);
+	std::vector<audioStream> m_audioStreams;
+	std::vector<subtitleStream> m_subtitleStreams;
+	iSubtitleUser *m_subtitle_widget;
+
+	int m_currentTrickRatio;
+
+	friend class eServiceFactoryEPlayer3;
+	eServiceReference m_ref;
+	int m_buffer_size;
+
+	bufferInfo m_bufferInfo;
+	errorInfo m_errorInfo;
+	std::string m_download_buffer_path;
+	eServiceEPlayer3(eServiceReference ref);
+	Signal2<void,iPlayableService*,int> m_event;
+	enum
+	{
+		stIdle, stRunning, stStopped,
+	};
+	int m_state;
+
+	Context_t * player;
+
+	struct Message
+	{
+		Message()
+			:type(-1)
+		{}
+		Message(int type)
+			:type(type)
+		{}
+		int type;
+	};
+	eFixedMessagePump<Message> m_pump;
+	static void eplayerCBsubtitleAvail(long int duration_ns, size_t len, char * buffer, void* user_data);
+
+	struct subtitle_page_t
+	{
+		uint32_t start_ms;
+		uint32_t end_ms;
+		std::string text;
+
+		subtitle_page_t(uint32_t start_ms_in, uint32_t end_ms_in, std::string text_in)
+			: start_ms(start_ms_in), end_ms(end_ms_in), text(text_in)
+		{
+		}
+	};
+
+	typedef std::map<uint32_t, subtitle_page_t> subtitle_pages_map_t;
+	typedef std::pair<uint32_t, subtitle_page_t> subtitle_pages_map_pair_t;
+	subtitle_pages_map_t m_subtitle_pages;
+	ePtr<eTimer> m_subtitle_sync_timer;
+	
+	ePtr<eTimer> m_streamingsrc_timeout;
+	pts_t m_prev_decoder_time;
+	int m_decoder_time_valid_state;
+
+	void pushSubtitles();
+
+	void sourceTimeout();
+	sourceStream m_sourceinfo;
+
+	RESULT seekToImpl(pts_t to);
+
+	gint m_aspect, m_width, m_height, m_framerate, m_progressive;
+	std::string m_useragent;
+};
+
+#endif
diff --git a/lib/service/servicemp3.cpp b/lib/service/servicemp3.cpp
index 231cbac..e1a6024 100644
--- a/lib/service/servicemp3.cpp
+++ b/lib/service/servicemp3.cpp
@@ -16,8 +16,10 @@
 
 #include <string>
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 #include <gst/gst.h>
 #include <gst/pbutils/missing-plugins.h>
+#endif
 #include <sys/stat.h>
 
 #define HTTP_TIMEOUT 30
@@ -61,6 +63,11 @@ typedef enum
 #define GSTREAMER_SUBTITLE_SYNC_MODE_BUG
 /**/
 
+void mp3Blit(){
+	fbClass *fb = fbClass::getInstance();
+	fb->blit();
+}
+
 eServiceFactoryMP3::eServiceFactoryMP3()
 {
 	ePtr<eServiceCenter> sc;
@@ -75,24 +82,49 @@ eServiceFactoryMP3::eServiceFactoryMP3()
 		extensions.push_back("ogg");
 		extensions.push_back("ogm");
 		extensions.push_back("ogv");
-		extensions.push_back("mpg");
-		extensions.push_back("vob");
 		extensions.push_back("wav");
 		extensions.push_back("wave");
+		extensions.push_back("flac");
+		extensions.push_back("flv");
+		extensions.push_back("m4a");
+		extensions.push_back("3gp");
+		extensions.push_back("3g2");
+		extensions.push_back("asf");
+#if defined(__sh__)
+#if !defined(ENABLE_MEDIAFWGSTREAMER) || !defined(ENABLE_LIBEPLAYER3)
+/* Hellmaster1024: if both gst and eplayer3 are enabled, this is the GST service!
+ * We only select the audio extensions (above), and leave the Video extensions for
+ * the ePlayer3 service located in serviceeplayer3
+ * If only one of GST and ePlayer3 this service handles all extensions and switches between
+ * GST and ePlayer3
+*/
 		extensions.push_back("m4v");
 		extensions.push_back("mkv");
 		extensions.push_back("avi");
 		extensions.push_back("divx");
 		extensions.push_back("dat");
-		extensions.push_back("flac");
-		extensions.push_back("flv");
+		extensions.push_back("mpg");
+		extensions.push_back("vob");
 		extensions.push_back("mp4");
 		extensions.push_back("mov");
-		extensions.push_back("m4a");
-		extensions.push_back("3gp");
-		extensions.push_back("3g2");
-		extensions.push_back("asf");
-		extensions.push_back("wmv");
+		extensions.push_back("mpeg");
+		extensions.push_back("m2ts");
+		extensions.push_back("trp");
+		extensions.push_back("vdr");
+		extensions.push_back("mts");
+		extensions.push_back("rar");
+		extensions.push_back("img");
+		extensions.push_back("iso");
+		extensions.push_back("ifo");
+		int fd = open("/proc/stb/info/model", O_RDONLY);
+		char tmp[255];
+		int rd = fd >= 0 ? read(fd, tmp, 255) : 0;
+		if (fd >= 0)
+			close(fd);
+		if (!strncmp(tmp, "ufs912\n", rd) || !strncmp(tmp, "ufs913\n", rd) || !strncmp(tmp, "atevio7500\n", rd) || !strncmp(tmp, "hs7110\n", rd) || !strncmp(tmp, "hs7810a\n", rd) || !strncmp(tmp, "spark7162\n", rd) || !strncmp(tmp, "whitebox\n", rd))
+			extensions.push_back("wmv");
+#endif
+#endif
 		extensions.push_back("wma");
 		sc->addServiceFactory(eServiceFactoryMP3::id, this, extensions);
 	}
@@ -319,6 +351,7 @@ int eStreamBufferInfo::getBufferSize() const
 	return bufferSize;
 }
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 DEFINE_REF(eServiceMP3InfoContainer);
 
 eServiceMP3InfoContainer::eServiceMP3InfoContainer()
@@ -369,6 +402,7 @@ void eServiceMP3InfoContainer::setBuffer(GstBuffer *buffer)
 	bufferSize = map.size;
 #endif
 }
+#endif
 
 // eServiceMP3
 int eServiceMP3::ac3_delay = 0,
@@ -381,13 +415,16 @@ eServiceMP3::eServiceMP3(eServiceReference ref):
 {
 	m_subtitle_sync_timer = eTimer::create(eApp);
 	m_streamingsrc_timeout = 0;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	m_stream_tags = 0;
+#endif
 	m_currentAudioStream = -1;
 	m_currentSubtitleStream = -1;
 	m_cachedSubtitleStream = 0; /* report the first subtitle stream to be 'cached'. TODO: use an actual cache. */
 	m_subtitle_widget = 0;
 	m_currentTrickRatio = 1.0;
 	m_buffer_size = 5 * 1024 * 1024;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	m_ignore_buffering_messages = 0;
 	m_is_live = false;
 	m_use_prefillbuffer = false;
@@ -395,13 +432,17 @@ eServiceMP3::eServiceMP3(eServiceReference ref):
 	m_seek_paused = false;
 	m_extra_headers = "";
 	m_download_buffer_path = "";
+#endif
 	m_prev_decoder_time = -1;
 	m_decoder_time_valid_state = 0;
 	m_errorInfo.missing_codec = "";
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	audioSink = videoSink = NULL;
-
+#endif
 	CONNECT(m_subtitle_sync_timer->timeout, eServiceMP3::pushSubtitles);
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	CONNECT(m_pump.recv_msg, eServiceMP3::gstPoll);
+#endif
 	CONNECT(m_nownext_timer->timeout, eServiceMP3::updateEpgCacheNowNext);
 	m_aspect = m_width = m_height = m_framerate = m_progressive = -1;
 
@@ -413,6 +454,7 @@ eServiceMP3::eServiceMP3(eServiceReference ref):
 	if (!ext)
 		ext = filename + strlen(filename);
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	m_sourceinfo.is_video = FALSE;
 	m_sourceinfo.audiotype = atUnknown;
 	if ( (strcasecmp(ext, ".mpeg") && strcasecmp(ext, ".mpg") && strcasecmp(ext, ".vob") && strcasecmp(ext, ".bin") && strcasecmp(ext, ".dat") ) == 0 )
@@ -594,10 +636,182 @@ eServiceMP3::eServiceMP3(eServiceReference ref):
 		eDebug("eServiceMP3::sorry, can't play: %s",m_errorInfo.error_message.c_str());
 	}
 	g_free(uri);
+#else
+	player = (Context_t*) malloc(sizeof(Context_t));
+
+	if (player)
+	{
+		player->playback  = &PlaybackHandler;
+		player->output    = &OutputHandler;
+		player->container = &ContainerHandler;
+		player->manager   = &ManagerHandler;
+		printf("%s\n", player->output->Name);
+	}
+
+	//Registration of output devices
+	if (player && player->output)
+	{
+		player->output->Command(player,OUTPUT_ADD, (void*)"audio");
+		player->output->Command(player,OUTPUT_ADD, (void*)"video");
+		player->output->Command(player,OUTPUT_ADD, (void*)"subtitle");
+	}
+
+	if (player && player->output && player->output->subtitle)
+	{
+		fbClass *fb = fbClass::getInstance();
+		SubtitleOutputDef_t out;
+		out.screen_width = fb->getScreenResX();
+		out.screen_height = fb->getScreenResY();
+		out.shareFramebuffer = 1;
+		out.framebufferFD = fb->getFD();
+		out.destination = fb->getLFB_Direct();
+		out.destStride = fb->Stride();
+		out.framebufferBlit = mp3Blit;
+		player->output->subtitle->Command(player, (OutputCmd_t)OUTPUT_SET_SUBTITLE_OUTPUT, (void*) &out);
+	}
+
+	//create playback path
+	char file[1023] = {""};
+
+	if (!strncmp("http://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("rtsp://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("rtmp://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("rtmpe://", m_ref.path.c_str(), 8))
+		;
+	else if (!strncmp("rtmpt://", m_ref.path.c_str(), 8))
+		;
+	else if (!strncmp("rtmps://", m_ref.path.c_str(), 8))
+		;
+	else if (!strncmp("rtmpte://", m_ref.path.c_str(), 9))
+		;
+	else if (!strncmp("rtp://", m_ref.path.c_str(), 6))
+		;
+	else if (!strncmp("upnp://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("mms://", m_ref.path.c_str(), 6))
+		;
+	else if (!strncmp("file://", m_ref.path.c_str(), 7))
+		;
+	else if (!strncmp("udp://", m_ref.path.c_str(), 6))
+		;
+	else if (!strncmp("bluray://", m_ref.path.c_str(), 9))
+		;
+	else
+		strcat(file, "file://");
+	strcat(file, m_ref.path.c_str());
+
+	//try to open file
+	if (player && player->playback && player->playback->Command(player, PLAYBACK_OPEN, file) >= 0)
+	{
+		//VIDEO
+		//We dont have to register video tracks, or do we ?
+		//AUDIO
+		if (player && player->manager && player->manager->audio)
+		{
+			char ** TrackList = NULL;
+			player->manager->audio->Command(player, MANAGER_LIST, &TrackList);
+			if (TrackList != NULL)
+			{
+				printf("AudioTrack List\n");
+				int i = 0;
+				for (i = 0; TrackList[i] != NULL; i+=2)
+				{
+					printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
+					audioStream audio;
+					audio.language_code = TrackList[i];
+
+					// atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC
+					if (    !strncmp("A_MPEG/L3",   TrackList[i+1], 9))
+						audio.type = atMP3;
+					else if (!strncmp("A_MP3",      TrackList[i+1], 5))
+						audio.type = atMP3;
+					else if (!strncmp("A_AC3",      TrackList[i+1], 5))
+						audio.type = atAC3;
+					else if (!strncmp("A_DTS",      TrackList[i+1], 5))
+						audio.type = atDTS;
+					else if (!strncmp("A_AAC",      TrackList[i+1], 5))
+						audio.type = atAAC;
+					else if (!strncmp("A_PCM",      TrackList[i+1], 5))
+						audio.type = atPCM;
+					else if (!strncmp("A_VORBIS",   TrackList[i+1], 8))
+						audio.type = atOGG;
+					else if (!strncmp("A_FLAC",     TrackList[i+1], 6))
+						audio.type = atFLAC;
+					else
+						audio.type = atUnknown;
+
+					m_audioStreams.push_back(audio);
+					free(TrackList[i]);
+					free(TrackList[i+1]);
+				}
+				free(TrackList);
+			}
+		}
+		//SUB
+		if (player && player->manager && player->manager->subtitle)
+		{
+			char ** TrackList = NULL;
+			player->manager->subtitle->Command(player, MANAGER_LIST, &TrackList);
+			if (TrackList != NULL)
+			{
+				printf("SubtitleTrack List\n");
+				int i = 0;
+				for (i = 0; TrackList[i] != NULL; i+=2)
+				{
+					printf("\t%s - %s\n", TrackList[i], TrackList[i+1]);
+					subtitleStream sub;
+					sub.language_code = TrackList[i];
+					//  stPlainText, stSSA, stSRT
+					if (    !strncmp("S_TEXT/SSA",   TrackList[i+1], 10) ||
+							!strncmp("S_SSA", TrackList[i+1], 5))
+						sub.type = stSSA;
+					else if (!strncmp("S_TEXT/ASS",   TrackList[i+1], 10) ||
+							!strncmp("S_AAS", TrackList[i+1], 5))
+						sub.type = stSSA;
+					else if (!strncmp("S_TEXT/SRT",   TrackList[i+1], 10) ||
+							!strncmp("S_SRT", TrackList[i+1], 5))
+						sub.type = stSRT;
+					else
+						sub.type = stPlainText;
+
+					m_subtitleStreams.push_back(sub);
+					free(TrackList[i]);
+					free(TrackList[i+1]);
+				}
+				free(TrackList);
+			}
+		}
+		m_event(this, evStart);
+	}
+	else
+	{
+		//Creation failed, no playback support for insert file, so delete playback context
+		//FIXME: How to tell e2 that we failed?
+		if (player && player->output)
+		{
+			player->output->Command(player,OUTPUT_DEL, (void*)"audio");
+			player->output->Command(player,OUTPUT_DEL, (void*)"video");
+			player->output->Command(player,OUTPUT_DEL, (void*)"subtitle");
+		}
+
+		if (player && player->playback)
+			player->playback->Command(player,PLAYBACK_CLOSE, NULL);
+
+		if (player)
+			free(player);
+		player = NULL;
+	}
+	//m_state = stRunning;
+	eDebug("eServiceMP3-<\n");
+#endif
 }
 
 eServiceMP3::~eServiceMP3()
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	// disconnect subtitle callback
 	GstElement *subsink = gst_bin_get_by_name(GST_BIN(m_gst_playbin), "subtitle_sink");
 
@@ -606,10 +820,12 @@ eServiceMP3::~eServiceMP3()
 		g_signal_handler_disconnect (subsink, m_subs_to_pull_handler_id);
 		gst_object_unref(subsink);
 	}
+#endif
 
 	if (m_subtitle_widget) m_subtitle_widget->destroy();
 	m_subtitle_widget = 0;
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (m_gst_playbin)
 	{
 		// disconnect sync handler callback
@@ -621,10 +837,12 @@ eServiceMP3::~eServiceMP3()
 #endif
 		gst_object_unref(bus);
 	}
+#endif
 
 	if (m_state == stRunning)
 		stop();
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (m_stream_tags)
 		gst_tag_list_free(m_stream_tags);
 
@@ -643,6 +861,7 @@ eServiceMP3::~eServiceMP3()
 		gst_object_unref (GST_OBJECT (m_gst_playbin));
 		eDebug("eServiceMP3::destruct!");
 	}
+#endif
 }
 
 void eServiceMP3::updateEpgCacheNowNext()
@@ -692,25 +911,47 @@ void eServiceMP3::updateEpgCacheNowNext()
 
 DEFINE_REF(eServiceMP3);
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 DEFINE_REF(eServiceMP3::GstMessageContainer);
+#endif
 
 RESULT eServiceMP3::connectEvent(const Slot2<void,iPlayableService*,int> &event, ePtr<eConnection> &connection)
 {
 	connection = new eConnection((iPlayableService*)this, m_event.connect(event));
+#ifdef ENABLE_MEDIAFWGSTREAMER
+#else
+	m_event(this, evSeekableStatusChanged);
+#endif
 	return 0;
 }
 
 RESULT eServiceMP3::start()
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	ASSERT(m_state == stIdle);
+#else
+	if (m_state != stIdle)
+	{
+		eDebug("eServiceMP3::%s < m_state != stIdle", __func__);
+		return -1;
+	}
+#endif
 
 	m_state = stRunning;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (m_gst_playbin)
 	{
 		eDebug("eServiceMP3::starting pipeline");
 		gst_element_set_state (m_gst_playbin, GST_STATE_PLAYING);
 		updateEpgCacheNowNext();
 	}
+#else
+	if (player && player->output && player->playback)
+	{
+		player->output->Command(player, OUTPUT_OPEN, NULL);
+		player->playback->Command(player, PLAYBACK_PLAY, NULL);
+	}
+#endif
 
 	m_event(this, evStart);
 
@@ -725,13 +966,45 @@ void eServiceMP3::sourceTimeout()
 
 RESULT eServiceMP3::stop()
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	ASSERT(m_state != stIdle);
+#else
+	if (m_state == stIdle)
+	{
+		eDebug("eServiceMP3::%s < m_state == stIdle", __func__);
+		return -1;
+	}
+#endif
 
 	if (m_state == stStopped)
 		return -1;
 
 	eDebug("eServiceMP3::stop %s", m_ref.path.c_str());
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	gst_element_set_state(m_gst_playbin, GST_STATE_NULL);
+#else
+	if (player && player->playback && player->output)
+	{
+		player->playback->Command(player, PLAYBACK_STOP, NULL);
+		player->output->Command(player, OUTPUT_CLOSE, NULL);
+	}
+
+	if (player && player->output)
+	{
+		player->output->Command(player,OUTPUT_DEL, (void*)"audio");
+		player->output->Command(player,OUTPUT_DEL, (void*)"video");
+		player->output->Command(player,OUTPUT_DEL, (void*)"subtitle");
+	}
+
+	if (player && player->playback)
+		player->playback->Command(player,PLAYBACK_CLOSE, NULL);
+
+	if (player)
+		free(player);
+
+	if (player != NULL)
+		player = NULL;
+#endif
 	m_state = stStopped;
 	m_nownext_timer->stop();
 	if (m_streamingsrc_timeout)
@@ -751,37 +1024,119 @@ RESULT eServiceMP3::pause(ePtr<iPauseableService> &ptr)
 	return 0;
 }
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
+#else
+int speed_mapping[] =
+{
+ /* e2_ratio   speed */
+	2,         1,
+	4,         3,
+	8,         7,
+	16,        15,
+	32,        31,
+	64,        63,
+	128,      127,
+	-2,       -5,
+	-4,      -10,
+	-8,      -20,
+	-16,      -40,
+	-32,      -80,
+	-64,     -160,
+	-128,     -320,
+	-1,       -1
+};
+
+int getSpeed(int ratio)
+{
+	int i = 0;
+	while (speed_mapping[i] != -1)
+	{
+		if (speed_mapping[i] == ratio)
+			return speed_mapping[i+1];
+		i += 2;
+	}
+	return -1;
+}
+#endif
+
 RESULT eServiceMP3::setSlowMotion(int ratio)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (!ratio)
 		return 0;
 	eDebug("eServiceMP3::setSlowMotion ratio=%f",1.0/(gdouble)ratio);
 	return trickSeek(1.0/(gdouble)ratio);
+#else
+// konfetti: in libeplayer3 we changed this because I dont like application specific stuff in a library
+	int speed = getSpeed(ratio);
+	if (player && player->playback && (speed != -1))
+	{
+		int result = 0;
+		if (ratio > 1)
+			result = player->playback->Command(player, PLAYBACK_SLOWMOTION, (void*)&speed);
+
+		if (result != 0)
+			return -1;
+	}
+	return 0;
+#endif
 }
 
 RESULT eServiceMP3::setFastForward(int ratio)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	eDebug("eServiceMP3::setFastForward ratio=%i",ratio);
 	return trickSeek(ratio);
+#else
+// konfetti: in libeplayer3 we changed this because I dont like application specific stuff in a library
+	int speed = getSpeed(ratio);
+	if (player && player->playback && (speed != -1))
+	{
+		int result = 0;
+		if (ratio > 1)
+			result = player->playback->Command(player, PLAYBACK_FASTFORWARD, (void*)&speed);
+		else if (ratio < -1)
+		{
+			//speed = speed * -1;
+			result = player->playback->Command(player, PLAYBACK_FASTBACKWARD, (void*)&speed);
+		}
+		else
+			result = player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+
+		if (result != 0)
+			return -1;
+	}
+	return 0;
+#endif
 }
 
 		// iPausableService
 RESULT eServiceMP3::pause()
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (!m_gst_playbin || m_state != stRunning)
 		return -1;
 
 	trickSeek(0.0);
+#else
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_PAUSE, NULL);
+#endif
 
 	return 0;
 }
 
 RESULT eServiceMP3::unpause()
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (!m_gst_playbin || m_state != stRunning)
 		return -1;
 
 	trickSeek(1.0);
+#else
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_CONTINUE, NULL);
+#endif
 
 	return 0;
 }
@@ -795,6 +1150,7 @@ RESULT eServiceMP3::seek(ePtr<iSeekableService> &ptr)
 
 RESULT eServiceMP3::getLength(pts_t &pts)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (!m_gst_playbin)
 		return -1;
 
@@ -812,11 +1168,23 @@ RESULT eServiceMP3::getLength(pts_t &pts)
 		/* len is in nanoseconds. we have 90 000 pts per second. */
 
 	pts = len / 11111LL;
+#else
+	double length = 0;
+
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_LENGTH, &length);
+
+	if (length <= 0)
+		return -1;
+
+	pts = length * 90000;
+#endif
 	return 0;
 }
 
 RESULT eServiceMP3::seekToImpl(pts_t to)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 		/* convert pts to nanoseconds */
 	gint64 time_nanoseconds = to * 11111LL;
 	if (!gst_element_seek (m_gst_playbin, m_currentTrickRatio, GST_FORMAT_TIME, (GstSeekFlags)(GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_KEY_UNIT),
@@ -827,12 +1195,13 @@ RESULT eServiceMP3::seekToImpl(pts_t to)
 		return -1;
 	}
 
+
 	if (m_paused)
 	{
 		m_seek_paused = true;
 		gst_element_set_state(m_gst_playbin, GST_STATE_PLAYING);
 	}
-
+#endif
 	return 0;
 }
 
@@ -840,17 +1209,25 @@ RESULT eServiceMP3::seekTo(pts_t to)
 {
 	RESULT ret = -1;
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (m_gst_playbin)
 	{
 		m_prev_decoder_time = -1;
 		m_decoder_time_valid_state = 0;
 		ret = seekToImpl(to);
 	}
+#else
+	float pos = (to/90000.0)-10;
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SEEK, (void*)&pos);
 
+	ret =0;
+#endif
 	return ret;
 }
 
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 RESULT eServiceMP3::trickSeek(gdouble ratio)
 {
 	if (!m_gst_playbin)
@@ -891,21 +1268,31 @@ RESULT eServiceMP3::trickSeek(gdouble ratio)
 	m_decoder_time_valid_state = 0;
 	return 0;
 }
-
+#endif
 
 RESULT eServiceMP3::seekRelative(int direction, pts_t to)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (!m_gst_playbin)
 		return -1;
-
+#endif
 	pts_t ppos;
 	if (getPlayPosition(ppos) < 0) return -1;
 	ppos += to * direction;
 	if (ppos < 0)
 		ppos = 0;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	return seekTo(ppos);
+#else
+	float pos = direction*(to/90000.0);
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SEEK, (void*)&pos);
+
+	return 0;
+#endif
 }
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 #if GST_VERSION_MAJOR < 1
 gint eServiceMP3::match_sinktype(GstElement *element, gpointer type)
 {
@@ -918,9 +1305,11 @@ gint eServiceMP3::match_sinktype(const GValue *velement, const gchar *type)
 	return strcmp(g_type_name(G_OBJECT_TYPE(element)), type);
 }
 #endif
+#endif
 
 RESULT eServiceMP3::getPlayPosition(pts_t &pts)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	gint64 pos;
 	pts = 0;
 
@@ -950,6 +1339,27 @@ RESULT eServiceMP3::getPlayPosition(pts_t &pts)
 
 	/* pos is in nanoseconds. we have 90 000 pts per second. */
 	pts = pos / 11111LL;
+#else
+	if (player && player->playback && !player->playback->isPlaying)
+	{
+		eDebug("eServiceMP3::%s !!!!EOF!!!! < -1", __func__);
+		if(m_state == stRunning)
+			m_event((iPlayableService*)this, evEOF);
+		pts = 0;
+		return -1;
+	}
+
+	unsigned long long int vpts = 0;
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_PTS, &vpts);
+
+	if (vpts<=0)
+		return -1;
+
+	/* len is in nanoseconds. we have 90 000 pts per second. */
+	pts = vpts>0?vpts:pts;;
+
+#endif
 	return 0;
 }
 
@@ -961,6 +1371,7 @@ RESULT eServiceMP3::setTrickmode(int trick)
 
 RESULT eServiceMP3::isCurrentlySeekable()
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER // Hellmaster1024: 1 for skipping 3 for skipping anf fast forward
 	int ret = 3; /* just assume that seeking and fast/slow winding are possible */
 
 	if (!m_gst_playbin)
@@ -969,6 +1380,9 @@ RESULT eServiceMP3::isCurrentlySeekable()
 		return 0;
 
 	return ret;
+#else
+	return 3;
+#endif
 }
 
 RESULT eServiceMP3::info(ePtr<iServiceInformation>&i)
@@ -1002,7 +1416,9 @@ RESULT eServiceMP3::getEvent(ePtr<eServiceEvent> &evt, int nownext)
 
 int eServiceMP3::getInfo(int w)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	const gchar *tag = 0;
+#endif
 
 	switch (w)
 	{
@@ -1042,7 +1458,9 @@ int eServiceMP3::getInfo(int w)
 	case sTagKeywords:
 	case sTagChannelMode:
 	case sUser+12:
+#if not defined(__sh__)
 		return resIsString;
+#endif
 	case sTagTrackGain:
 	case sTagTrackPeak:
 	case sTagAlbumGain:
@@ -1053,6 +1471,7 @@ int eServiceMP3::getInfo(int w)
 	case sTagPreviewImage:
 	case sTagAttachment:
 		return resIsPyObject;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	case sTagTrackNumber:
 		tag = GST_TAG_TRACK_NUMBER;
 		break;
@@ -1086,17 +1505,20 @@ int eServiceMP3::getInfo(int w)
 	case sTagCRC:
 		tag = "has-crc";
 		break;
+#endif
 	case sBuffer: return m_bufferInfo.bufferPercent;
 	default:
 		return resNA;
 	}
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (!m_stream_tags || !tag)
 		return 0;
 
 	guint value;
 	if (gst_tag_list_get_uint(m_stream_tags, tag, &value))
 		return (int) value;
+#endif
 
 	return 0;
 }
@@ -1121,6 +1543,7 @@ std::string eServiceMP3::getInfoString(int w)
 		}
 	}
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if ( !m_stream_tags && w < sUser && w > 26 )
 		return "";
 	const gchar *tag = 0;
@@ -1248,9 +1671,69 @@ std::string eServiceMP3::getInfoString(int w)
 		g_free(value);
 		return res;
 	}
+#else
+	char * tag = NULL;
+	char * res_str = NULL;
+	switch (w)
+	{
+	case sTagTitle:
+		tag = strdup("Title");
+		break;
+	case sTagArtist:
+		tag = strdup("Artist");
+		break;
+	case sTagAlbum:
+		tag = strdup("Album");
+		break;
+	case sTagComment:
+		tag = strdup("Comment");
+		break;
+	case sTagTrackNumber:
+		tag = strdup("Track");
+		break;
+	case sTagGenre:
+		tag = strdup("Genre");
+		break;
+	case sTagDate:
+		tag = strdup("Year");
+		break;
+	case sTagVideoCodec:
+		tag = strdup("VideoType");
+		break;
+	case sTagAudioCodec:
+		tag = strdup("AudioType");
+		break;
+	default:
+		return "";
+	}
+
+	if (player && player->playback)
+	{
+		/*Hellmaster1024: we need to save the adress of tag to free the strduped mem
+		  the command will retun a new adress for a new strduped string.
+		  Both Strings need to be freed! */
+		res_str = tag;
+		player->playback->Command(player, PLAYBACK_INFO, &res_str);
+		/* Hellmaster1024: in case something went wrong maybe no new adress is returned */
+		if (tag != res_str)
+		{
+			std::string res = res_str;
+			free(tag);
+			free(res_str);
+			return res;
+		}
+		else
+		{
+			free(tag);
+			return "";
+		}
+	}
+	free(tag);
+#endif
 	return "";
 }
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 ePtr<iServiceInfoContainer> eServiceMP3::getInfoObject(int w)
 {
 	eServiceMP3InfoContainer *container = new eServiceMP3InfoContainer;
@@ -1314,6 +1797,7 @@ ePtr<iServiceInfoContainer> eServiceMP3::getInfoObject(int w)
 	}
 	return retval;
 }
+#endif
 
 RESULT eServiceMP3::audioChannel(ePtr<iAudioChannelSelection> &ptr)
 {
@@ -1346,13 +1830,16 @@ int eServiceMP3::getNumberOfTracks()
 
 int eServiceMP3::getCurrentTrack()
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (m_currentAudioStream == -1)
 		g_object_get (G_OBJECT (m_gst_playbin), "current-audio", &m_currentAudioStream, NULL);
+#endif
 	return m_currentAudioStream;
 }
 
 RESULT eServiceMP3::selectTrack(unsigned int i)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	bool validposition = false;
 	pts_t ppos = 0;
 	if (getPlayPosition(ppos) >= 0)
@@ -1362,8 +1849,10 @@ RESULT eServiceMP3::selectTrack(unsigned int i)
 		if (ppos < 0)
 			ppos = 0;
 	}
+#endif
 
 	int ret = selectAudioStream(i);
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	if (!ret)
 	{
 		if (validposition)
@@ -1372,12 +1861,14 @@ RESULT eServiceMP3::selectTrack(unsigned int i)
 			seekTo(ppos);
 		}
 	}
+#endif
 
 	return ret;
 }
 
 int eServiceMP3::selectAudioStream(int i)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	int current_audio;
 	g_object_set (G_OBJECT (m_gst_playbin), "current-audio", i, NULL);
 	g_object_get (G_OBJECT (m_gst_playbin), "current-audio", &current_audio, NULL);
@@ -1388,6 +1879,16 @@ int eServiceMP3::selectAudioStream(int i)
 		return 0;
 	}
 	return -1;
+#else
+	if (i != m_currentAudioStream)
+	{
+		if (player && player->playback)
+			player->playback->Command(player, PLAYBACK_SWITCH_AUDIO, (void*)&i);
+		m_currentAudioStream = i;
+		return 0;
+	}
+	return -1;
+#endif
 }
 
 int eServiceMP3::getCurrentChannel()
@@ -1405,6 +1906,7 @@ RESULT eServiceMP3::getTrackInfo(struct iAudioTrackInfo &info, unsigned int i)
 {
  	if (i >= m_audioStreams.size())
 		return -2;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 		info.m_description = m_audioStreams[i].codec;
 /*	if (m_audioStreams[i].type == atMPEG)
 		info.m_description = "MPEG";
@@ -1424,11 +1926,28 @@ RESULT eServiceMP3::getTrackInfo(struct iAudioTrackInfo &info, unsigned int i)
 		info.m_description = "FLAC";
 	else
 		info.m_description = "???";*/
+#else
+	if (m_audioStreams[i].type == atMPEG)
+		info.m_description = "MPEG";
+	else if (m_audioStreams[i].type == atMP3)
+		info.m_description = "MP3";
+	else if (m_audioStreams[i].type == atAC3)
+		info.m_description = "AC3";
+	else if (m_audioStreams[i].type == atAAC)
+		info.m_description = "AAC";
+	else if (m_audioStreams[i].type == atDTS)
+		info.m_description = "DTS";
+	else if (m_audioStreams[i].type == atPCM)
+		info.m_description = "PCM";
+	else if (m_audioStreams[i].type == atOGG)
+		info.m_description = "OGG";
+#endif
 	if (info.m_language.empty())
 		info.m_language = m_audioStreams[i].language_code;
 	return 0;
 }
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 subtype_t getSubtitleType(GstPad* pad, gchar *g_codec=NULL)
 {
 	subtype_t type = stUnknown;
@@ -2171,9 +2690,11 @@ void eServiceMP3::gstPoll(ePtr<GstMessageContainer> const &msg)
 		}
 	}
 }
+#endif
 
 eAutoInitPtr<eServiceFactoryMP3> init_eServiceFactoryMP3(eAutoInitNumbers::service+1, "eServiceFactoryMP3");
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 void eServiceMP3::gstCBsubtitleAvail(GstElement *subsink, GstBuffer *buffer, gpointer user_data)
 {
 	eServiceMP3 *_this = (eServiceMP3*)user_data;
@@ -2301,9 +2822,30 @@ void eServiceMP3::pullSubtitle(GstBuffer *buffer)
 #endif
 	}
 }
+#else
+void eServiceMP3::eplayerCBsubtitleAvail(long int duration_ms, size_t len, char * buffer, void* user_data)
+{
+	eDebug("eServiceMP3::%s >", __func__);
+	unsigned char tmp[len+1];
+	memcpy(tmp, buffer, len);
+	tmp[len] = 0;
+	eDebug("gstCBsubtitleAvail: %s", tmp);
+	eServiceMP3 *_this = (eServiceMP3*)user_data;
+	if ( _this->m_subtitle_widget )
+	{
+		ePangoSubtitlePage page;
+		gRGB rgbcol(0xD0,0xD0,0xD0);
+		page.m_elements.push_back(ePangoSubtitlePageElement(rgbcol, (const char*)tmp));
+		page.m_timeout = duration_ms;
+		(_this->m_subtitle_widget)->setPage(page);
+	}
+	eDebug("eServiceMP3::%s <", __func__);
+}
+#endif
 
 void eServiceMP3::pushSubtitles()
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	pts_t running_pts = 0;
 	int32_t next_timer = 0, decoder_ms, start_ms, end_ms, diff_start_ms, diff_end_ms;
 	subtitle_pages_map_t::iterator current;
@@ -2406,23 +2948,27 @@ exit:
 	m_subtitle_sync_timer->start(next_timer, true);
 
 	//eDebug("\n\n");
+#endif
 }
 
 RESULT eServiceMP3::enableSubtitles(iSubtitleUser *user, struct SubtitleTrack &track)
 {
 	if (m_currentSubtitleStream != track.pid)
 	{
+#ifdef ENABLE_MEDIAFWGSTREAMER
 		g_object_set (G_OBJECT (m_gst_playbin), "current-text", -1, NULL);
+#endif
 		m_subtitle_sync_timer->stop();
 		m_subtitle_pages.clear();
 		m_prev_decoder_time = -1;
 		m_decoder_time_valid_state = 0;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 		m_currentSubtitleStream = track.pid;
 		m_cachedSubtitleStream = m_currentSubtitleStream;
 		g_object_set (G_OBJECT (m_gst_playbin), "current-text", m_currentSubtitleStream, NULL);
-
+#endif
 		m_subtitle_widget = user;
-
+#ifdef ENABLE_MEDIAFWGSTREAMER
 		eDebug ("eServiceMP3::switched to subtitle stream %i", m_currentSubtitleStream);
 
 #ifdef GSTREAMER_SUBTITLE_SYNC_MODE_BUG
@@ -2432,7 +2978,13 @@ RESULT eServiceMP3::enableSubtitles(iSubtitleUser *user, struct SubtitleTrack &t
 		 */
 		seekRelative(-1, 90000);
 #endif
+#endif
 	}
+#ifdef ENABLE_MEDIAFWGSTREAMER
+#else
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SWITCH_SUBTITLE, (void*)&track.pid);
+#endif
 
 	return 0;
 }
@@ -2440,15 +2992,23 @@ RESULT eServiceMP3::enableSubtitles(iSubtitleUser *user, struct SubtitleTrack &t
 RESULT eServiceMP3::disableSubtitles()
 {
 	eDebug("eServiceMP3::disableSubtitles");
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	m_currentSubtitleStream = -1;
 	m_cachedSubtitleStream = m_currentSubtitleStream;
 	g_object_set (G_OBJECT (m_gst_playbin), "current-text", m_currentSubtitleStream, NULL);
+#endif
 	m_subtitle_sync_timer->stop();
 	m_subtitle_pages.clear();
 	m_prev_decoder_time = -1;
 	m_decoder_time_valid_state = 0;
 	if (m_subtitle_widget) m_subtitle_widget->destroy();
 	m_subtitle_widget = 0;
+#ifdef ENABLE_MEDIAFWGSTREAMER
+#else
+	int pid = -1;
+	if (player && player->playback)
+		player->playback->Command(player, PLAYBACK_SWITCH_SUBTITLE, (void*)&pid);
+#endif
 	return 0;
 }
 
@@ -2515,7 +3075,9 @@ ePtr<iStreamBufferInfo> eServiceMP3::getBufferCharge()
 int eServiceMP3::setBufferSize(int size)
 {
 	m_buffer_size = size;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	g_object_set (G_OBJECT (m_gst_playbin), "buffer-size", m_buffer_size, NULL);
+#endif
 	return 0;
 }
 
@@ -2531,6 +3093,7 @@ int eServiceMP3::getPCMDelay()
 
 void eServiceMP3::setAC3Delay(int delay)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	ac3_delay = delay;
 	if (!m_gst_playbin || m_state != stRunning)
 		return;
@@ -2558,10 +3121,12 @@ void eServiceMP3::setAC3Delay(int delay)
 			eTSMPEGDecoder::setHwAC3Delay(config_delay_int);
 		}
 	}
+#endif
 }
 
 void eServiceMP3::setPCMDelay(int delay)
 {
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	pcm_delay = delay;
 	if (!m_gst_playbin || m_state != stRunning)
 		return;
@@ -2589,4 +3154,5 @@ void eServiceMP3::setPCMDelay(int delay)
 			eTSMPEGDecoder::setHwPCMDelay(config_delay_int);
 		}
 	}
+#endif
 }
diff --git a/lib/service/servicemp3.h b/lib/service/servicemp3.h
index b3a685e..3fe45e9 100644
--- a/lib/service/servicemp3.h
+++ b/lib/service/servicemp3.h
@@ -6,7 +6,18 @@
 #include <lib/dvb/pmt.h>
 #include <lib/dvb/subtitle.h>
 #include <lib/dvb/teletext.h>
+#ifdef ENABLE_MEDIAFWGSTREAMER
 #include <gst/gst.h>
+#else
+#include <libeplayer/common.h>
+#include <libeplayer/subtitle.h>
+#define gint int
+#define gint64 int64_t
+extern OutputHandler_t		OutputHandler;
+extern PlaybackHandler_t	PlaybackHandler;
+extern ContainerHandler_t	ContainerHandler;
+extern ManagerHandler_t	ManagerHandler;
+#endif
 /* for subtitles */
 #include <lib/gui/esubtitle.h>
 
@@ -68,7 +79,9 @@ class eServiceMP3InfoContainer: public iServiceInfoContainer
 	DECLARE_REF(eServiceMP3InfoContainer);
 
 	double doubleValue;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	GstBuffer *bufferValue;
+#endif
 
 	unsigned char *bufferData;
 	unsigned int bufferSize;
@@ -84,10 +97,14 @@ public:
 	unsigned char *getBuffer(unsigned int &size) const;
 
 	void setDouble(double value);
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	void setBuffer(GstBuffer *buffer);
+#endif
 };
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 typedef struct _GstElement GstElement;
+#endif
 
 typedef enum { atUnknown, atMPEG, atMP3, atAC3, atDTS, atAAC, atPCM, atOGG, atFLAC, atWMA } audiotype_t;
 typedef enum { stUnknown, stPlainText, stSSA, stASS, stSRT, stVOB, stPGS } subtype_t;
@@ -146,7 +163,9 @@ public:
 	RESULT getEvent(ePtr<eServiceEvent> &evt, int nownext);
 	int getInfo(int w);
 	std::string getInfoString(int w);
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	ePtr<iServiceInfoContainer> getInfoObject(int w);
+#endif
 
 		// iAudioTrackSelection
 	int getNumberOfTracks();
@@ -175,6 +194,7 @@ public:
 	void setAC3Delay(int);
 	void setPCMDelay(int);
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	struct audioStream
 	{
 		GstPad* pad;
@@ -207,6 +227,38 @@ public:
 		{
 		}
 	};
+#else
+	struct audioStream
+	{
+		audiotype_t type;
+		std::string language_code; /* iso-639, if available. */
+		std::string codec; /* clear text codec description */
+		audioStream()
+			:type(atUnknown)
+		{
+		}
+	};
+	struct subtitleStream
+	{
+		subtype_t type;
+		std::string language_code; /* iso-639, if available. */
+		int id;
+		subtitleStream()
+		{
+		}
+	};
+	struct sourceStream
+	{
+		audiotype_t audiotype;
+		containertype_t containertype;
+		bool is_video;
+		bool is_streaming;
+		sourceStream()
+			:audiotype(atUnknown), containertype(ctNone), is_video(false), is_streaming(false)
+		{
+		}
+	};
+#endif
 	struct bufferInfo
 	{
 		gint bufferPercent;
@@ -239,15 +291,21 @@ private:
 	std::vector<audioStream> m_audioStreams;
 	std::vector<subtitleStream> m_subtitleStreams;
 	iSubtitleUser *m_subtitle_widget;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	gdouble m_currentTrickRatio;
+#else
+	int m_currentTrickRatio;
+#endif
 	friend class eServiceFactoryMP3;
 	eServiceReference m_ref;
 	int m_buffer_size;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	int m_ignore_buffering_messages;
 	bool m_is_live;
 	bool m_use_prefillbuffer;
 	bool m_paused;
 	bool m_seek_paused;
+#endif
 	bufferInfo m_bufferInfo;
 	errorInfo m_errorInfo;
 	std::string m_download_buffer_path;
@@ -258,6 +316,7 @@ private:
 		stIdle, stRunning, stStopped,
 	};
 	int m_state;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	GstElement *m_gst_playbin, *audioSink, *videoSink;
 	GstTagList *m_stream_tags;
 
@@ -306,6 +365,22 @@ private:
 	static gint match_sinktype(const GValue *velement, const gchar *type);
 #endif
 	static void handleElementAdded(GstBin *bin, GstElement *element, gpointer user_data);
+#else
+	Context_t * player;
+
+	struct Message
+	{
+		Message()
+			:type(-1)
+		{}
+		Message(int type)
+			:type(type)
+		{}
+		int type;
+	};
+	eFixedMessagePump<Message> m_pump;
+	static void eplayerCBsubtitleAvail(long int duration_ns, size_t len, char * buffer, void* user_data);
+#endif
 
 	struct subtitle_page_t
 	{
@@ -329,17 +404,23 @@ private:
 	int m_decoder_time_valid_state;
 
 	void pushSubtitles();
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	void pullSubtitle(GstBuffer *buffer);
+#endif
 	void sourceTimeout();
 	sourceStream m_sourceinfo;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	gulong m_subs_to_pull_handler_id;
+#endif
 
 	RESULT seekToImpl(pts_t to);
 
 	gint m_aspect, m_width, m_height, m_framerate, m_progressive;
 	std::string m_useragent;
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	std::string m_extra_headers;
 	RESULT trickSeek(gdouble ratio);
+#endif
 };
 
 #endif
diff --git a/m4/ax_python_devel.m4 b/m4/ax_python_devel.m4
index a62b860..c6fb904 100644
--- a/m4/ax_python_devel.m4
+++ b/m4/ax_python_devel.m4
@@ -154,7 +154,7 @@ $ac_distutils_result])
 		python_path=`$PYTHON -c "import distutils.sysconfig; \
 			print (distutils.sysconfig.get_python_inc ());"`
 		if test -n "${python_path}"; then
-			python_path="-I$python_path"
+			python_path="-I$PY_PATH/include/python$PYTHON_VERSION"
 		fi
 		PYTHON_CPPFLAGS=$python_path
 	fi
@@ -235,7 +235,8 @@ EOD`
 			  "from distutils.sysconfig import get_python_lib as f; \
 			  import os; \
 			  print (os.path.join(f(plat_specific=1, standard_lib=1), 'config'));"`
-			PYTHON_LDFLAGS="-L$ac_python_libdir -lpython$ac_python_version"
+			PYTHON_LDFLAGS="-L$PY_PATH/include/python$PYTHON_VERSION -lpython$ac_python_version"
+#			PYTHON_LDFLAGS="-L$ac_python_libdir -lpython$ac_python_version"
 		fi
 
 		if test -z "PYTHON_LDFLAGS"; then
@@ -253,8 +254,9 @@ EOD`
 	#
 	AC_MSG_CHECKING([for Python site-packages path])
 	if test -z "$PYTHON_SITE_PKG"; then
-		PYTHON_SITE_PKG=`$PYTHON -c "import distutils.sysconfig; \
-			print (distutils.sysconfig.get_python_lib(0,0));"`
+		PYTHON_SITE_PKG="$PY_PATH/lib/python$PYTHON_VERSION/site-packages"
+#		PYTHON_SITE_PKG=`$PYTHON -c "import distutils.sysconfig; \
+#			print (distutils.sysconfig.get_python_lib(0,0));"`
 	fi
 	AC_MSG_RESULT([$PYTHON_SITE_PKG])
 	AC_SUBST([PYTHON_SITE_PKG])
diff --git a/main/Makefile.am b/main/Makefile.am
index 03121cc..42c7964 100644
--- a/main/Makefile.am
+++ b/main/Makefile.am
@@ -9,6 +9,8 @@ AM_CXXFLAGS = \
 
 bin_PROGRAMS = enigma2
 
+installdir = $(targetprefix)/usr/local/bin
+
 enigma2_SOURCES = \
 	bsod.cpp \
 	bsod.h \
@@ -53,6 +55,15 @@ enigma2_LDADD = \
 	@LIBDDVD_LIBS@ \
 	-ltuxtxt -ltuxtxt32bpp -lcrypt -lrt
 
+if ENABLE_LIBEPLAYER3
+enigma2_LDADD += \
+	-leplayer3
+endif
+
+if HAVE_GRAPHLCD
+enigma2_LDADD += -lglcddrivers -lglcdgraphics -lglcdskin
+endif
+
 enigma2_LDFLAGS = -Wl,--export-dynamic
 
 if HAVE_GIT_DIR
diff --git a/main/bsod.cpp b/main/bsod.cpp
index b62512e..b2981ed 100644
--- a/main/bsod.cpp
+++ b/main/bsod.cpp
@@ -17,8 +17,11 @@
 #include "version_info.h"
 
 /************************************************/
-
+#if defined(__sh__) // dont send mails to dm
+#define CRASH_EMAILADDR "somebody who cares"
+#else
 #define CRASH_EMAILADDR "forum at www.openpli.org"
+#endif
 #define INFOFILE "/maintainer.info"
 
 #define RINGBUFFER_SIZE 16384
diff --git a/main/enigma.cpp b/main/enigma.cpp
index 8fb7e61..6a4f831 100644
--- a/main/enigma.cpp
+++ b/main/enigma.cpp
@@ -30,10 +30,15 @@
 #include <lib/python/python.h>
 #include <lib/python/pythonconfig.h>
 
+#if defined(__sh__) // vfd class
+#include <lib/driver/vfd.h>
+#endif
 #include "bsod.h"
 #include "version_info.h"
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 #include <gst/gst.h>
+#endif
 
 #ifdef OBJECT_DEBUG
 int object_total_remaining;
@@ -136,7 +141,9 @@ int main(int argc, char **argv)
 	atexit(object_dump);
 #endif
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 	gst_init(&argc, &argv);
+#endif
 
 	// set pythonpath if unset
 	setenv("PYTHONPATH", eEnv::resolve("${libdir}/enigma2/python").c_str(), 0);
@@ -170,7 +177,11 @@ int main(int argc, char **argv)
 	eWidgetDesktop dsk_lcd(my_lcd_dc->size());
 
 	dsk.setStyleID(0);
+#ifdef HAVE_GRAPHLCD
+	dsk_lcd.setStyleID(my_lcd_dc->size().width() == 320 ? 1 : 2);
+#else
 	dsk_lcd.setStyleID(my_lcd_dc->size().width() == 96 ? 2 : 1);
+#endif
 
 /*	if (double_buffer)
 	{
@@ -225,6 +236,12 @@ int main(int argc, char **argv)
 
 	eRCInput::getInstance()->keyEvent.connect(slot(keyEvent));
 
+#if defined(__sh__) // initialise the vfd class
+	evfd * vfd = new evfd;
+	vfd->init();
+	delete vfd;
+#endif
+
 	printf("executing main\n");
 
 	bsodCatchSignals();
@@ -323,10 +340,12 @@ const char *getBoxType()
 	return BOXTYPE;
 }
 
+#ifdef ENABLE_MEDIAFWGSTREAMER
 const char *getGStreamerVersionString()
 {
 	return gst_version_string();
 }
+#endif
 
 #include <malloc.h>
 
diff --git a/mytest.py b/mytest.py
index 8e3fdcf..d9cb10a 100644
--- a/mytest.py
+++ b/mytest.py
@@ -302,6 +302,10 @@ class Session:
 
 		self.pushCurrent()
 		dlg = self.current_dialog = self.instantiateDialog(screen, *arguments, **kwargs)
+
+		if dlg is None:
+			return
+
 		dlg.isTmp = True
 		dlg.callback = None
 		self.execBegin()
@@ -510,10 +514,10 @@ def runScreenTest():
 	if wakeupList:
 		from time import strftime
 		startTime = wakeupList[0]
-		if (startTime[0] - nowTime) < 270: # no time to switch box back on
+		if (startTime[0] - nowTime) < 330: # no time to switch box back on
 			wptime = nowTime + 30  # so switch back on in 30 seconds
 		else:
-			wptime = startTime[0] - 240
+			wptime = startTime[0] - 300
 		if not config.misc.useTransponderTime.value:
 			print "dvb time sync disabled... so set RTC now to current linux time!", strftime("%Y/%m/%d %H:%M", localtime(nowTime))
 			setRTCtime(nowTime)
